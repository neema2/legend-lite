// Copyright 2026 Legend Lite Contributors
// SPDX-License-Identifier: Apache-2.0

import meta::pure::test::pct::*;
import meta::legend::lite::pct::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::metamodel::relation::*;

// Custom grammar extension for proper TDS serialization
function meta::legend::lite::pct::legendLiteGrammarExtension():GrammarExtension[1]
{
    ^GrammarExtension(
        extraInstanceValueHandlers = 
          [
            // Serialize TDS to #TDS\n...\n# format (original format without braces)
            t:TDS<Any>[1]|'#TDS\n'+$t.csv->replace(' ','')+'\n#'                     
          ]
    );
}

// Legend-Lite configuration with TDS grammar extension
function meta::legend::lite::pct::legendLiteGrammarConfiguration():Configuration[1]
{
  ^Configuration
  (
    fullPath = true,
    extensions = legendLiteGrammarExtension()  
  );
}

// Get simple type name from a generic type (e.g., Integer, String, Float)
function meta::legend::lite::pct::getSimpleTypeName(gt:GenericType[1]):String[1]
{
  let rawType = $gt.rawType->toOne();
  // Get just the simple name, not fully qualified
  if($rawType->instanceOf(PrimitiveType),
    | $rawType->cast(@PrimitiveType).name->toOne(),
    | if($rawType->instanceOf(Enumeration),
        | 'String', // Enums serialize as strings
        | 'String'  // Default fallback
      )
  );
}

// Build typed column header from expected return type
// This is needed to preserve column types when parsing TDS results
// Format: col1:Type,col2:Type (NO multiplicity - stringToTDS uses just Type names)
function meta::legend::lite::pct::buildTypedHeader(funcReturnType:GenericType[1]):String[0..1]
{
  if ($funcReturnType.rawType->toOne()->subTypeOf(Relation) && 
      $funcReturnType.typeArguments->at(0).rawType->toOne()->instanceOf(RelationType),
    | let relType = $funcReturnType.typeArguments->at(0).rawType->cast(@RelationType<Any>)->toOne();
      let columns = $relType.columns->map(col |
        let colName = $col.name->toOne();
        // Use simple type name (Integer, String, Float, Boolean) - NO multiplicity
        let colType = getSimpleTypeName($col->functionReturnType());
        $colName + ':' + $colType;
      );
      $columns->joinStrings(',');,
    | []
  );
}

// PCT Adapter for Legend-Lite
// This adapter serializes Pure functions to grammar text, executes through
// legend-lite's QueryService, and converts results back to Pure values.
function <<PCT.adapter>> {PCT.adapterName='LegendLite'} 
    meta::legend::lite::pct::testAdapterForLegendLiteExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
    // Serialize the full function definition to Pure grammar text
    // Use legendLiteGrammarConfiguration() to get proper TDS serialization support
    let config = legendLiteGrammarConfiguration();
    let pureText = $f->cast(@FunctionDefinition<Any>)
        ->printFunctionDefinition($config, ^GContext(space=''));
    
    // Debug: print the serialized Pure text
    print('[LegendLite PCT] Executing Pure expression: ' + $pureText + '\n');
    
    // Execute through Legend-Lite's QueryService via native bridge
    // Returns either:
    //   - TDSResult wrapper containing TDS string (for relation queries)
    //   - Scalar value directly (Integer, Float, Boolean, String)
    let result = executeLegendLiteQuery($pureText);
    
    // Check if this is a TDS result (wrapped in TDSResult class)
    if($result->instanceOf(TDSResult),
        | // For TDS results, build a properly typed TDS by constructing header from expected return type
          let tdsData = $result->cast(@TDSResult).tdsString;
          
          // Debug: print original TDS data from Java
          print('[LegendLite PCT] Original TDS data from Java: <<<' + $tdsData + '>>>\n');
          
          let typedHeader = buildTypedHeader($f->functionReturnType());
          
          // If we have type info, prepend the typed header to the data rows
          // Otherwise fall back to raw parsing (Java already provides col:Type format)
          let tdsString = if($typedHeader->isEmpty(),
            | $tdsData,
            | // Replace the first line (SQL-inferred types) with Pure-inferred types from return type
              let lines = $tdsData->split('\n');
              print('[LegendLite PCT] Lines after split: ' + $lines->size()->toString() + ' lines\n');
              if($lines->size() > 1,
                | let tail = $lines->tail();
                  print('[LegendLite PCT] Tail has: ' + $tail->size()->toString() + ' lines\n');
                  $typedHeader->toOne() + '\n' + $tail->joinStrings('\n');,
                | // No data rows, just return header
                  $typedHeader->toOne()
              );
          );
          
          print('[LegendLite PCT] TDS String for parsing: <<<' + $tdsString + '>>>\n');
          $tdsString->stringToTDS()->cast(@X)->toMultiplicity(@[o]);,
        | $result->cast(@X)->toMultiplicity(@[o])
    );
}
