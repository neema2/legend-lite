// Copyright 2026 Legend Lite Contributors
// SPDX-License-Identifier: Apache-2.0

import meta::pure::test::pct::*;
import meta::legend::lite::pct::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::metamodel::relation::*;

// PCT Adapter for Legend-Lite
// This adapter serializes Pure functions to grammar text, executes through
// legend-lite's QueryService, and converts results back to Pure values.
function <<PCT.adapter>> {PCT.adapterName='LegendLite'} 
    meta::legend::lite::pct::testAdapterForLegendLiteExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
    // Serialize the full function definition to Pure grammar text
    // Use configuration with fullPath=true for proper serialization
    let config = ^Configuration(fullPath = true);
    let pureText = $f->cast(@FunctionDefinition<Any>)
        ->printFunctionDefinition($config, ^GContext(space=''));
    
    // Execute through Legend-Lite's QueryService via native bridge
    // Returns either:
    //   - TDSResult wrapper containing TDS string (for relation queries)
    //   - Scalar value directly (Integer, Float, Boolean, String)
    let result = executeLegendLiteQuery($pureText);
    
    // Check if this is a TDS result (wrapped in TDSResult class)
    if($result->instanceOf(TDSResult),
        | $result->cast(@TDSResult).tdsString->stringToTDS()->cast(@X)->toMultiplicity(@[o]),
        | $result->cast(@X)->toMultiplicity(@[o])
    );
}
