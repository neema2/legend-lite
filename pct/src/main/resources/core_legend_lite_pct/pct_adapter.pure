// Copyright 2026 Legend Lite Contributors
// SPDX-License-Identifier: Apache-2.0

import meta::pure::test::pct::*;
import meta::legend::lite::pct::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::metamodel::relation::*;

// Custom grammar extension for proper TDS serialization
function meta::legend::lite::pct::legendLiteGrammarExtension():GrammarExtension[1]
{
    ^GrammarExtension(
        extraInstanceValueHandlers = 
          [
            // Serialize TDS to #TDS\n...\n# format (original format without braces)
            t:TDS<Any>[1]|'#TDS\n'+$t.csv+'\n#'                                          
          ]
    );
}

// Legend-Lite configuration with TDS grammar extension
function meta::legend::lite::pct::legendLiteGrammarConfiguration():Configuration[1]
{
  ^Configuration
  (
    fullPath = true,
    extensions = legendLiteGrammarExtension()  
  );
}

// Get simple type name from a generic type (e.g., Integer, String, Float, Variant)
// For non-primitive types like Variant, we must return the full path because stringToTDS()
// doesn't scan imports for type resolution.
function meta::legend::lite::pct::getSimpleTypeName(gt:GenericType[1]):String[1]
{
  let rawType = $gt.rawType->toOne();
  let typeName = $rawType->elementToPath();
  // Get just the simple name, not fully qualified
  if($rawType->instanceOf(PrimitiveType),
    | $rawType->cast(@PrimitiveType).name->toOne(),
    | if($rawType->instanceOf(Enumeration),
        | 'String', // Enums serialize as strings
        | // Check for Variant type - use full path because stringToTDS requires it
          if($typeName->contains('Variant'),
            | $typeName,  // Full path: meta::pure::metamodel::variant::Variant
            | 'String'    // Default fallback
          )
      )
  );
}

// Build typed column header from expected return type
// This is needed to preserve column types when parsing TDS results
// Format: col1:Type,col2:Type (NO multiplicity - stringToTDS uses just Type names)
function meta::legend::lite::pct::buildTypedHeader(funcReturnType:GenericType[1]):String[0..1]
{
  if ($funcReturnType.rawType->toOne()->subTypeOf(Relation) && 
      $funcReturnType.typeArguments->at(0).rawType->toOne()->instanceOf(RelationType),
    | let relType = $funcReturnType.typeArguments->at(0).rawType->cast(@RelationType<Any>)->toOne();
      let columns = $relType.columns->map(col |
        let colName = $col.name->toOne();
        // Quote column names containing '__|__' (pivot columns) with single quotes
        // Note: RelationType column names may already include quotes from Pure type system
        let quotedName = if($colName->startsWith('\''),
          | $colName,  // Already quoted
          | if($colName->contains('__|__'),
              | '\'' + $colName + '\'',
              | $colName
            )
        );
        // Use simple type name (Integer, String, Float, Boolean) - NO multiplicity
        let colType = getSimpleTypeName($col->functionReturnType());
        $quotedName + ':' + $colType;
      );
      $columns->joinStrings(',');,
    | []
  );
}

// Substitute open (captured) variables in the function's expression sequence
// This replaces VariableExpression nodes with their captured values from outer scope
function meta::legend::lite::pct::substituteOpenVariables(f:FunctionDefinition<Any>[1]):FunctionDefinition<Any>[1]
{
  // Get captured variables from closure (variables from outer scope)
  let openVars = $f->openVariableValues();
  
  if ($openVars->isEmpty(),
    | $f,
    | // Substitute variables in expression sequence
      let substitutedExprs = $f.expressionSequence->evaluateAndDeactivate()->map(e |
        substituteInExpression($e, $openVars->toOne())
      );
      ^$f(expressionSequence = $substitutedExprs->cast(@ValueSpecification)->toOneMany());
  );
}

// Recursively substitute variables in an expression
function meta::legend::lite::pct::substituteInExpression(expr:Any[1], openVars:Map<String, Any>[1]):Any[1]
{
  $expr->match([
    // Variable reference - check if it's in openVars and substitute
    v:VariableExpression[1] | 
      let value = $openVars->get($v.name);
      if ($value->isEmpty(),
        | $v,  // Not a captured variable, keep as-is
        | // Create InstanceValue with the captured value
          let capturedVal = $value->toOne()->cast(@List<Any>).values;
          ^InstanceValue(
            genericType = $capturedVal->genericType()->toOne(),
            multiplicity = if($capturedVal->size() == 1, |PureOne, |ZeroMany),
            values = $capturedVal
          );
      );,
      
    // Function expression - recursively substitute in parameters
    sfe:SimpleFunctionExpression[1] |
      let substitutedParams = $sfe.parametersValues->evaluateAndDeactivate()->map(p |
        substituteInExpression($p, $openVars)->cast(@ValueSpecification)
      );
      ^$sfe(parametersValues = $substitutedParams);,
      
    // Instance value - recursively substitute in nested values
    iv:InstanceValue[1] |
      let substitutedValues = $iv.values->map(v |
        $v->match([
          vs:ValueSpecification[1] | substituteInExpression($vs, $openVars),
          fd:FunctionDefinition<Any>[1] | 
            // Handle nested lambdas
            let substExprs = $fd.expressionSequence->evaluateAndDeactivate()->map(e |
              substituteInExpression($e, $openVars)
            );
            ^$fd(expressionSequence = $substExprs->cast(@ValueSpecification)->toOneMany());,
          a:Any[1] | $a
        ])
      );
      ^$iv(values = $substitutedValues);,
      
    // Lambda function - recursively substitute in body
    lf:LambdaFunction<Any>[1] |
      let substExprs = $lf.expressionSequence->evaluateAndDeactivate()->map(e |
        substituteInExpression($e, $openVars)
      );
      ^$lf(expressionSequence = $substExprs->cast(@ValueSpecification)->toOneMany());,
    
    // Pass through anything else
    a:Any[1] | $a
  ]);
}

// PCT Adapter for Legend-Lite
// This adapter serializes Pure functions to grammar text, executes through
// legend-lite's QueryService, and converts results back to Pure values.
function <<PCT.adapter>> {PCT.adapterName='LegendLite'} 
    meta::legend::lite::pct::testAdapterForLegendLiteExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
    // Substitute captured closure variables before serialization
    // This replaces VariableExpression nodes with their actual values
    let funcDef = $f->cast(@FunctionDefinition<Any>);
    let substituted = substituteOpenVariables($funcDef);
    
    // Serialize the substituted function definition to Pure grammar text
    let config = legendLiteGrammarConfiguration();
    let pureText = $substituted->printFunctionDefinition($config, ^GContext(space=''));
    
    // Debug: print the serialized Pure text
    print('[LegendLite PCT] Executing Pure expression: ' + $pureText + '\n');
    
    // Execute through Legend-Lite's QueryService via native bridge
    // Returns either:
    //   - TDSResult wrapper containing TDS string (for relation queries)
    //   - Scalar value directly (Integer, Float, Boolean, String)
    let result = executeLegendLiteQuery($pureText);
    
    // Check if this is a TDS result (wrapped in TDSResult class)
    if($result->instanceOf(TDSResult),
        | // For TDS results, build a properly typed TDS by constructing header from expected return type
          let tdsData = $result->cast(@TDSResult).tdsString;
          
          // Debug: print original TDS data from Java
          print('[LegendLite PCT] Original TDS data from Java: <<<' + $tdsData + '>>>\n');
          
          let typedHeader = buildTypedHeader($f->functionReturnType());
          
          // If we have type info, prepend the typed header to the data rows
          // Otherwise fall back to raw parsing (Java already provides col:Type format)
          let tdsString = if($typedHeader->isEmpty(),
            | $tdsData,
            | // Replace the first line (SQL-inferred types) with Pure-inferred types from return type
              let lines = $tdsData->split('\n');
              print('[LegendLite PCT] Lines after split: ' + $lines->size()->toString() + ' lines\n');
              if($lines->size() > 1,
                | let tail = $lines->tail();
                  print('[LegendLite PCT] Tail has: ' + $tail->size()->toString() + ' lines\n');
                  $typedHeader->toOne() + '\n' + $tail->joinStrings('\n');,
                | // No data rows, just return header
                  $typedHeader->toOne()
              );
          );
          
          print('[LegendLite PCT] TDS String for parsing: <<<' + $tdsString + '>>>\n');
          $tdsString->stringToTDS()->cast(@X)->toMultiplicity(@[o]);,
        | $result->cast(@X)->toMultiplicity(@[o])
    );
}

