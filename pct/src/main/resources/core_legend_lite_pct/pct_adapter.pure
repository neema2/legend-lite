// Copyright 2026 Legend Lite Contributors
// SPDX-License-Identifier: Apache-2.0

import meta::pure::test::pct::*;
import meta::legend::lite::pct::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::metamodel::relation::*;

// Marker class for captured class instances that need ^Class(...) serialization
// This allows us to target only captured variables, not all objects
Class meta::legend::lite::pct::CapturedInstance
{
  value: Any[1];
}

// Custom grammar extension for TDS and captured class instance serialization
function meta::legend::lite::pct::legendLiteGrammarExtension():GrammarExtension[1]
{
    ^GrammarExtension(
        extraInstanceValueHandlers = 
          [
            // Serialize TDS to #TDS\n...\n# format
            t:TDS<Any>[1]|'#TDS\n'+$t.csv+'\n#',
            // Serialize captured class instances to ^Class(prop=val) format
            c:CapturedInstance[1]|$c.value->objectToGrammar()
          ]
    );
}

// Convert any value to Pure grammar string representation
// For class instances, produces ^ClassName(prop1=val1, prop2=val2) syntax
function meta::legend::lite::pct::objectToGrammar(a:Any[1]):String[1]
{
  $a->match(
    [
       i:Integer[1] | $i->toRepresentation(),
       x:String[1] | $x->toRepresentation(),
       b:Boolean[1] | $b->toRepresentation(),
       f:Float[1] | $f->toRepresentation(),
       d:Date[1] | $d->toRepresentation(),
       e:Enum[1] | $e->type()->elementToPath()+'.'+$e.name,
       d:Decimal[1] | $d->toRepresentation(),
       a:Any[1] |
         let _type = $a->type()->cast(@Class<Any>);
         let properties = $_type->meta::pure::functions::meta::hierarchicalProperties();
         '^'+$a->type()->elementToPath()+'('+
          $properties->map(p| let value = $p->eval($a);
                              if ($value->isEmpty(),
                                |'',
                                |$p.name->toOne() + '=' + $value->map(w|$w->objectToGrammar())->joinStrings(',')
                              );
                       )->filter(v|$v != '')->joinStrings(',')+
        ')';
    ]
  );
}

// Legend-Lite configuration with TDS grammar extension
function meta::legend::lite::pct::legendLiteGrammarConfiguration():Configuration[1]
{
  ^Configuration
  (
    fullPath = true,
    extensions = legendLiteGrammarExtension()  
  );
}

// Get simple type name from a generic type (e.g., Integer, String, Float, Variant)
// For non-primitive types like Variant, we must return the full path because stringToTDS()
// doesn't scan imports for type resolution.
function meta::legend::lite::pct::getSimpleTypeName(gt:GenericType[1]):String[1]
{
  let rawType = $gt.rawType->toOne();
  let typeName = $rawType->elementToPath();
  // Get just the simple name, not fully qualified
  if($rawType->instanceOf(PrimitiveType),
    | $rawType->cast(@PrimitiveType).name->toOne(),
    | if($rawType->instanceOf(Enumeration),
        | 'String', // Enums serialize as strings
        | // Check for Variant type - use full path because stringToTDS requires it
          if($typeName->contains('Variant'),
            | $typeName,  // Full path: meta::pure::metamodel::variant::Variant
            | 'String'    // Default fallback
          )
      )
  );
}

// Build typed column header from expected return type
// This is needed to preserve column types when parsing TDS results
// Format: col1:Type,col2:Type (NO multiplicity - stringToTDS uses just Type names)
function meta::legend::lite::pct::buildTypedHeader(funcReturnType:GenericType[1]):String[0..1]
{
  if ($funcReturnType.rawType->toOne()->subTypeOf(Relation) && 
      $funcReturnType.typeArguments->at(0).rawType->toOne()->instanceOf(RelationType),
    | let relType = $funcReturnType.typeArguments->at(0).rawType->cast(@RelationType<Any>)->toOne();
      let columns = $relType.columns->map(col |
        let colName = $col.name->toOne();
        // Quote column names containing '__|__' (pivot columns) with single quotes
        // Note: RelationType column names may already include quotes from Pure type system
        let quotedName = if($colName->startsWith('\''),
          | $colName,  // Already quoted
          | if($colName->contains('__|__'),
              | '\'' + $colName + '\'',
              | $colName
            )
        );
        // Use simple type name (Integer, String, Float, Boolean) - NO multiplicity
        let colType = getSimpleTypeName($col->functionReturnType());
        $quotedName + ':' + $colType;
      );
      $columns->joinStrings(',');,
    | []
  );
}

// Substitute open (captured) variables in the function's expression sequence
// This replaces VariableExpression nodes with their captured values from outer scope
function meta::legend::lite::pct::substituteOpenVariables(f:FunctionDefinition<Any>[1]):FunctionDefinition<Any>[1]
{
  // Get captured variables from closure (variables from outer scope)
  let openVars = $f->openVariableValues();
  
  if ($openVars->isEmpty(),
    | $f,
    | // Substitute variables in expression sequence
      let substitutedExprs = $f.expressionSequence->evaluateAndDeactivate()->map(e |
        substituteInExpression($e, $openVars->toOne())
      );
      ^$f(expressionSequence = $substitutedExprs->cast(@ValueSpecification)->toOneMany());
  );
}

// Recursively substitute variables in an expression
function meta::legend::lite::pct::substituteInExpression(expr:Any[1], openVars:Map<String, Any>[1]):Any[1]
{
  $expr->match([
    // Variable reference - check if it's in openVars and substitute
    v:VariableExpression[1] | 
      let value = $openVars->get($v.name);
      if ($value->isEmpty(),
        | $v,  // Not a captured variable, keep as-is
        | // Create InstanceValue with the captured value
          let capturedVal = $value->toOne()->cast(@List<Any>).values;
          let valType = $capturedVal->genericType()->toOne().rawType->toOne();
          // For class instances (non-primitive, non-enum), wrap in CapturedInstance marker
          // This allows targeted serialization to ^Class(...) format
          let wrappedVal = if ($valType->instanceOf(Class) && 
                              !$valType->instanceOf(PrimitiveType) &&
                              !$valType->subTypeOf(Function) &&
                              !$valType->elementToPath()->startsWith('meta::pure::metamodel'),
                            | $capturedVal->map(v | ^CapturedInstance(value = $v)),
                            | $capturedVal
                           );
          ^InstanceValue(
            genericType = if($wrappedVal->at(0)->instanceOf(CapturedInstance),
                           | ^GenericType(rawType = CapturedInstance),
                           | $capturedVal->genericType()->toOne()),
            multiplicity = if($capturedVal->size() == 1, |PureOne, |ZeroMany),
            values = $wrappedVal
          );
      );,
      
    // Function expression - recursively substitute in parameters
    sfe:SimpleFunctionExpression[1] |
      let substitutedParams = $sfe.parametersValues->evaluateAndDeactivate()->map(p |
        substituteInExpression($p, $openVars)->cast(@ValueSpecification)
      );
      ^$sfe(parametersValues = $substitutedParams);,
      
    // Instance value - recursively substitute in nested values
    iv:InstanceValue[1] |
      let substitutedValues = $iv.values->map(v |
        $v->match([
          vs:ValueSpecification[1] | substituteInExpression($vs, $openVars),
          fd:FunctionDefinition<Any>[1] | 
            // Handle nested lambdas
            let substExprs = $fd.expressionSequence->evaluateAndDeactivate()->map(e |
              substituteInExpression($e, $openVars)
            );
            ^$fd(expressionSequence = $substExprs->cast(@ValueSpecification)->toOneMany());,
          a:Any[1] | $a
        ])
      );
      ^$iv(values = $substitutedValues);,
      
    // Lambda function - recursively substitute in body
    lf:LambdaFunction<Any>[1] |
      let substExprs = $lf.expressionSequence->evaluateAndDeactivate()->map(e |
        substituteInExpression($e, $openVars)
      );
      ^$lf(expressionSequence = $substExprs->cast(@ValueSpecification)->toOneMany());,
    
    // Pass through anything else
    a:Any[1] | $a
  ]);
}

// Convert a scalar result to the expected Pure type.
// Modeled after legend-engine's resultToType in pct_relational.pure.
// Handles: String→Integer, String→Float, String→Boolean, String→Nil,
// array strings like "[1, 2, 3]" → Integer[*], Integer→String, and Decimal→Float.
function meta::legend::lite::pct::resultToType(result: Any[1], type: GenericType[1], mult: Multiplicity[1]):Any[*]
{
  let resultType = $type.rawType->toOne();

  if ([
    // Expected Nil → empty collection
    pair(|$resultType == Nil, |[]),
    // String result that looks like array "[]" or "[1, 2, 3]" with toMany multiplicity → parse
    pair(|$result->instanceOf(String) && $result->cast(@String) == '[]', |[]),
    pair(|$result->instanceOf(String) && $result->cast(@String)->startsWith('[') && $result->cast(@String)->endsWith(']') && $mult->isToMany(),
         |let str = $result->cast(@String);
          let inner = $str->substring(1, $str->length()-1);
          if ($inner == '',
            | [],
            | let parts = $inner->split(',');
              if ($resultType->subTypeOf(Integer),
                | $parts->map(s|$s->trim()->parseInteger()),
                | if ($resultType->subTypeOf(Float) || $resultType->subTypeOf(Number),
                    | $parts->map(s|$s->trim()->parseFloat()),
                    | if ($resultType->subTypeOf(Boolean),
                        | $parts->map(s|$s->trim() == 'true'),
                        | $parts->map(s|$s->trim())
                      )
                  )
              );
          );),
    // String result, expected Integer → parse
    pair(|$result->instanceOf(String) && $resultType->subTypeOf(Integer), |$result->cast(@String)->parseInteger()),
    // String result, expected Float → parse
    pair(|$result->instanceOf(String) && $resultType->subTypeOf(Float), |$result->cast(@String)->parseFloat()),
    // String result, expected Boolean → parse
    pair(|$result->instanceOf(String) && $resultType->subTypeOf(Boolean), |$result->cast(@String) == 'true'),
    // String result, expected Number → parse as float
    pair(|$result->instanceOf(String) && $resultType->subTypeOf(Number), |$result->cast(@String)->parseFloat()),
    // Non-string result, expected String → convert to string
    pair(|$resultType->subTypeOf(String) && !$result->instanceOf(String), |$result->toString()),
    // Decimal/Number result but Float expected → convert
    pair(|$result->instanceOf(Number) && $resultType->subTypeOf(Float) && !$result->instanceOf(Float), |$result->cast(@Number)->toFloat()),
    // Number result but Integer expected → round
    pair(|$result->instanceOf(Number) && $resultType->subTypeOf(Integer) && !$result->instanceOf(Integer), |$result->cast(@Number)->round())
  ],
  | $result  // fallback: keep as-is
  );
}

// PCT Adapter for Legend-Lite
// This adapter serializes Pure functions to grammar text, executes through
// legend-lite's QueryService, and converts results back to Pure values.
function <<PCT.adapter>> {PCT.adapterName='LegendLite'} 
    meta::legend::lite::pct::testAdapterForLegendLiteExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
    // Substitute captured closure variables before serialization
    // This replaces VariableExpression nodes with their actual values
    let funcDef = $f->cast(@FunctionDefinition<Any>);
    let substituted = substituteOpenVariables($funcDef);
    
    // Serialize the substituted function definition to Pure grammar text
    let config = legendLiteGrammarConfiguration();
    let pureText = $substituted->printFunctionDefinition($config, ^GContext(space=''));
    
    // Debug: print the serialized Pure text
    print('[LegendLite PCT] Executing Pure expression: ' + $pureText + '\n');
    
    // Execute through Legend-Lite's QueryService via native bridge
    // Returns either:
    //   - TDSResult wrapper containing TDS string (for relation queries)
    //   - Scalar value directly (Integer, Float, Boolean, String)
    let result = executeLegendLiteQuery($pureText);
    
    // Check if this is a TDS result (wrapped in TDSResult class)
    if($result->instanceOf(TDSResult),
        | // For TDS results, build a properly typed TDS by constructing header from expected return type
          let tdsData = $result->cast(@TDSResult).tdsString;
          
          // Debug: print original TDS data from Java
          print('[LegendLite PCT] Original TDS data from Java: <<<' + $tdsData + '>>>\n');
          
          let typedHeader = buildTypedHeader($f->functionReturnType());
          
          // If we have type info, prepend the typed header to the data rows
          // Otherwise fall back to raw parsing (Java already provides col:Type format)
          let tdsString = if($typedHeader->isEmpty(),
            | $tdsData,
            | // Replace the first line (SQL-inferred types) with Pure-inferred types from return type
              let lines = $tdsData->split('\n');
              print('[LegendLite PCT] Lines after split: ' + $lines->size()->toString() + ' lines\n');
              if($lines->size() > 1,
                | let tail = $lines->tail();
                  print('[LegendLite PCT] Tail has: ' + $tail->size()->toString() + ' lines\n');
                  $typedHeader->toOne() + '\n' + $tail->joinStrings('\n');,
                | // No data rows, just return header
                  $typedHeader->toOne()
              );
          );
          
          print('[LegendLite PCT] TDS String for parsing: <<<' + $tdsString + '>>>\n');
          $tdsString->stringToTDS()->cast(@X)->toMultiplicity(@[o]);,
        | let converted = resultToType($result, $f->functionReturnType(), $f->functionReturnMultiplicity());
          $converted->cast(@X)->toMultiplicity(@[o]);
    );
}

