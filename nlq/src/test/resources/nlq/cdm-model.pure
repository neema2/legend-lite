// ═══════════════════════════════════════════════════════════
// ISDA Common Domain Model (CDM) — Auto-generated from Rosetta DSL
// Source: 741 types from finos/common-domain-model
// ═══════════════════════════════════════════════════════════

Profile nlq::NlqProfile
{
    stereotypes: [dimension, metric];
    tags: [description, synonyms, sampleValues, unit, importance, businessDomain, exampleQuestions, whenToUse];
}

Enum party::AccountTypeEnum
{
    AggregateClient,
    Client,
    House
}

Enum event::ActionEnum
{
    New,
    Correct,
    Cancel
}

Enum csa::AdditionalTerminationEventEnum
{
    FailureToNotifyNAV,
    InvestmentAdvisor,
    KeyPersons,
    NAVDeclineTrigger,
    NAVFloor,
    OperativeDocs,
    RatingsDowngradeOrWithdrawalParty1,
    RatingsDowngradeOrWithdrawalParty2,
    AsApplicable,
    AsSpecified
}

Enum csa::AdditionalTypeEnum
{
    NotApplicable,
    EquityOptionOrIndexOption,
    Other
}

Enum event::AffirmationStatusEnum
{
    Affirmed,
    Unaffirmed
}

Enum collateral::AlternativeToInterestAmountEnum
{
    Standard,
    ActualAmountReceived,
    TransferIfDeliveryAmountBelowMTA,
    Other
}

Enum csa::AmendmentEffectiveDateEnum
{
    AnnexDate,
    DeedDate,
    AgreementDate,
    AmendmentEffectiveDate
}

Enum party::AncillaryRoleEnum
{
    DisruptionEventsDeterminingParty,
    ExtraordinaryDividendsParty,
    PredeterminedClearingOrganizationParty,
    ExerciseNoticeReceiverPartyManual,
    ExerciseNoticeReceiverPartyOptionalEarlyTermination,
    ExerciseNoticeReceiverPartyCancelableProvision,
    ExerciseNoticeReceiverPartyExtendibleProvision,
    CalculationAgentIndependent,
    CalculationAgentOptionalEarlyTermination,
    CalculationAgentMandatoryEarlyTermination,
    CalculationAgentFallback
}

Enum math::ArithmeticOperationEnum
{
    Add,
    Subtract,
    Multiply,
    Divide,
    Max,
    Min
}

Enum asset::AssetBackedEnum
{
    HomeEquity,
    AutoLoan,
    StudentLoan,
    CreditCard,
    Property,
    Mortgage,
    Other
}

Enum asset::AssetClassEnum
{
    Commodity,
    Credit,
    Equity,
    ForeignExchange,
    InterestRate,
    MoneyMarket
}

Enum asset::AssetIdTypeEnum
{
    CurrencyCode,
    ExchangeCode,
    ClearingCode
}

Enum template::AssetPayoutTradeTypeEnum
{
    Repo,
    BuySellBack
}

Enum event::AssetTransferTypeEnum
{
    FreeOfPayment
}

Enum asset::AssetTypeEnum
{
    Security,
    Cash,
    Commodity,
    Other
}

Enum position::AvailableInventoryTypeEnum
{
    AvailableToLend,
    RequestToBorrow
}

Enum collateral::AverageTradingVolumeMethodologyEnum
{
    Single,
    Consolidated
}

Enum math::AveragingCalculationMethodEnum
{
    Arithmetic,
    Geometric,
    Harmonic
}

Enum template::AveragingInOutEnum
{
    In,
    Out,
    Both
}

Enum math::AveragingWeightingMethodEnum
{
    Unweighted,
    Weighted
}

Enum product::BankHolidayTreatmentEnum
{
    AsWeekday,
    AsWeekend
}

// BrokerConfirmationTypeEnum has 87 values, showing first 50
Enum legaldoc::BrokerConfirmationTypeEnum
{
    ABX,
    AsiaCorporate,
    AsiaSovereign,
    AustraliaCorporate,
    AustraliaSovereign,
    CDSonLeveragedLoans,
    CDSonMBS,
    CDXEmergingMarkets,
    CDXEmergingMarketsDiversified,
    CDXSwaption,
    CDXTranche,
    CMBX,
    DJ_CDX_EM_,
    DJ_CDX_NA,
    EmergingEuropeanAndMiddleEasternSovereign,
    EmergingEuropeanCorporate,
    EmergingEuropeanCorporateLPN,
    EuropeanCMBS,
    EuropeanCorporate,
    EuropeanRMBS,
    JapanCorporate,
    JapanSovereign,
    LatinAmericaCorporate,
    LatinAmericaCorporateBond,
    LatinAmericaCorporateBondOrLoan,
    LatinAmericaSovereign,
    MBX,
    MCDX,
    NewZealandCorporate,
    NewZealandSovereign,
    NorthAmericanCorporate,
    PO,
    SingaporeCorporate,
    SingaporeSovereign,
    StandardAsiaCorporate,
    StandardAsiaSovereign,
    StandardAustraliaCorporate,
    StandardAustraliaSovereign,
    StandardCDXTranche,
    StandardEmergingEuropeanAndMiddleEasternSovereign,
    StandardEmergingEuropeanCorporate,
    StandardEmergingEuropeanCorporateLPN,
    StandardEuropeanCorporate,
    StandardJapanCorporate,
    StandardJapanSovereign,
    StandardLCDS,
    StandardLCDSBullet,
    StandardLCDXBullet,
    StandardLCDXBulletTranche,
    StandardLatinAmericaCorporateBond
}

// BusinessCenterEnum has 212 values, showing first 50
Enum datetime::BusinessCenterEnum
{
    AEAB,
    AEAD,
    AEDU,
    AMYE,
    AOLU,
    ARBA,
    ATVI,
    AUAD,
    AUBR,
    AUCA,
    AUDA,
    AUME,
    AUPE,
    AUSY,
    AZBA,
    BBBR,
    BDDH,
    BEBR,
    BGSO,
    BHMA,
    BMHA,
    BNBS,
    BOLP,
    BRBD,
    BRBR,
    BRRJ,
    BRSP,
    BSNA,
    BWGA,
    BYMI,
    CACL,
    CAFR,
    CAMO,
    CAOT,
    CATO,
    CAVA,
    CAWI,
    CHBA,
    CHGE,
    CHZU,
    CIAB,
    CLSA,
    CMYA,
    CNBE,
    CNSH,
    COBO,
    CRSJ,
    CWWI,
    CYNI,
    CZPR
}

Enum datetime::BusinessDayConventionEnum
{
    FOLLOWING,
    FRN,
    MODFOLLOWING,
    PRECEDING,
    MODPRECEDING,
    NEAREST,
    NONE,
    NotApplicable
}

Enum csa::CSASpecifiedOrAccessConditionEnum
{
    Illegality,
    TaxEvent,
    TaxEventUponMerger,
    CreditEventUponMerger,
    AdditionalTerminationEvents,
    ForceMajeureEvent,
    PotentialTerminationEvents
}

Enum observable::CalculationMethodEnum
{
    Averaging,
    Compounding,
    CompoundedIndex
}

Enum observable::CalculationShiftMethodEnum
{
    Lookback,
    ObservationPeriodShift,
    RateCutOff,
    NoShift
}

Enum csa::CalculationValuationAgentPartyEnum
{
    Party1,
    Party2,
    PartyMakingDemand
}

Enum event::CallTypeEnum
{
    MarginCall,
    Notification,
    ExpectedCall
}

Enum template::CallingPartyEnum
{
    InitialBuyer,
    InitialSeller,
    Either,
    AsDefinedInMasterAgreement
}

// CapacityUnitEnum has 66 values, showing first 50
Enum math::CapacityUnitEnum
{
    ALW,
    BBL,
    BCF,
    BDFT,
    CBM,
    CER,
    CRT,
    DAG,
    DAY,
    DMTU,
    ENVCRD,
    ENVOFST,
    FEU,
    G,
    GBBSH,
    GBBTU,
    GBCWT,
    GBGAL,
    GBMBTU,
    GBMMBTU,
    GBT,
    GBTHM,
    GJ,
    GW,
    GWH,
    HL,
    HOGB,
    ISOBTU,
    ISOMBTU,
    ISOMMBTU,
    ISOTHM,
    J,
    KG,
    KL,
    KW,
    KWD,
    KWH,
    KWM,
    KWMIN,
    KWY,
    L,
    LB,
    MB,
    MBF,
    MJ,
    MMBF,
    MMBBL,
    MSF,
    MT,
    MW
}

Enum csa::CashCTSTimeEnum
{
    Same,
    Next,
    FirstLBD,
    SecondLBD,
    Other
}

Enum settlement::CashSettlementMethodEnum
{
    CashPriceMethod,
    CashPriceAlternateMethod,
    ParYieldCurveAdjustedMethod,
    ZeroCouponYieldAdjustedMethod,
    ParYieldCurveUnadjustedMethod,
    CrossCurrencyMethod,
    CollateralizedCashPriceMethod,
    MidMarketIndicativeQuotations,
    MidMarketIndicativeQuotationsAlternate,
    MidMarketCalculationAgentDetermination,
    ReplacementValueFirmQuotations,
    ReplacementValueCalculationAgentDetermination
}

Enum event::ClosedStateEnum
{
    Allocated,
    Cancelled,
    Exercised,
    Expired,
    Matured,
    Novated,
    Terminated
}

// CollateralAssetDefinitionsEnum has 178 values, showing first 50
Enum csa::CollateralAssetDefinitionsEnum
{
    AU_CASH,
    AU_CIB,
    AU_FIB,
    AU_FRB,
    AU_ILB,
    AU_NOTE,
    AU_STATENOTE,
    AU_TAB,
    BE_BEL20,
    BE_CERT,
    BE_LINEAR,
    BE_NOTE,
    BE_REGIONGT,
    BE_STATEGT,
    BE_STATELOAN,
    CA_BOND,
    CA_CASH,
    CA_RRB,
    CA_TBILL,
    CH_CANTON,
    CH_CASH,
    CH_FEDBOND,
    DE_BILL,
    DE_BOND,
    DE_ERBLAST,
    DE_MUNI,
    DE_NOTE2,
    DE_NOTE5_5,
    DE_PFAND,
    DK_BILL,
    DK_BOLIGX,
    DK_BOND,
    DK_CALLMORT,
    DK_CASH,
    DK_KFX,
    DK_MORT,
    DK_NOTE,
    ES_BILL,
    ES_BOND,
    ES_CEDULAS,
    ES_CORP,
    ES_EQUITY,
    EU_CASH,
    EU_EURO100,
    EU_EUROTOP300,
    EU_STOXX50,
    EU_STOXX600,
    FI_BILL,
    FI_BOND,
    FI_HEX
}

Enum asset::CollateralEntityTypeEnum
{
    SupraNational,
    SovereignCentralBank,
    QuasiGovernment,
    RegionalGovernment,
    Corporate,
    Fund,
    SpecialPurposeVehicle
}

Enum collateral::CollateralInterestHandlingEnum
{
    Transfer,
    Adjust,
    Transfer_or_Adjust
}

Enum collateral::CollateralMarginTypeEnum
{
    VariationMargin,
    InitialMargin
}

Enum event::CollateralStatusEnum
{
    FullAmount,
    SettledAmount,
    InTransitAmount
}

Enum collateral::CollateralTypeEnum
{
    Cash,
    NonCash,
    CashPool
}

Enum asset::CollateralizedObligationEnum
{
    CDO,
    CMO,
    CLO,
    CBO
}

// CommodityBusinessCalendarEnum has 115 values, showing first 50
Enum datetime::CommodityBusinessCalendarEnum
{
    ADSM,
    AGRUS_FMB,
    APPI,
    ARGUS_CRUDE,
    ARGUS_EUROPEAN_GAS,
    ARGUS_EUROPEAN_PRODUCTS,
    ARGUS_INTERNATIONAL_LPG,
    ARGUS_MCCLOSKEYS_COAL_REPORT,
    ARGUS_US_PRODUCTS,
    ASX,
    AWB,
    AWEX,
    BALTIC_EXCHANGE,
    BANK_NEGARA_MALAYSIA_POLICY_COMMITTEE,
    BELPEX,
    BLUENEXT,
    BM_F,
    BURSA_MALAYSIA_SETTLEMENT,
    BURSA_MALAYSIA_TRADING,
    CANADIAN_GAS_PRICE_REPORTER,
    CBOT_SOFT,
    CMAI_AROMATICS_MARKET_REPORT,
    CMAI_GLOBAL_PLASTICS_AND_POLYMERS_MARKET_REPORT,
    CMAI_METHANOL_MARKET_REPORT,
    CMAI_MONOMERS_MARKET_REPORT,
    CME_DAIRY,
    CME_NON_DAIRY_SOFT,
    COMEX,
    CRU,
    CRU_LONG,
    DEPARTMENT_OF_ENERGY,
    DEWITT_BENZENE_DERIVATIVES,
    DME,
    DOW_JONES,
    DOW_JONES_ENERGY_SERVICE,
    DowJonesPower,
    EEX_COAL,
    EEX_EMISSIONS,
    EEX_GAS,
    EEX_POWER,
    EURONEX_MATIF,
    FERTECON,
    FERTILIZER_WEEK,
    GAS_DAILY,
    GAS_DAILY_PRICE_GUIDE,
    GLOBALCOAL,
    HEREN_REPORT,
    ICE_10X_DAILY,
    ICE_10X_MONTHLY,
    ICE_CANADA
}

// CommodityInformationPublisherEnum has 107 values, showing first 50
Enum asset::CommodityInformationPublisherEnum
{
    Argus,
    ArgusMcCloskeys,
    ArgusAmericasCrudeReport,
    ArgusBiofuelReport,
    ArgusCrudeReport,
    ArgusEuropeanProductsReport,
    ArgusFMB,
    ArgusInternationalLPGReport,
    ArgusLPG,
    ArgusNatGas,
    AssocBanksSingapore,
    BandD,
    BalticExchange,
    BankOfCanada,
    BankOfEngland,
    BankOfJapan,
    Bloomberg,
    BLUENEXT,
    CAISO,
    CanadianGasPriceReporter,
    CanadianGasReporter,
    ChemicalMarketsAssociation,
    CMAIAromaticsMarketReport,
    CMAIWeeklyMethanolMarketReport,
    CRUSteelLongProductMonitor,
    CRUSteelSheetProductsMonitor,
    DowJonesEnergyService,
    DowJonesEnergyServiceScreen,
    DowJonesNatGas,
    EEX,
    ERCOT,
    EuroCentralBank,
    EURONEXMATIF,
    FederalReserve,
    FERTECON,
    FertilizerWeek,
    FHLBSF,
    GasDaily,
    GasDailyPriceGuide,
    GlobalCoale,
    GME,
    HerenReport,
    ICE,
    ICE10XDailyNaturalGas,
    ICE10XDailyPower,
    ICE10XMonthly,
    ICEDayAheadIndex,
    ICEECX,
    ICIS,
    InsideFERC
}

Enum identifier::CommodityLocationIdentifierTypeEnum
{
    DeliveryPoint,
    EntryPoint,
    InterconnectionPoint,
    WithdrawalPoint,
    DeliveryZone,
    BuyerHub,
    SellerHub
}

Enum observable::CommodityReferencePriceEnum
{
    ALUMINIUM_ALLOY_LME_15_MONTH,
    COAL_CENTRAL_APPALACHIAN_NYMEX,
    COCOA_ICE,
    COFFEE_ARABICA_ICE,
    COFFEE_ROBUSTA_ICE,
    COPPER_COMEX,
    CORN_CBOT,
    COTTON_NO__2_ICE,
    ETHANOL_CBOT,
    FEEDER_CATTLE_CME,
    FROZEN_CONCENTRATED_ORANGE_JUICE_NO__1_ICE,
    GASOLINE_RBOB_NEW_YORK_ICE,
    GASOLINE_RBOB_NEW_YORK_NYMEX,
    GOLD_COMEX,
    HEATING_OIL_NEW_YORK_NYMEX,
    LEAN_HOGS_CME,
    LIVE_CATTLE_CME,
    LUMBER_CME,
    MILK_CLASS_III_CME,
    MILK_NONFAT_DRY_CME,
    NATURAL_GAS_NYMEX,
    NATURAL_GAS_PEPL__TEXOK_MAINLINE__INSIDE_FERC,
    NATURAL_GAS_W__TEXAS__WAHA__INSIDE_FERC,
    OATS_CBOT,
    OIL_WTI_NYMEX,
    PALLADIUM_NYMEX,
    PLATINUM_NYMEX,
    RICE_CBOT,
    SILVER_COMEX,
    SOYBEANS_CBOT,
    SOYBEAN_MEAL_CBOT,
    SOYBEAN_OIL_CBOT,
    SUGAR___11__WORLD__ICE,
    SUGAR___16__US__ICE,
    WHEAT_CBOT,
    WHEAT_HRW_KCBOT,
    WHEAT_RED_SPRING_MGE
}

Enum math::CompareOp
{
    GreaterThan,
    GreaterThanOrEquals,
    Equals,
    LessThanOrEquals,
    LessThan
}

Enum product::CompoundingMethodEnum
{
    Flat,
    None,
    Straight,
    SpreadExclusive
}

Enum datetime::CompoundingTypeEnum
{
    None,
    Business,
    Calendar
}

Enum collateral::ConcentrationLimitTypeEnum
{
    Asset,
    BaseCurrencyEquivalent,
    Issuer,
    PrimaryExchange,
    IndustrySector,
    UltimateParentInstitution,
    IssueOutstandingAmount,
    MarketCapitalisation,
    OutstandingBalance
}

Enum event::ConfirmationStatusEnum
{
    Confirmed,
    Unconfirmed
}

Enum legaldoc::ContractualDefinitionsEnum
{
    ISDA1991InterestRate,
    ISDA1993CommodityDerivatives,
    ISDA1996EquityDerivatives,
    ISDA1997Bullion,
    ISDA1997GovernmentBondOption,
    ISDA1998FxAndCurrencyOption,
    ISDA1999CreditDerivatives,
    ISDA2000,
    ISDA2002EquityDerivatives,
    ISDA2003CreditDerivatives,
    ISDA2004Novation,
    ISDA2005Commodity,
    ISDA2006,
    ISDA2006InflationDerivatives,
    ISDA2008InflationDerivatives,
    ISDA2011EquityDerivatives,
    ISDA2014CreditDerivatives,
    ISDA2021InterestRateDerivatives,
    ISDA2022VerifiedCarbonCredit,
    ISDA2023DigitalAssetDerivatives
}

// ContractualSupplementTypeEnum has 73 values, showing first 50
Enum legaldoc::ContractualSupplementTypeEnum
{
    ABX,
    ABXTranche,
    CDSonLeveragedLoans,
    CDSonMBS,
    CDX,
    CDXEmergingMarkets,
    CDXEmergingMarketsDiversified,
    CDXSwaption,
    CDXTranche,
    CMBX,
    EuropeanCMBS,
    EuropeanRMBS,
    IOS,
    ISDA1999CreditConvertibleExchangeableAccretingObligations,
    ISDA1999CreditRestructuring,
    ISDA1999CreditSuccessorAndCreditEvents,
    ISDA2003AdditionalProvisionsLPN,
    ISDA2003ContingentCreditSpreadTransaction,
    ISDA2003Credit2005MatrixSupplement,
    ISDA2003CreditArgentineRepublic,
    ISDA2003CreditAuctionSupplement,
    ISDA2003CreditMay2003,
    ISDA2003CreditMonolineInsurers,
    ISDA2003CreditMonolineInsurers2005,
    ISDA2003CreditRepublicOfHungary,
    ISDA2003CreditRepublicOfHungary2005,
    ISDA2003CreditRussianFederation,
    ISDA2003CreditUSMunicipals,
    ISDA2003STMicroelectronicsNV,
    ISDA2007FullLookthroughDepositoryReceiptSupplement,
    ISDA2007PartialLookthroughDepositoryReceiptSupplement,
    ISDACreditMonolineInsurers,
    ISDADeliveryRestrictions,
    ISDAFixedRecovery,
    ISDALPNReferenceEntities,
    ISDAMarch2004EquityCanadianSupplement,
    ISDARecoveryLock,
    ISDASecuredDeliverableObligationCharacteristic,
    LCDX,
    LCDXTranche,
    MBX,
    MCDX,
    PO,
    PrimeX,
    StandardCDXTranche,
    StandardLCDS,
    StandardLCDSBullet,
    StandardLCDXBullet,
    StandardLCDXBulletTranche,
    StandardiTraxxEuropeTranche
}

Enum event::CorporateActionTypeEnum
{
    CashDividend,
    StockDividend,
    StockSplit,
    ReverseStockSplit,
    SpinOff,
    Merger,
    Delisting,
    StockNameChange,
    StockIdentifierChange,
    RightsIssue,
    Takeover,
    StockReclassification,
    BonusIssue,
    ClassAction,
    EarlyRedemption,
    Liquidation,
    BankruptcyOrInsolvency,
    IssuerNationalization,
    Relisting,
    BespokeEvent
}

Enum party::CounterpartyRoleEnum
{
    Party1,
    Party2
}

Enum asset::CoveredBondEnum
{
    Pfandbriefe,
    JumboPfandbriefe
}

Enum event::CreditEventTypeEnum
{
    Bankruptcy,
    DistressedRatingsDowngrade,
    FailureToPay,
    FailureToPayInterest,
    FailureToPayPrincipal,
    GovernmentalIntervention,
    ImpliedWritedown,
    MaturityExtension,
    ObligationAcceleration,
    ObligationDefault,
    RepudiationMoratorium,
    Restructuring,
    Writedown
}

Enum workflow::CreditLimitTypeEnum
{
    CS01,
    DV01,
    IM,
    Notional,
    NPV,
    PV01
}

Enum observable::CreditNotationBoundaryEnum
{
    Minimum,
    Maximum
}

Enum observable::CreditNotationMismatchResolutionEnum
{
    Lowest,
    Highest,
    ReferenceAgency,
    Average,
    SecondBest,
    Other
}

Enum observable::CreditRatingAgencyEnum
{
    AMBest,
    CBRS,
    DBRS,
    Fitch,
    Japanagency,
    Moodys,
    RatingAndInvestmentInformation,
    StandardAndPoors
}

Enum observable::CreditRatingCreditWatchEnum
{
    Positive,
    Negative,
    Developing
}

Enum observable::CreditRatingOutlookEnum
{
    Positive,
    Negative,
    Stable,
    Developing
}

Enum asset::CreditRiskEnum
{
    TranchedCreditRisk,
    UntranchedCreditRisk
}

Enum product::CreditSeniorityEnum
{
    Other,
    SeniorLossAbsorbingCapacity,
    SeniorSec,
    SeniorUnSec,
    SubLowerTier2,
    SubTier1,
    SubTier3,
    SubUpperTier2
}

Enum collateral::CreditSupportAgreementTypeEnum
{
    CreditSupportDeed,
    CreditSupportAnnex,
    CollateralTransferAgreement
}

Enum csa::CreditSupportAmountEnum
{
    Standard,
    IAFloorGIA,
    IAFloorGIATIA,
    NonStandardRatings,
    NonStandardOther
}

Enum legaldoc::CreditSupportDocumentTermsEnum
{
    Specified,
    Any,
    None
}

Enum legaldoc::CreditSupportProviderTermsEnum
{
    Specified,
    Any,
    None
}

Enum observable::CsaTypeEnum
{
    NoCSA,
    ExistingCSA,
    ReferenceVMCSA
}

Enum asset::CurrencyCodeEnum
{
    CNH,
    CNT,
    GGP,
    IMP,
    JEP,
    KID,
    MCF,
    SML,
    VAL
}

Enum other::DayCountFractionEnum
{
    ACT_360,
    ACT_365L,
    ACT_364,
    ACT_365_FIXED,
    ACT_ACT_AFB,
    ACT_ACT_ICMA,
    ACT_ACT_ISDA,
    ACT_ACT_ISMA,
    CAL_252,
    _1_1,
    _30E_360,
    _30E_360_ISDA,
    _30_360,
    RBA_BOND_BASIS
}

Enum product::DayDistributionEnum
{
    All,
    First,
    Last,
    Penultimate
}

Enum datetime::DayOfWeekEnum
{
    MON,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
}

Enum datetime::DayTypeEnum
{
    Business,
    Calendar,
    CurrencyBusiness,
    ExchangeBusiness,
    ScheduledTradingDay
}

Enum asset::DebtClassEnum
{
    RegCap,
    Structured,
    Vanilla
}

Enum asset::DebtInterestEnum
{
    Fixed,
    Floating,
    InflationLinked,
    IndexLinked,
    InterestOnly,
    OtherStructured,
    InverseFloating,
    ZeroCoupon
}

Enum asset::DebtPrincipalEnum
{
    Bullet,
    Callable,
    Puttable,
    Amortising,
    InflationLinked,
    IndexLinked,
    OtherStructured,
    PrincipalOnly
}

Enum asset::DebtSeniorityEnum
{
    Secured,
    Senior,
    Subordinated
}

Enum collateral::DeliveryAmountElectionEnum
{
    LastLocalBusinessDay,
    LastAndAnyLocalBusinessDay
}

Enum settlement::DeliveryMethodEnum
{
    DeliveryVersusPayment,
    FreeOfPayment,
    PreDelivery,
    PrePayment
}

Enum asset::DeliveryNearbyTypeEnum
{
    CalculationPeriod,
    NearbyMonth,
    NearbyWeek
}

Enum csa::DeliveryReturnAmountEnum
{
    Standard,
    NonStandardRatings,
    NonStandardOther
}

Enum asset::DepositaryReceiptTypeEnum
{
    ADR,
    GDR,
    IDR,
    EDR
}

Enum observable::DeterminationMethodEnum
{
    AgreedInitialPrice,
    AsSpecifiedInMasterConfirmation,
    CalculationAgent,
    ClosingPrice,
    DividendCurrency,
    ExpiringContractLevel,
    HedgeExecution,
    IssuerPaymentCurrency,
    NAV,
    OpenPrice,
    OSPPrice,
    SettlementCurrency,
    StrikeDateDetermination,
    TWAPPrice,
    ValuationTime,
    VWAPPrice
}

Enum legaldoc::DeterminationRoleEnum
{
    CalculationAgent,
    HedgingParty,
    DeterminingParty
}

Enum product::DiscountingTypeEnum
{
    Standard,
    FRA,
    FRAYield,
    AFMA
}

Enum product::DividendAmountTypeEnum
{
    RecordAmount,
    ExAmount,
    PaidAmount,
    AsSpecifiedInMasterConfirmation
}

Enum product::DividendCompositionEnum
{
    EquityAmountReceiverElection,
    CalculationAgentElection
}

Enum product::DividendDateReferenceEnum
{
    AdHocDate,
    CashSettlementPaymentDate,
    CashSettlePaymentDateExDiv,
    CashSettlePaymentDateIssuerPayment,
    CumulativeEquityExDiv,
    CumulativeEquityPaid,
    CumulativeEquityExDivBeforeReset,
    CumulativeEquityPaidBeforeReset,
    CumulativeEquityPaidInclReset,
    CumulativeInterestExDiv,
    CumulativeInterestPaid,
    CumulativeInterestPaidInclReset,
    CumulativeInterestPaidBeforeReset,
    DividendPaymentDate,
    DividendValuationDate,
    EquityPaymentDate,
    ExDate,
    FloatingAmountPaymentDate,
    FollowingPaymentDate,
    RecordDate,
    SharePayment,
    TerminationDate,
    TradeDate,
    UnwindOrEquityExDiv,
    UnwindOrEquityPaid,
    UnwindOrInterestExDiv,
    UnwindOrInterestPaid,
    UnwindExDiv,
    UnwindPaid
}

Enum product::DividendEntitlementEnum
{
    ExDate,
    RecordDate
}

Enum product::DividendPeriodEnum
{
    FirstPeriod,
    SecondPeriod
}

Enum asset::EU_EMIR_EligibleCollateralEnum
{
    EU_EMIRTypeA,
    EU_EMIRTypeB,
    EU_EMIRTypeC,
    EU_EMIRTypeD,
    EU_EMIRTypeE,
    EU_EMIRTypeF,
    EU_EMIRTypeG,
    EU_EMIRTypeH,
    EU_EMIRTypeI,
    EU_EMIRTypeJ,
    EU_EMIRTypeK,
    EU_EMIRTypeL,
    EU_EMIRTypeM,
    EU_EMIRTypeN,
    EU_EMIRTypeO,
    EU_EMIRTypeP,
    EU_EMIRTypeQ,
    EU_EMIRTypeR
}

Enum csa::ElectiveAmountEnum
{
    Zero,
    Unlimited
}

Enum party::EntityIdentifierTypeEnum
{
    REDID,
    CountryCode,
    Other
}

Enum party::EntityTypeEnum
{
    Asian,
    AustralianAndNewZealand,
    EuropeanEmergingMarkets,
    Japanese,
    NorthAmericanHighYield,
    NorthAmericanInsurance,
    NorthAmericanInvestmentGrade,
    Singaporean,
    WesternEuropean,
    WesternEuropeanInsurance
}

// EquityIndexEnum has 342 values, showing first 50
Enum other::EquityIndexEnum
{
    AEX,
    ALLORD,
    AMSMID,
    AASHR,
    ASCIX,
    ARBG,
    ARGMI,
    ATHEX,
    ATX50,
    ATX,
    BEL20,
    BELAS,
    BELMD,
    BGBEL,
    BELSM,
    BGREIT,
    BULG30,
    BGBX40,
    TRKSTN,
    TIN30,
    BKADR,
    BKBRIC,
    BUMIX,
    BUDPES,
    PBVGEN,
    CAC40,
    FCASH,
    SBF250,
    CACL60,
    CAC190,
    FCAM,
    CAC20,
    CSM90,
    CDAX,
    CECE,
    CINT10,
    CSMGL,
    CSMST,
    CNX100,
    MILBCI,
    CZSEC,
    CSI500,
    CZT,
    DAX,
    DJTB30,
    DOWCOM,
    DOWI,
    DJT30,
    DJTCOM,
    DOWTRA
}

Enum asset::EquityTypeEnum
{
    Ordinary,
    NonConvertiblePreference,
    DepositaryReceipt,
    ConvertiblePreference
}

Enum event::EventIntentEnum
{
    Allocation,
    CashFlow,
    Clearing,
    Compression,
    ContractFormation,
    ContractTermsAmendment,
    CorporateActionAdjustment,
    CreditEvent,
    Decrease,
    EarlyTerminationProvision,
    Increase,
    IndexTransition,
    NotionalReset,
    NotionalStep,
    Novation,
    ObservationRecord,
    OptionExercise,
    OptionalExtension,
    OptionalCancellation,
    PortfolioRebalancing,
    PrincipalExchange,
    Reallocation,
    Repurchase
}

Enum workflow::EventTimestampQualificationEnum
{
    clearingDateTime,
    clearingConfirmationDateTime,
    clearingReceiptDateTime,
    clearingSubmissionDateTime,
    confirmationDateTime,
    eventCreationDateTime,
    eventExpirationDateTime,
    eventProcessingDateTime,
    eventSentDateTime,
    eventSubmittedDateTime,
    executionDateTime,
    transactionCreationDateTime
}

Enum csa::ExceptionEnum
{
    Applicable,
    NotApplicable,
    Other
}

Enum legaldoc::ExecutionLocationEnum
{
    ExecutedOutsideBelgium,
    ExecutedInBelgium,
    OtherLocation
}

Enum event::ExecutionTypeEnum
{
    Electronic,
    OffFacility,
    OnVenue
}

Enum template::ExerciseNoticeGiverEnum
{
    Buyer,
    Seller,
    Both,
    AsSpecifiedInMasterAgreement
}

Enum template::ExpirationTimeTypeEnum
{
    Close,
    Open,
    OSP,
    SpecificTime,
    XETRA,
    DerivativesClose,
    AsSpecifiedInMasterConfirmation
}

Enum csa::ExposureScopeProductEnum
{
    FXTransactions,
    FXSettlementDate,
    CurrencyOptionTransactions
}

Enum product::FPVFinalPriceElectionFallbackEnum
{
    FPVClose,
    FPVHedgeExecution
}

Enum observable::FeeTypeEnum
{
    Assignment,
    BrokerageCommission,
    Increase,
    Novation,
    PartialTermination,
    Premium,
    Renegotiation,
    Termination,
    Upfront,
    CreditEvent,
    CorporateAction
}

Enum product::FinalPrincipalExchangeCalculationEnum
{
    Floored,
    NonFloored
}

Enum math::FinancialUnitEnum
{
    Contract,
    ContractualProduct,
    IndexUnit,
    LogNormalVolatility,
    Share,
    ValuePerDay,
    ValuePerPercent,
    Weight
}

Enum observable::FloatingRateIndexCalculationMethodEnum
{
    OISCompound,
    Average,
    Compounded,
    AllInCompounded
}

Enum observable::FloatingRateIndexCategoryEnum
{
    ScreenRate,
    Calculated,
    ReferenceBanks
}

// FloatingRateIndexEnum has 659 values, showing first 50
Enum other::FloatingRateIndexEnum
{
    AED_EBOR_Reuters,
    AED_EIBOR,
    AUD_AONIA,
    AUD_AONIA_OIS_Compound_1,
    AUD_AONIA_OIS_COMPOUND,
    AUD_AONIA_OIS_COMPOUND_SwapMarker,
    AUD_BBR_AUBBSW,
    AUD_BBR_BBSW,
    AUD_BBR_BBSW_Bloomberg,
    AUD_BBR_BBSY__BID_,
    AUD_BBR_ISDC,
    AUD_BBSW,
    AUD_BBSW_Quarterly_Swap_Rate_ICAP,
    AUD_BBSW_Semi_Annual_Swap_Rate_ICAP,
    AUD_BBSY_Bid,
    AUD_LIBOR_BBA,
    AUD_LIBOR_BBA_Bloomberg,
    AUD_LIBOR_Reference_Banks,
    AUD_Quarterly_Swap_Rate_ICAP,
    AUD_Quarterly_Swap_Rate_ICAP_Reference_Banks,
    AUD_Semi_Annual_Swap_Rate_11_00_BGCANTOR,
    AUD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks,
    AUD_Semi_annual_Swap_Rate_ICAP,
    AUD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks,
    AUD_Swap_Rate_Reuters,
    BRL_CDI,
    CAD_BA_CDOR,
    CAD_BA_CDOR_Bloomberg,
    CAD_BA_ISDD,
    CAD_BA_Reference_Banks,
    CAD_BA_Reuters,
    CAD_BA_Telerate,
    CAD_CDOR,
    CAD_CORRA,
    CAD_CORRA_CanDeal_TMX_Term,
    CAD_CORRA_Compounded_Index,
    CAD_CORRA_OIS_Compound_1,
    CAD_CORRA_OIS_COMPOUND,
    CAD_ISDA_Swap_Rate,
    CAD_LIBOR_BBA,
    CAD_LIBOR_BBA_Bloomberg,
    CAD_LIBOR_BBA_SwapMarker,
    CAD_LIBOR_Reference_Banks,
    CAD_REPO_CORRA,
    CAD_TBILL_ISDD,
    CAD_TBILL_Reference_Banks,
    CAD_TBILL_Reuters,
    CAD_TBILL_Telerate,
    CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP,
    CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg
}

Enum product::FloatingRateIndexProcessingTypeEnum
{
    Screen,
    CompoundIndex,
    OIS,
    OvernightAvg,
    Modular,
    RefBanks
}

Enum observable::FloatingRateIndexStyleEnum
{
    AverageFRO,
    CompoundedFRO,
    CompoundedIndex,
    Index,
    Other,
    Overnight,
    PublishedAverage,
    SpecifiedFormula,
    SwapRate,
    TermRate
}

Enum asset::FundProductTypeEnum
{
    MoneyMarketFund,
    ExchangeTradedFund,
    MutualFund,
    OtherFund
}

Enum legaldoc::FxForceMajeureOrActOfSStateEnum
{
    ToBeTreatedAsDisruptionEvent,
    ToBeTreatedAsForceMajeureOrActOfSState
}

Enum legaldoc::FxIllegalityOrImpossibilityEnum
{
    ToBeTreatedAsDisruptionEvent,
    ToBeTreatedAsIllegalityOrImpossibility
}

Enum legaldoc::FxSubstitutionProvisionTypeEnum
{
    LocalAssetSubstituteGross,
    LocalAssetSubstituteNet,
    LocalCurrencySubstitute
}

Enum legaldoc::GoverningLawEnum
{
    AsSpecifiedInMasterAgreement,
    BE,
    CAAB,
    CABC,
    CAMN,
    CAON,
    CAQC,
    DE,
    FR,
    GBEN,
    GBGY,
    GBIM,
    GBJY,
    GBSC,
    IE,
    JP,
    LU,
    RelatedMasterAgreement,
    USCA,
    USDE,
    USIL,
    USNY
}

Enum event::HaircutIndicatorEnum
{
    PreHaircut,
    PostHaircut
}

Enum csa::HoldingPostedCollateralEnum
{
    AcceptableCustodian
}

// ISOCountryCodeEnum has 249 values, showing first 50
Enum asset::ISOCountryCodeEnum
{
    AF,
    AL,
    DZ,
    AS,
    AD,
    AO,
    AI,
    AQ,
    AG,
    AR,
    AM,
    AW,
    AU,
    AT,
    AZ,
    BS,
    BH,
    BD,
    BB,
    BY,
    BE,
    BZ,
    BJ,
    BM,
    AX,
    BT,
    BO,
    BQ,
    BA,
    BW,
    BV,
    BR,
    IO,
    BN,
    BG,
    BF,
    BI,
    CV,
    KH,
    CM,
    CA,
    KY,
    CF,
    TD,
    CL,
    CN,
    CX,
    CC,
    CO,
    KM
}

// ISOCurrencyCodeEnum has 178 values, showing first 50
Enum asset::ISOCurrencyCodeEnum
{
    AED,
    AFN,
    ALL,
    AMD,
    AOA,
    ARS,
    AUD,
    AWG,
    AZN,
    BAM,
    BBD,
    BDT,
    BHD,
    BIF,
    BMD,
    BND,
    BOB,
    BOV,
    BRL,
    BSD,
    BTN,
    BWP,
    BYN,
    BZD,
    CAD,
    CDF,
    CHE,
    CHF,
    CHW,
    CLF,
    CLP,
    CNY,
    COP,
    COU,
    CRC,
    CUP,
    CVE,
    CZK,
    DJF,
    DKK,
    DOP,
    DZD,
    EGP,
    ERN,
    ETB,
    EUR,
    FJD,
    FKP,
    GBP,
    GEL
}

Enum csa::IndependentAmountCompareEnum
{
    Compare
}

Enum csa::IndependentAmountEligibilityEnum
{
    None,
    NoneUnlessSpecifiedInConfirmation
}

Enum product::IndexAnnexSourceEnum
{
    MasterConfirmation,
    Publisher
}

Enum observable::IndexEventConsequenceEnum
{
    CalculationAgentAdjustment,
    NegotiatedCloseOut,
    CancellationAndPayment,
    RelatedExchange
}

Enum observable::InflationCalculationMethodEnum
{
    Ratio,
    Return,
    Spread
}

Enum observable::InflationCalculationStyleEnum
{
    YearOnYear,
    ZeroCoupon
}

// InflationRateIndexEnum has 72 values, showing first 50
Enum other::InflationRateIndexEnum
{
    AUD_CPI,
    AUS_CPI,
    AUS_HICP,
    BLG_CPI_GI,
    BLG_CPI_HI,
    BLG_HICP,
    BRL_IGPM,
    BRL_IPCA,
    CAD_CPI,
    CLP_CPI,
    CNY_CPI,
    CZK_CPI,
    DEK_CPI,
    DEK_HICP,
    DEM_CPI,
    DEM_CPI_NRW,
    DEM_HICP,
    ESP_CPI,
    ESP_HICP,
    ESP_R_CPI,
    ESP_R_HICP,
    EUR_AI_CPI,
    EUR_AI_R_CPI,
    EUR_EXT_CPI,
    EUR_EXT_R_CPI,
    FIN_CPI,
    FIN_HICP,
    FRC_EXT_CPI,
    FRC_HICP,
    GRD_CPI,
    GRD_HICP,
    HKD_CPI,
    HUF_CPI,
    IDR_CPI,
    ILS_CPI,
    IRL_CPI,
    IRL_HICP,
    ISK_CPI,
    ISK_HICP,
    ITL_BC_EXT_CPI,
    ITL_BC_INT_CPI,
    ITL_HICP,
    ITL_WC_EXT_CPI,
    ITL_WC_INT_CPI,
    JPY_CPI_EXF,
    KRW_CPI,
    LUX_CPI,
    LUX_HICP,
    MXN_CPI,
    MXN_UDI
}

Enum observable::InformationProviderEnum
{
    AssocBanksSingapore,
    BancoCentralChile,
    BankOfCanada,
    BankOfEngland,
    BankOfJapan,
    Bloomberg,
    EuroCentralBank,
    FederalReserve,
    FHLBSF,
    ICESWAP,
    ISDA,
    Refinitiv,
    ReserveBankAustralia,
    ReserveBankNewZealand,
    Reuters,
    SAFEX,
    Telerate,
    TOKYOSWAP
}

Enum event::InstructionFunctionEnum
{
    Execution,
    ContractFormation,
    QuantityChange,
    Renegotiation,
    Compression
}

Enum asset::InstrumentTypeEnum
{
    Debt,
    Equity,
    Fund,
    Warrant,
    Certificate,
    LetterOfCredit,
    ListedDerivative
}

Enum csa::InterestAdjustmentPeriodicityEnum
{
    LastLocalBusinessDayOfMonth,
    EachDay
}

Enum product::InterestShortfallCapEnum
{
    Fixed,
    Variable
}

Enum observable::InterpolationMethodEnum
{
    Linear,
    LinearZeroYield,
    None
}

Enum csa::LegacyConsentEnum
{
    ConsentRequired,
    NoConsent,
    ConsentRequiredNoDelay,
    TimesAdjusted,
    NoticeConditions,
    CostsApportioned
}

Enum csa::LegacyResolutionAlternativeEnum
{
    NoAlternative,
    SplitDifference,
    AdditionalConditions
}

Enum csa::LegacyVMCustodianEnum
{
    NotApplicable,
    NamedEntity,
    AsAdvised1to2,
    AsAdvised2to1,
    Party1toParty2,
    Party2toParty1
}

Enum legaldoc::LegalAgreementPublisherEnum
{
    AFB,
    BNYM,
    ISDAClearstream,
    EMTA,
    TheFXCommittee,
    ISDAEuroclear,
    ISDA,
    ISLA,
    JPMorgan,
    ICMA
}

Enum legaldoc::LegalAgreementTypeEnum
{
    BrokerConfirmation,
    Confirmation,
    CreditSupportAgreement,
    MasterAgreement,
    MasterConfirmation,
    SecurityAgreement,
    Other
}

Enum legaldoc::LengthUnitEnum
{
    Pages,
    TimeUnit
}

Enum workflow::LimitLevelEnum
{
    Account,
    Customer,
    House
}

Enum product::LoadTypeEnum
{
    BaseLoad,
    PeakLoad,
    OffPeak,
    BlockHours,
    Shaped,
    GasDay,
    Other
}

Enum csa::MarginApproachEnum
{
    Distinct,
    Allocated,
    GreaterOf
}

Enum event::MarginCallActionEnum
{
    Delivery,
    Return
}

Enum event::MarginCallResponseTypeEnum
{
    AgreeinFull,
    PartiallyAgree,
    Dispute
}

Enum template::MarginTypeEnum
{
    Cash,
    Instrument
}

Enum observable::MarketDisruptionEnum
{
    ModifiedPostponement,
    Omission,
    Postponement
}

// MasterAgreementClauseIdentifierEnum has 56 values, showing first 50
Enum legaldoc::MasterAgreementClauseIdentifierEnum
{
    ISLA_GMSLA_001,
    ISLA_GMSLA_002,
    ISLA_GMSLA_003,
    ISLA_GMSLA_004,
    ISLA_GMSLA_005,
    ISLA_GMSLA_006,
    ISLA_GMSLA_007,
    ISLA_GMSLA_008,
    ISLA_GMSLA_009,
    ISLA_GMSLA_010,
    ISLA_GMSLA_011,
    ISLA_GMSLA_012,
    ISLA_GMSLA_013,
    ISLA_GMSLA_014,
    ISLA_GMSLA_015,
    ISLA_GMSLA_016,
    ISLA_GMSLA_017,
    ISLA_GMSLA_018,
    ISLA_GMSLA_019,
    ISLA_GMSLA_020,
    ISLA_GMSLA_021,
    ISLA_GMSLA_022,
    ISLA_GMSLA_023,
    ISLA_GMSLA_024,
    ISLA_GMSLA_025,
    ISLA_GMSLA_026,
    ISLA_GMSLA_027,
    ISLA_GMSLA_028,
    ISLA_GMSLA_029,
    ISLA_GMSLA_030,
    ISLA_GMSLA_031,
    ISLA_GMSLA_032,
    ISLA_GMSLA_033,
    ISLA_GMSLA_034,
    ISLA_GMSLA_035,
    ISLA_GMSLA_036,
    ISLA_GMSLA_037,
    ISLA_GMSLA_038,
    ISLA_GMSLA_039,
    ISLA_GMSLA_040,
    ISLA_GMSLA_041,
    ISLA_GMSLA_042,
    ISLA_GMSLA_043,
    ISLA_GMSLA_044,
    ISLA_GMSLA_045,
    ISLA_GMSLA_046,
    ISLA_GMSLA_047,
    ISLA_GMSLA_048,
    ISLA_GMSLA_049,
    ISLA_GMSLA_050
}

Enum legaldoc::MasterAgreementTypeEnum
{
    AFB,
    Bespoke,
    CMA,
    CMOF,
    EEIPower,
    EFETElectricity,
    EFETGas,
    EMA,
    FBF,
    GasEDI,
    German,
    GMRA,
    GMSLA,
    GTMA,
    ICOM,
    IETA_ERPA,
    IETA_ETMA,
    IETA_IETMA,
    IFEMA,
    IFEOMA,
    ISDAMaster,
    ISDAFIA_CDEA,
    ISDAIIFM_TMA,
    JSCC,
    LBMA,
    LEAP,
    MCPSA,
    NAESBGas,
    NBP,
    RussianDerivatives,
    RussianRepo,
    SCoTA,
    Swiss,
    TTF,
    ZBT
}

// MasterAgreementVariantIdentifierEnum has 172 values, showing first 50
Enum legaldoc::MasterAgreementVariantIdentifierEnum
{
    ISLA_GMSLA_001_01,
    ISLA_GMSLA_001_02,
    ISLA_GMSLA_002_01,
    ISLA_GMSLA_002_02,
    ISLA_GMSLA_002_03,
    ISLA_GMSLA_003_01,
    ISLA_GMSLA_003_02,
    ISLA_GMSLA_004_01,
    ISLA_GMSLA_004_02,
    ISLA_GMSLA_004_03,
    ISLA_GMSLA_005_01,
    ISLA_GMSLA_005_02,
    ISLA_GMSLA_006_01,
    ISLA_GMSLA_006_02,
    ISLA_GMSLA_006_03,
    ISLA_GMSLA_006_04,
    ISLA_GMSLA_006_05,
    ISLA_GMSLA_007_01,
    ISLA_GMSLA_007_02,
    ISLA_GMSLA_008_01,
    ISLA_GMSLA_008_02,
    ISLA_GMSLA_008_03,
    ISLA_GMSLA_008_04,
    ISLA_GMSLA_009_01,
    ISLA_GMSLA_009_02,
    ISLA_GMSLA_009_03,
    ISLA_GMSLA_009_04,
    ISLA_GMSLA_010_01,
    ISLA_GMSLA_010_02,
    ISLA_GMSLA_011_01,
    ISLA_GMSLA_011_02,
    ISLA_GMSLA_011_03,
    ISLA_GMSLA_012_01,
    ISLA_GMSLA_012_02,
    ISLA_GMSLA_012_03,
    ISLA_GMSLA_013_01,
    ISLA_GMSLA_013_02,
    ISLA_GMSLA_013_03,
    ISLA_GMSLA_013_04,
    ISLA_GMSLA_013_05,
    ISLA_GMSLA_013_06,
    ISLA_GMSLA_014_01,
    ISLA_GMSLA_014_02,
    ISLA_GMSLA_014_03,
    ISLA_GMSLA_014_04,
    ISLA_GMSLA_014_05,
    ISLA_GMSLA_015_01,
    ISLA_GMSLA_015_02,
    ISLA_GMSLA_016_01,
    ISLA_GMSLA_016_02
}

Enum legaldoc::MasterConfirmationAnnexTypeEnum
{
    ISDA2004IndexVarianceSwapAmericasInterdealer,
    ISDA2004ShareVarianceSwapAmericasInterdealer,
    ISDA2007DispersionVarianceSwapEuropean,
    ISDA2007EquityFinanceSwapEuropean,
    ISDA2007IndexVarianceSwapAmericasInterdealer,
    ISDA2007ShareVarianceSwapAmericasInterdealer,
    ISDA2007VarianceOptionEuropean,
    ISDA2008EquityFinanceSwapAsiaExcludingJapan,
    ISDA2008EquityFinanceSwapAsiaExcludingJapanRev1,
    ISDA2008EquityOptionAsiaExcludingJapan,
    ISDA2008EquityOptionAsiaExcludingJapanRev1,
    ISDA2008EquityOptionJapan,
    ISDA2009ClosedMarketsOptionsAsiaExcludingJapan,
    ISDA2009EquityEuropeanInterdealerSS,
    ISDA2009EquityEuropeanIS,
    ISDA2009IndexShareOptionAmericas,
    ISDA2009IndexSwapEuropeanInterdealer,
    ISDA2009IndexSwapPanAsiaInterdealer,
    ISDA2009ShareSwapPanAsia,
    ISDA2010FairValueShareSwapEuropeanInterdealer,
    ISDA2010IndexShareOptionEMEAInterdealer
}

// MasterConfirmationTypeEnum has 105 values, showing first 50
Enum legaldoc::MasterConfirmationTypeEnum
{
    _2003CreditIndex,
    _2004EquityEuropeanInterdealer,
    _2005VarianceSwapEuropeanInterdealer,
    _2006DividendSwapEuropean,
    _2006DividendSwapEuropeanInterdealer,
    _2014CreditAsia,
    _2014CreditAsiaFinancial,
    _2014CreditAustraliaNewZealand,
    _2014CreditAustraliaNewZealandFinancial,
    _2014CreditEuropean,
    _2014CreditEuropeanCoCoFinancial,
    _2014CreditEuropeanFinancial,
    _2014CreditJapan,
    _2014CreditJapanFinancial,
    _2014CreditNorthAmerican,
    _2014CreditNorthAmericanFinancial,
    _2014CreditSingapore,
    _2014CreditSingaporeFinancial,
    _2014CreditSovereignAsia,
    _2014CreditSovereignEmergingEuropeanAndMiddleEastern,
    _2014CreditSovereignJapan,
    _2014CreditSovereignLatinAmerican,
    _2014CreditSovereignWesternEuropean,
    _2014StandardCreditAsia,
    _2014StandardCreditAsiaFinancial,
    _2014StandardCreditAustraliaNewZealand,
    _2014StandardCreditAustraliaNewZealandFinancial,
    _2014StandardCreditEuropean,
    _2014StandardCreditEuropeanCoCoFinancial,
    _2014StandardCreditEuropeanFinancial,
    _2014StandardCreditJapan,
    _2014StandardCreditJapanFinancial,
    _2014StandardCreditNorthAmerican,
    _2014StandardCreditNorthAmericanFinancial,
    _2014StandardCreditSingapore,
    _2014StandardCreditSingaporeFinancial,
    _2014StandardCreditSovereignAsia,
    _2014StandardCreditSovereignEmergingEuropeanAndMiddleEastern,
    _2014StandardCreditSovereignJapan,
    _2014StandardCreditSovereignLatinAmerican,
    _2014StandardCreditSovereignWesternEuropean,
    DJ_CDX_EM,
    DJ_CDX_EM_DIV,
    DJ_CDX_NA,
    DJ_iTraxx_Europe,
    EquityAmericas,
    EquityAsia,
    EquityEuropean,
    ISDA1999Credit,
    ISDA2003CreditAsia
}

// MatrixTermEnum has 78 values, showing first 50
Enum legaldoc::MatrixTermEnum
{
    AsiaCorporate,
    AsiaFinancialCorporate,
    AsiaSovereign,
    AustraliaCorporate,
    AustraliaFinancialCorporate,
    AustraliaSovereign,
    EmergingEuropeanAndMiddleEasternSovereign,
    EmergingEuropeanCorporate,
    EmergingEuropeanCorporateLPN,
    EmergingEuropeanFinancialCorporate,
    EmergingEuropeanFinancialCorporateLPN,
    EuropeanCoCoFinancialCorporate,
    EuropeanCorporate,
    EuropeanFinancialCorporate,
    EuropeanSeniorNonPreferredFinancialCorporate,
    IVS1OpenMarkets,
    JapanCorporate,
    JapanFinancialCorporate,
    JapanSovereign,
    LatinAmericaCorporate,
    LatinAmericaCorporateBond,
    LatinAmericaCorporateBondOrLoan,
    LatinAmericaFinancialCorporateBond,
    LatinAmericaFinancialCorporateBondOrLoan,
    LatinAmericaSovereign,
    NewZealandCorporate,
    NewZealandFinancialCorporate,
    NewZealandSovereign,
    NorthAmericanCorporate,
    NorthAmericanFinancialCorporate,
    SingaporeCorporate,
    SingaporeFinancialCorporate,
    SingaporeSovereign,
    StandardAsiaCorporate,
    StandardAsiaFinancialCorporate,
    StandardAsiaSovereign,
    StandardAustraliaCorporate,
    StandardAustraliaFinancialCorporate,
    StandardAustraliaSovereign,
    StandardEmergingEuropeanAndMiddleEasternSovereign,
    StandardEmergingEuropeanCorporate,
    StandardEmergingEuropeanCorporateLPN,
    StandardEmergingEuropeanFinancialCorporate,
    StandardEmergingEuropeanFinancialCorporateLPN,
    StandardEuropeanCoCoFinancialCorporate,
    StandardEuropeanCorporate,
    StandardEuropeanFinancialCorporate,
    StandardEuropeanSeniorNonPreferredFinancialCorporate,
    StandardJapanCorporate,
    StandardJapanFinancialCorporate
}

Enum legaldoc::MatrixTypeEnum
{
    CreditDerivativesPhysicalSettlementMatrix,
    EquityDerivativesMatrix,
    SettlementMatrix
}

Enum asset::MaturityTypeEnum
{
    RemainingMaturity,
    OriginalMaturity,
    FromIssuance
}

Enum asset::MoneyMarketTypeEnum
{
    CommercialPaper,
    CertificateOfDeposit
}

Enum legaldoc::NationalizationOrInsolvencyOrDelistingEventEnum
{
    NegotiatedCloseout,
    CancellationAndPayment
}

Enum party::NaturalPersonRoleEnum
{
    Broker,
    Buyer,
    DecisionMaker,
    ExecutionWithinFirm,
    InvestmentDecisionMaker,
    Seller,
    Trader
}

Enum product::NegativeInterestRateTreatmentEnum
{
    NegativeInterestRateMethod,
    ZeroInterestRateMethod,
    ZeroInterestRateExcludingSpreadMethod
}

Enum product::NonCashDividendTreatmentEnum
{
    PotentialAdjustmentEvent,
    CashEquivalent
}

Enum csa::NotRatedByEnum
{
    All,
    One,
    Two
}

Enum product::NotionalAdjustmentEnum
{
    Execution,
    PortfolioRebalancing,
    Standard
}

Enum csa::NumberOfRatingAgenciesEnum
{
    All,
    AnyOne,
    AnyTwo,
    Other
}

Enum credit::ObligationCategoryEnum
{
    Payment,
    BorrowedMoney,
    ReferenceObligationsOnly,
    Bond,
    Loan,
    BondOrLoan
}

Enum observable::ObservationPeriodDatesEnum
{
    SetInAdvance,
    Standard,
    FixingDate
}

Enum template::OptionExerciseStyleEnum
{
    European,
    Bermuda,
    American
}

Enum template::OptionTypeEnum
{
    Payer,
    Receiver,
    Straddle
}

Enum observable::PartyDeterminationEnum
{
    ExercisingParty,
    NonExercisingParty,
    AsSpecifiedInMasterAgreement,
    AsSpecifiedInStandardTermsSupplement,
    Both
}

Enum party::PartyIdentifierTypeEnum
{
    BIC,
    LEI,
    MIC
}

// PartyRoleEnum has 56 values, showing first 50
Enum party::PartyRoleEnum
{
    Accountant,
    AgentLender,
    AllocationAgent,
    ArrangingBroker,
    BarrierDeterminationAgent,
    BeneficialOwner,
    Beneficiary,
    BookingParty,
    Borrower,
    Buyer,
    BuyerDecisionMaker,
    Chargor,
    ClearingClient,
    ClearingExceptionParty,
    ClearingFirm,
    ClearingOrganization,
    Client,
    ClientDecisionMaker,
    ConfirmationPlatform,
    ContractualParty,
    CounterPartyAffiliate,
    CounterPartyUltimateParent,
    Counterparty,
    CreditSupportProvider,
    Custodian,
    DataSubmitter,
    DeterminingParty,
    DisputingParty,
    DocumentRepository,
    ExecutingBroker,
    ExecutingEntity,
    ExecutionAgent,
    ExecutionFacility,
    Guarantor,
    HedgingParty,
    Lender,
    MarginAffiliate,
    OrderTransmitter,
    Pledgor,
    PrimeBroker,
    PriorTradeRepository,
    PTRRServiceProvider,
    PublicationVenue,
    ReportingParty,
    ReportingPartyAffiliate,
    ReportingPartyUltimateParent,
    Seller,
    SellerDecisionMaker,
    SecuredParty,
    SettlementAgent
}

Enum schedule::PayRelativeToEnum
{
    CalculationPeriodStartDate,
    CalculationPeriodEndDate,
    LastPricingDate,
    ResetDate,
    ValuationDate
}

Enum party::PayerReceiverEnum
{
    Payer,
    Receiver
}

Enum event::PerformanceTransferTypeEnum
{
    Commodity,
    Correlation,
    Dividend,
    Equity,
    Interest,
    Volatility,
    Variance
}

Enum datetime::PeriodEnum
{
    D,
    W,
    M,
    Y
}

Enum datetime::PeriodExtendedEnum
{
    H,
    D,
    W,
    M,
    Y,
    T,
    C
}

Enum datetime::PeriodTimeEnum
{
    Hour,
    Minute,
    Second
}

Enum party::PersonIdentifierTypeEnum
{
    ARNU,
    CCPT,
    CUST,
    DRLC,
    EMPL,
    NIDN,
    SOSE,
    TXID,
    NPID,
    PLID
}

Enum event::PositionEventIntentEnum
{
    PositionCreation,
    CorporateActionAdjustment,
    Decrease,
    Increase,
    Transfer,
    OptionExercise,
    Valuation
}

Enum position::PositionStatusEnum
{
    Executed,
    Formed,
    Settled,
    Cancelled,
    Closed
}

Enum observable::PremiumTypeEnum
{
    PrePaid,
    PostPaid,
    Variable,
    Fixed
}

Enum observable::PriceExpressionEnum
{
    AbsoluteTerms,
    PercentageOfNotional,
    ParValueFraction,
    PerOption
}

Enum observable::PriceOperandEnum
{
    AccruedInterest,
    Commission,
    ForwardPoint
}

Enum observable::PriceSubTypeEnum
{
    Premium,
    Fee,
    Discount,
    Rebate
}

Enum event::PriceTimingEnum
{
    ClosingPrice,
    OpeningPrice
}

Enum observable::PriceTypeEnum
{
    AssetPrice,
    CashPrice,
    Correlation,
    Dividend,
    ExchangeRate,
    InterestRate,
    provision,
    provision,
    Variance,
    Volatility
}

// ProductGradeEnum has 72 values, showing first 50
Enum other::ProductGradeEnum
{
    _0_1_Percent,
    _0_5_Percent,
    _1_0_Percent,
    _10_PPM,
    _10_PPM_95_R,
    _10_PPM_Premium_Unleaded,
    _10_PPM_Regular_Unleaded,
    _180_CST,
    _3_5_Percent,
    _380_CST,
    _50_PPM,
    _54,
    _55,
    _87_M,
    _87_Unleaded,
    _87_Unleaded_ULS_30,
    _92_Unleaded,
    _93_Unleaded,
    _95_Unleaded,
    _97_Unleaded,
    _98_Unleaded,
    Arabian_Light,
    Brass_Blend,
    Brent,
    CARBOB,
    CBOB,
    Cold_Lake,
    Dubai,
    Edmonton_High_Sulphur_Sour,
    EUROBOB,
    German_10PPM,
    Gulf_Coast_Sweet,
    Hardisty_Light,
    Iranian_Light_1,
    Iranian_Light,
    Jet,
    Kirkuk_Light,
    Kuwait,
    Light_Louisiana_Sweet,
    Low_Sulphur,
    Low_Sulphur_Jet,
    Mars,
    Mixed_Sour_Blend,
    Mixed_Sweet_Blend,
    Murban,
    Natural_Gasoline,
    No__2,
    No__6_0_3_Percent,
    No__6_0_3_Percent_HP,
    No__6_0_3_Percent_LP
}

Enum asset::ProductIdTypeEnum
{
    BBGID,
    BBGTICKER,
    CUSIP,
    FIGI,
    ISDACRP,
    ISIN,
    Name,
    REDID,
    RIC,
    Other,
    Sicovam,
    SEDOL,
    UPI,
    Valoren,
    Wertpapier
}

Enum asset::PropertyTypeEnum
{
    Commercial,
    Residential
}

Enum asset::PutCallEnum
{
    Put,
    Call
}

Enum math::QuantifierEnum
{
    All,
    Any
}

Enum math::QuantityChangeDirectionEnum
{
    Increase,
    Decrease,
    Replace
}

Enum observable::QuotationRateTypeEnum
{
    Bid,
    Ask,
    Mid,
    ExercisingPartyPays
}

Enum observable::QuotationSideEnum
{
    Afternoon,
    Ask,
    Bid,
    Closing,
    High,
    Index,
    MeanOfBidAndAsk,
    LocationalMarginal,
    Low,
    MarginalHourly,
    MarketClearing,
    MeanOfHighAndLow,
    Morning,
    Official,
    Opening,
    OSP,
    Settlement,
    Spot,
    Mid,
    NationalSingle,
    WeightedAverage,
    UnWeightedAverage
}

Enum observable::QuotationStyleEnum
{
    PointsUpFront,
    TradedSpread,
    Price
}

Enum observable::QuoteBasisEnum
{
    Currency1PerCurrency2,
    Currency2PerCurrency1
}

Enum product::RateTreatmentEnum
{
    BondEquivalentYield,
    MoneyMarketYield
}

Enum csa::RatedPartyEnum
{
    Party,
    CreditSupportProvider,
    NamedEntity,
    PartyOrCreditSupportProvider,
    NamedAffiliate,
    AllAffiliates
}

Enum collateral::RatingPriorityResolutionEnum
{
    Issuer,
    Asset,
    Lowest,
    Highest,
    Average
}

Enum csa::RatingTypeEnum
{
    LongTerm,
    ShortTerm
}

Enum product::RealisedVarianceMethodEnum
{
    Previous,
    Last,
    Both
}

Enum csa::RecalculationOfValueElectionEnum
{
    ConsulationProcedure,
    OtherRegulatoryCSAProcedure,
    NotApplicable,
    Specified
}

Enum event::RecordAmountTypeEnum
{
    AccountTotal,
    GrandTotal,
    ParentTotal
}

Enum asset::RedemptionPartyEnum
{
    Holder,
    Issuer
}

Enum asset::RedemptionTypeEnum
{
    Convertible,
    Exchangeable,
    ContingentConvertible,
    Sinkable,
    Extraordinary
}

Enum event::RegIMRoleEnum
{
    Pledgor,
    Secured
}

Enum event::RegMarginTypeEnum
{
    VM,
    RegIM,
    NonRegIM
}

Enum csa::RegulatoryRegimeEnum
{
    AustraliaMarginRules,
    CanadaMarginRules,
    CFTC_MarginRules,
    EMIR_MarginRules,
    HongKongMarginRules,
    JapanMarginRules,
    US_PrudentialMarginRules,
    SEC_MarginRules,
    SingaporeMarginRules,
    SwitzerlandMarginRules,
    BrazilMarginRules,
    UnitedKingdomMarginRules,
    SouthAfricaMarginRules,
    SouthKoreaMarginRules,
    HongKongSFCMarginRules
}

Enum template::RepoDurationEnum
{
    Overnight,
    Term
}

Enum schedule::ResetRelativeToEnum
{
    CalculationPeriodStartDate,
    CalculationPeriodEndDate
}

Enum legaldoc::ResourceTypeEnum
{
    Confirmation,
    SupplementalMaterialEconomicTerms,
    TermSheet
}

Enum observable::RestructuringEnum
{
    ModModR,
    ModR,
    R
}

Enum product::ReturnTypeEnum
{
    Price,
    Total
}

Enum datetime::RollConventionEnum
{
    EOM,
    FRN,
    IMM,
    IMMCAD,
    IMMAUD,
    IMMNZD,
    SFE,
    NONE,
    TBILL,
    _1,
    _2,
    _3,
    _4,
    _5,
    _6,
    _7,
    _8,
    _9,
    _10,
    _11,
    _12,
    _13,
    _14,
    _15,
    _16,
    _17,
    _18,
    _19,
    _20,
    _21,
    _22,
    _23,
    _24,
    _25,
    _26,
    _27,
    _28,
    _29,
    _30,
    MON,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
}

Enum product::RollSourceCalendarEnum
{
    ListedOption,
    Future
}

Enum math::RoundingDirectionEnum
{
    Up,
    Down,
    Nearest
}

Enum datetime::RoundingFrequencyEnum
{
    Daily,
    PeriodEnd
}

Enum math::RoundingModeEnum
{
    Down,
    Up
}

Enum settlement::ScheduledTransferEnum
{
    CorporateAction,
    Coupon,
    CreditEvent,
    DividendReturn,
    Exercise,
    FixedRateReturn,
    FloatingRateReturn,
    FractionalAmount,
    InterestReturn,
    NetInterest,
    Performance,
    Principal
}

Enum asset::SecuredTypeEnum
{
    AssetBacked,
    CollateralizedObligation,
    CoveredBonds
}

Enum csa::SecuritiesCTSTimeEnum
{
    Same,
    Next,
    FirstDay,
    SecondDay,
    ThirdDay,
    Other
}

Enum csa::SecurityInterestObligationsEnum
{
    NotApplicable,
    AllObligationsOfPartyA,
    AllObligationsOfPartyB,
    Other
}

Enum csa::SecurityInterestObligeeEnum
{
    PartyA,
    PartyAOrAffiliate,
    PartyB,
    PartyBOrAffiliate,
    Other
}

Enum csa::SensitivitiesEnum
{
    Alternative,
    Standard
}

Enum product::SettledEntityMatrixSourceEnum
{
    ConfirmationAnnex,
    NotApplicable,
    Publisher
}

Enum settlement::SettlementCentreEnum
{
    EuroclearBank,
    ClearstreamBankingLuxembourg
}

// SettlementRateOptionEnum has 96 values, showing first 50
Enum observable::SettlementRateOptionEnum
{
    ARS_BNAR_ARS01,
    ARS_EMTA_INDICATIVE_SURVEY_RATE_ARS04,
    ARS_EMTA_INDUSTRY_SURVEY_RATE_ARS03,
    ARS_MAE_ARS05,
    ARS_OFFICIAL_RATE_ARS02,
    BRL_BRBY_BRL01,
    BRL_EMTA_INDICATIVE_SURVEY_RATE_BRL13,
    BRL_EMTA_INDUSTRY_SURVEY_RATE_BRL12,
    BRL_OFFICIAL_RATE_BRL02,
    BRL_PCOT_COMMERCIAL_BRL03,
    BRL_PCOT_FLOATING_BRL04,
    BRL_PTAX_BRL09,
    BRL_PTAX_COMMERCIAL_BRL05,
    BRL_PTAX_COMMERCIAL_BRFR_BRL06,
    BRL_PTAX_FLOATING_BRL07,
    BRL_PTAX_FLOATING_BRFR_BRL08,
    CLP_BCCH_CLP01,
    CLP_CHILD_INFORMAL_CLP02,
    CLP_CHILD_INTERBANK_CLP03,
    CLP_CHILD_OBSERVADO_CLP04,
    CLP_CHILG_INFORMAL_CLP05,
    CLP_CHILG_INTERBANK_CLP06,
    CLP_CHILG_OBSERVADO_CLP07,
    CLP_DOLAR_OBS_CLP10,
    CLP_EMTA_INDICATIVE_SURVEY_RATE_CLP11,
    CLP_OFFICIAL_RATE_CLP08,
    CLP_TELERATE_38942_CLP09,
    CNY_SAEC_CNY01,
    CNY_SFEMC_INDICATIVE_SURVEY_RATE_CNY02,
    COP_CO_COL03_COP01,
    COP_EMTA_INDICATIVE_SURVEY_RATE_COP03,
    COP_TRM_COP02,
    CURRENCY_IMPLIED_RATE__ADR__CURA1,
    CURRENCY_IMPLIED_RATE__LOCAL_ASSET__CURA2,
    CURRENCY_MUTUAL_AGREEMENT_CURA3,
    CURRENCY_REFERENCE_DEALERS_CURA4,
    CURRENCY_WHOLESALE_MARKET_CURA5,
    ECS_DNRP_ECS01,
    IDR_ABS_IDR01,
    IDR_JISDOR_IDR04,
    IDR_SFEMC_INDICATIVE_SURVEY_RATE_IDR02,
    IDR_VWAP_IDR03,
    ILS_BOIJ_ILS01,
    ILS_FXIL_ILS02,
    INR_FBIL_INR01,
    INR_RBIB_INR01,
    INR_SFEMC_INDICATIVE_SURVEY_RATE_INR02,
    KRW_KEBEY_KRW01,
    KRW_KFTC18_KRW02,
    KRW_SFEMC_INDICATIVE_SURVEY_RATE_KRW04
}

Enum settlement::SettlementTypeEnum
{
    Cash,
    Physical,
    Election,
    CashOrPhysical
}

Enum observable::ShareExtraordinaryEventEnum
{
    AlternativeObligation,
    CancellationAndPayment,
    OptionsExchange,
    CalculationAgent,
    ModifiedCalculationAgent,
    PartialCancellationAndPayment,
    Component
}

Enum csa::SimmExceptionApplicableEnum
{
    FallBackToMandatoryMethod,
    MandatoryMethod,
    OtherMethod
}

Enum legaldoc::SpecifiedEntityClauseEnum
{
    DefaultUnderSpecifiedTransaction,
    CrossDefault,
    Bankruptcy,
    CreditEventUponMerger
}

Enum legaldoc::SpecifiedEntityTermsEnum
{
    None,
    AnyAffiliate,
    NamedSpecifiedEntity,
    MaterialSubsidiary,
    OtherSpecifiedEntity
}

Enum legaldoc::SpecifiedValueEnum
{
    OutstandingPrincipalBalance,
    StatedPrincipalBalance,
    FaceValue,
    MarketValue
}

Enum product::SpreadCalculationMethodEnum
{
    ParPar,
    Proceeds
}

Enum product::SpreadScheduleTypeEnum
{
    Long,
    Short
}

Enum settlement::StandardSettlementStyleEnum
{
    Standard,
    Net,
    StandardAndNet,
    PairAndNet
}

Enum margin::StandardizedScheduleAssetClassEnum
{
    InterestRates,
    Credit,
    ForeignExchange,
    Equity,
    Commodity
}

Enum margin::StandardizedScheduleProductClassEnum
{
    Swap,
    CrossCurrencySwap,
    Swaption,
    SwaptionStraddle,
    SwapWithCallableBermudanRightToEnterExitSwaps,
    IRExoticSwapWithAnExoticCouponAgainstAFloatingLeg,
    Option,
    ForwardRateAgreement,
    SingleNameCreditDefaultSwap,
    IndexCDS,
    IndexTranche,
    CreditNthToDefault,
    CreditTotalReturnSwapOnABond,
    DeliverableSwap,
    NonDeliverableCrossCurrencySwap,
    DeliverableForward,
    NonDeliverableForward,
    DeliverableOption,
    NonDeliverableOption,
    VarianceSwap,
    VolatilitySwap,
    CorrelationSwap,
    Forward,
    DividendSwap,
    DeliverableOptionF,
    ContractForDifference,
    SwapsAndPortfolioSwaps,
    FixedFloatSwap,
    BasisSwap
}

Enum schedule::StubPeriodTypeEnum
{
    ShortInitial,
    ShortFinal,
    LongInitial,
    LongFinal
}

Enum asset::SupraNationalIssuerTypeEnum
{
    InternationalOrganisation,
    MultilateralBank
}

Enum asset::TaxonomySourceEnum
{
    CFI,
    ISDA,
    ICAD,
    EMIR,
    EU_EMIR_EligibleCollateralAssetClass,
    UK_EMIR_EligibleCollateralAssetClass,
    CFTC,
    US_CFTC_PR_EligibleCollateralAssetClass,
    MAS,
    CSA,
    Other
}

Enum party::TelephoneTypeEnum
{
    Work,
    Mobile,
    Fax,
    Personal
}

Enum legaldoc::TerminationCurrencyConditionEnum
{
    PaymentsDue,
    FreelyAvailable,
    PaymentsDueAndFreelyAvailable,
    Specified
}

Enum observable::TimeTypeEnum
{
    Close,
    Open,
    OSP,
    SpecificTime,
    XETRA,
    DerivativesClose,
    AsSpecifiedInMasterConfirmation
}

Enum datetime::TimeUnitEnum
{
    Second,
    Minute,
    Hour,
    Day,
    Week,
    Month,
    Year
}

Enum identifier::TradeIdentifierTypeEnum
{
    UniqueTransactionIdentifier,
    UniqueSwapIdentifier
}

Enum settlement::TransferSettlementEnum
{
    DeliveryVersusDelivery,
    DeliveryVersusPayment,
    PaymentVersusPayment,
    NotCentralSettlement
}

Enum event::TransferStatusEnum
{
    Disputed,
    Instructed,
    Pending,
    Settled,
    Netted
}

Enum observable::TriggerTimeTypeEnum
{
    Closing,
    Anytime
}

Enum observable::TriggerTypeEnum
{
    EqualOrLess,
    EqualOrGreater,
    Equal,
    Less,
    Greater
}

Enum asset::UK_EMIR_EligibleCollateralEnum
{
    UK_EMIRTypeA,
    UK_EMIRTypeB,
    UK_EMIRTypeC,
    UK_EMIRTypeD,
    UK_EMIRTypeE,
    UK_EMIRTypeF,
    UK_EMIRTypeG,
    UK_EMIRTypeH,
    UK_EMIRTypeI,
    UK_EMIRTypeJ,
    UK_EMIRTypeK,
    UK_EMIRTypeL,
    UK_EMIRTypeM,
    UK_EMIRTypeN,
    UK_EMIRTypeO,
    UK_EMIRTypeP,
    UK_EMIRTypeQ,
    UK_EMIRTypeR
}

Enum asset::US_CFTC_PR_EligibleCollateralEnum
{
    US_CFTC_PRType1,
    US_CFTC_PRType2,
    US_CFTC_PRType3,
    US_CFTC_PRType4,
    US_CFTC_PRType5A,
    US_CFTC_PRType5B,
    US_CFTC_PRType6,
    US_CFTC_PRType7,
    US_CFTC_PRType8A,
    US_CFTC_PRType8B,
    US_CFTC_PRType8C,
    US_CFTC_PRType9,
    US_CTFC_PRType10
}

Enum legaldoc::UmbrellaPartyRoleEnum
{
    Agent,
    InvestmentManager,
    Principal,
    SubAccount,
    Sleeve
}

Enum settlement::UnscheduledTransferEnum
{
    Recall,
    Return
}

Enum csa::ValuationAgentDeterminationEnum
{
    SoleValuationAgent,
    SwitchUponDefault,
    SwitchUponFailureToPerform,
    FixedPartyForDisputes
}

Enum csa::ValuationDateDateEnum
{
    Each,
    Last,
    Secondlast,
    Thirdlast,
    Fourthlast,
    CalendarDay,
    AsSelected
}

Enum csa::ValuationDateDayEnum
{
    LocalBusinessDay,
    CalendarDay,
    NewYorkBankingDay
}

Enum csa::ValuationDateFrequencyEnum
{
    Daily,
    Weekly,
    Fortnightly,
    Monthly,
    AsAgreed,
    AsSelected
}

Enum observable::ValuationMethodEnum
{
    Market,
    Highest,
    AverageMarket,
    AverageHighest,
    BlendedMarket,
    BlendedHighest,
    AverageBlendedMarket,
    AverageBlendedHighest
}

Enum event::ValuationScopeEnum
{
    Collateral,
    Trade
}

Enum event::ValuationSourceEnum
{
    CentralCounterparty
}

Enum csa::ValuationTimeDayEnum
{
    PreviousLocalBusinessDay,
    PreviousLocalBusinessDayMarket,
    PreviousLocalBusinessDayCityOfAgent,
    ValuationDate,
    AsSelected
}

Enum csa::ValuationTimeEnum
{
    CloseOfBusiness,
    SpecificTime,
    AsSelected
}

Enum event::ValuationTypeEnum
{
    MarkToMarket,
    MarkToModel
}

Enum csa::ValueCashEnum
{
    CashAmount,
    CashPercentage,
    CashPercentageLessHaircut,
    Other
}

Enum csa::ValueSecuritiesEnum
{
    BidPricePercentage,
    BidPricePercentageLessHaircut,
    MidPricePercentage,
    MidPricePercentageLessHaircut,
    Other
}

Enum workflow::WarehouseIdentityEnum
{
    DTCC_TIW_Gold
}

Enum math::WeatherUnitEnum
{
    CDD,
    CPD,
    HDD
}

Enum schedule::WeeklyRollConventionEnum
{
    TBILL
}

Enum workflow::WorkflowStatusEnum
{
    Accepted,
    Alleged,
    Amended,
    Cancelled,
    Certain,
    Cleared,
    Pending,
    Rejected,
    Submitted,
    Terminated,
    Uncertain,
    Unconfirmed,
    Affirmed,
    Confirmed
}

Enum csa::ZeroEventEnum
{
    EventOfDefault,
    TerminationEvent,
    TerminationEventAllAffectedTransactions,
    PotentialEventOfDefault,
    AdditionalTerminationEvent,
    Other
}

// ─── Asset & Security Reference Data (28 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The base data type to specify common attributes for all Assets.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::AssetBase
{
    {nlq::NlqProfile.description = 'Defines whether the Asset is listed on a public exchange.'}
    isExchangeListed: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The unique identifier for an Asset, specified using an Asset Identifier Type enumerator.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::AssetIdentifier
{
    {nlq::NlqProfile.description = 'The identifier value.'}
    identifier: String[1];
    {nlq::NlqProfile.description = 'Defines the symbology source of the Asset Identifier, eg CUSIP, ISIN, etc.'}
    identifierType: asset::AssetIdTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the common attributes for all Instrument data types.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::InstrumentBase
{
    {nlq::NlqProfile.description = 'Identifies the type of an instrument using an enumerated list.'}
    instrumentType: asset::InstrumentTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Comprises an identifier and a source. The associated metadata key denotes the ability to associate a hash value to the ProductIdentifier instantiat...',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::ProductIdentifier
{
    {nlq::NlqProfile.description = 'Provides an identifier associated with a specific product.  The identifier is unique within the public source specifi...'}
    identifier: String[1];
    {nlq::NlqProfile.description = 'Defines the source of the identifier.'}
    source: asset::ProductIdTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a taxonomy value as either a simple string or a more granular expression with class names and values for each class.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::TaxonomyValue
{
    {nlq::NlqProfile.description = 'Specifies the taxonomy value as a simple string, which may be associated to an external scheme.'}
    name: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the taxonomy of an object by combining a taxonomy source (i.e. the rules to classify the object) and a value (i.e. the output of those rule...',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::Taxonomy
{
    {nlq::NlqProfile.description = 'The source of the taxonomy that defines the rules for classifying the object. The taxonomy source is taken from a enu...'}
    source: asset::TaxonomySourceEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the product taxonomy, which is composed of a taxonomy value and a taxonomy source.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::ProductTaxonomy
{
    {nlq::NlqProfile.description = 'Classifies the most important risk class of the trade.'}
    primaryAssetClass: asset::AssetClassEnum[0..1];
    {nlq::NlqProfile.description = 'Classifies additional risk classes of the trade, if any.'}
    secondaryAssetClass: asset::AssetClassEnum[*];
    {nlq::NlqProfile.description = 'Derived from the product payout features using a CDM product qualification function that determines the product type ...'}
    productQualifier: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identifies a specific commodity by referencing a product identifier or by a product definition.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::Commodity
{
    {nlq::NlqProfile.description = 'Describes the required quote type of the underlying price that will be observed. Example values include \'Bid, \'Ask\...'}
    priceQuoteType: observable::QuotationSideEnum[1];
    {nlq::NlqProfile.description = 'Provides additional information about the commodity underlier.'}
    description: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the commodity underlier in the event that no ISDA Commodity Reference Price exists.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::CommodityProductDefinition
{
    {nlq::NlqProfile.description = 'Specifies the publication where the commodity prices can be found.'}
    commodityInfoPublisher: asset::CommodityInformationPublisherEnum[0..1];
    {nlq::NlqProfile.description = 'Identifies the exchange from which the reference price should be sourced, using the scheme at the following url: http...'}
    exchangeId: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the type of commodity.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::CommodityReferenceFramework
{
    {nlq::NlqProfile.description = 'Identifies the commodity more specifically. Where possible, this should follow the naming convention used in the 2005...'}
    commodityName: String[1];
    {nlq::NlqProfile.description = 'Provides an enumerated value for a capacity unit, generally used in the context of defining quantities for commodities.'}
    capacityUnit: math::CapacityUnitEnum[0..1];
    {nlq::NlqProfile.description = 'Provides an enumerated values for a weather unit, generally used in the context of defining quantities for commodities.'}
    weatherUnit: math::WeatherUnitEnum[0..1];
    {nlq::NlqProfile.description = 'Defines the currency in which the commodity is priced.'}
    currency: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A securitized derivative on another asset.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::ListedDerivative
{
    {nlq::NlqProfile.description = 'Also called contract month or delivery month. However, it\'s not always a month. It is usually expressed using a code...'}
    deliveryTerm: String[0..1];
    {nlq::NlqProfile.description = 'The type of option, ie Put or Call. Left empty if it is a Future.'}
    optionType: asset::PutCallEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the strike of the option.', nlq::NlqProfile.unit = 'currency'}
    strike: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identifies a loan by referencing an asset identifier and through an optional set of attributes.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::Loan
{
    {nlq::NlqProfile.description = 'Specifies the seniority level of the lien.'}
    lien: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the type of loan facility (letter of credit, revolving, ...).'}
    facilityType: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the credit agreement date is the closing date (the date where the agreement has been signed) for the loans ...'}
    creditAgreementDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Denotes the loan tranche that is subject to the derivative transaction. It will typically be referenced as the Bloomb...'}
    tranche: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the collateral taxonomy, which is composed of a taxonomy value and a taxonomy source.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::CollateralTaxonomy
{
    {nlq::NlqProfile.description = 'Specifies the taxonomy source.'}
    taxonomySource: asset::TaxonomySourceEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the collateral taxonomy value, either as a specified enumeration or as a string.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::CollateralTaxonomyValue
{
    {nlq::NlqProfile.description = 'Identifies European Union Eligible Collateral Assets classification categories based on EMIR Uncleared Margin Rules. ...'}
    eu_EMIR_EligibleCollateral: asset::EU_EMIR_EligibleCollateralEnum[*];
    {nlq::NlqProfile.description = 'Identifies United Kingdom Eligible Collateral Assets classification categories based on UK Onshored EMIR Uncleared Ma...'}
    uk_EMIR_EligibleCollateral: asset::UK_EMIR_EligibleCollateralEnum[*];
    {nlq::NlqProfile.description = 'Identifies US Eligible Collateral Assets classification categories based on Uncleared Margin Rules published by the C...'}
    us_CFTC_PR_EligibleCollateral: asset::US_CFTC_PR_EligibleCollateralEnum[*];
    {nlq::NlqProfile.description = 'Identifies the taxonomy value when not specified as an enumeration.'}
    nonEnumeratedTaxonomyValue: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identifies a security by referencing an identifier and by specifying the sector.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::Security
{
    {nlq::NlqProfile.description = 'Identifies the type of fund.'}
    fundType: asset::FundProductTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'EquityType',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::EquityType
{
    {nlq::NlqProfile.description = 'equityType'}
    equityType: asset::EquityTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the type of debt security.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::DebtType
{
    {nlq::NlqProfile.description = 'Specifies the characteristics of a debt security.'}
    debtClass: asset::DebtClassEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies selected economics of a debt security.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::DebtEconomics
{
    {nlq::NlqProfile.description = 'Specifies the order of repayment in the event of a sale or bankruptcy of the issuer or a related party (eg guarantor).'}
    seniority: asset::DebtSeniorityEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the general rule for periodic interest rate payment.'}
    interest: asset::DebtInterestEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the general rule for repayment of principal.'}
    principal: asset::DebtPrincipalEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the redemption features and whether the redemption right is exercised at the discretion of the issuer or the holder.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::DebtRedemption
{
    {nlq::NlqProfile.description = 'Specifies the contractual redemption or conversion features associated with a debt security.'}
    redemptionType: asset::RedemptionTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the embedded option feature of a debt security.'}
    putCall: asset::PutCallEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies whether the debt security is redeemed at the election of the Issuer/Holder.'}
    party: asset::RedemptionPartyEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SecuredDebt',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::SecuredDebt
{
    {nlq::NlqProfile.description = 'Specifies the type of secured debt product.'}
    securedType: asset::SecuredTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the type of Asset Backed Security.'}
    assetBacked: asset::AssetBackedEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the type of Collateralized Obligation.'}
    collateralizedObligation: asset::CollateralizedObligationEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the type of Covered Bond.'}
    coveredBond: asset::CoveredBondEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the type of property when the security is linked to a property asset.'}
    propertyType: asset::PropertyTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the origin of entity guaranteeing the collateral.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::CollateralGuarantorType
{
    {nlq::NlqProfile.description = 'Specifies the origin of entity guaranteeing the collateral.'}
    guarantorType: asset::CollateralEntityTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to allow specification of the type of entity issuing the collateral.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::CollateralIssuerType
{
    {nlq::NlqProfile.description = 'Specifies the origin of entity issuing the collateral.'}
    issuerType: asset::CollateralEntityTypeEnum[1];
    {nlq::NlqProfile.description = 'Specifies debt issued by international organisations and multilateral banks.'}
    supraNationalType: asset::SupraNationalIssuerTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to allow specification of different types of Quasi Government collateral.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::QuasiGovernmentIssuerType
{
    {nlq::NlqProfile.description = 'True if sovereign entity (e.g. not separate legal personality from sovereign) or false if non-sovereign entity (e.g. ...'}
    sovereignEntity: Boolean[1];
    {nlq::NlqProfile.description = 'Applies to non-sovereign entity (e.g. separate legal personality from sovereign).  True if entity has recourse to sov...'}
    sovereignRecourse: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to allow specification of different type of Regional government collateral.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::RegionalGovernmentIssuerType
{
    {nlq::NlqProfile.description = 'Applies to regional governments, local authorities or municipals.  True if entity has recourse to sovereign (e.g. deb...'}
    sovereignRecourse: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to allow specification of different types of special purpose vehicle (SPV) collateral.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::SpecialPurposeVehicleIssuerType
{
    {nlq::NlqProfile.description = 'Indicates tranched or untranched credit risk.'}
    creditRisk: asset::CreditRiskEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'TaxonomyClassification',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::TaxonomyClassification
{
    {nlq::NlqProfile.description = 'The name defined by the classification system for a specific attribute in the taxonomy'}
    className: String[0..1];
    {nlq::NlqProfile.description = 'The value set by the taxonomy that is specific to the className attribute.'}
    value: String[1];
    {nlq::NlqProfile.description = 'A description of the class.'}
    description: String[0..1];
    {nlq::NlqProfile.description = 'In the case of multi-layered hierarchical classification systems such as commodity classification, the layer the valu...'}
    ordinal: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to allow specification of the asset product type.',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::AssetType
{
    {nlq::NlqProfile.description = 'Represents a filter based on the type of collateral asset.'}
    assetType: asset::AssetTypeEnum[1];
    {nlq::NlqProfile.description = 'Represents a filter based on the type of security.'}
    instrumentType: asset::InstrumentTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Represents a filter based on the type of fund.'}
    fundType: asset::FundProductTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the eligible asset type when not enumerated.'}
    otherAssetType: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a publication that provides the commodity price, including, where applicable, the details of where in the publication the price is publis...',
   nlq::NlqProfile.businessDomain = 'Asset & Security Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for asset identification, classification, taxonomy, and reference data'}
asset::PriceSource
{
    {nlq::NlqProfile.description = 'Defines a publication in which the price can be found. (e.g Gas Daily, Platts Bloomberg. Commodity publishers can be ...'}
    pricePublisher: String[1];
    {nlq::NlqProfile.description = 'Specifies the location of the price which may be a specific page, electornic screen name, or a code (e.g. a RIC code)...'}
    priceSourceLocation: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the heading or field name for the price  on a given page or screen, where applicable.'}
    priceSourceHeading: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the time at which the price should be observed.'}
    priceSourceTime: String[0..1];
}

// ─── Code Lists & Classifications (3 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type hold a list of codes for business data validation',
   nlq::NlqProfile.businessDomain = 'Code Lists & Classifications',
   nlq::NlqProfile.whenToUse = 'Use for standardized code lists and field value classifications'}
codelist::CodeList
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type to identify the version of a codelist',
   nlq::NlqProfile.businessDomain = 'Code Lists & Classifications',
   nlq::NlqProfile.whenToUse = 'Use for standardized code lists and field value classifications'}
codelist::CodeListIdentification
{
    {nlq::NlqProfile.description = 'A description  of the code list, e.g. A list of codes identifying business centers'}
    description: String[0..1];
    {nlq::NlqProfile.description = 'The most recent date the code list was published, e.g. 2021-10-05'}
    publicationDate: String[0..1];
    {nlq::NlqProfile.description = 'A short name (without whitespace) for the code list, e.g. businessCenterScheme'}
    shortName: String[1];
    {nlq::NlqProfile.description = 'The the most recent version of the codelist, eg. 9-1'}
    version: String[1];
    {nlq::NlqProfile.description = 'The name of the code list, e.g. business-center'}
    codeShortId: String[0..1];
    {nlq::NlqProfile.description = 'Canonical URI which uniquely identifies all versions (collectively) of the referenced code list. Must be an absolute ...'}
    canonicalUri: String[1];
    {nlq::NlqProfile.description = 'Canonical URI which uniquely identifies a specific version of the referenced code list. Must be an absolute URI. Must...'}
    canonicalVersionUri: String[0..1];
    {nlq::NlqProfile.description = 'Suggested retrieval location for this version, in genericode format. An application must signal an error to the user ...'}
    locationUri: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type to hold the value of the code in a codelist',
   nlq::NlqProfile.businessDomain = 'Code Lists & Classifications',
   nlq::NlqProfile.whenToUse = 'Use for standardized code lists and field value classifications'}
codelist::CodeValue
{
    {nlq::NlqProfile.description = 'The value of the code, e.g. USNY'}
    value: String[1];
    {nlq::NlqProfile.description = 'A description of the meaning of the code, e.g. New York City, USA'}
    description: String[0..1];
    {nlq::NlqProfile.description = 'Where the code was defined,e.g. ISDA, FpML, Bloomberg'}
    source: String[0..1];
    {nlq::NlqProfile.description = 'When the code became/becomes effective'}
    effectiveDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'When the code ceased to be valid for new uses'}
    deprecatedDate: StrictDate[0..1];
}

// ─── Collateral Management (38 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Query to check against an EligibleCollateralSpecification',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::EligibilityQuery
{
    {nlq::NlqProfile.description = 'Maturity in years'}
    maturity: Float[1];
    {nlq::NlqProfile.description = 'The asset country of origin.'}
    assetCountryOfOrigin: asset::ISOCountryCodeEnum[1];
    {nlq::NlqProfile.description = 'The underlying asset denominated currency.'}
    denominatedCurrency: asset::CurrencyCodeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Result for the CheckEligibilityByDetails and CheckEligibilityForProduct functions',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CheckEligibilityResult
{
    {nlq::NlqProfile.description = 'a simple boolean which is set to true if the asset described in the EligibilityQuery input is eligible'}
    isEligible: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type for defining the obligations of the counterparty subject to credit support requirements.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::Collateral
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Contains collateral attributes which can also inherit information from a GMRA',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralProvisions
{
    {nlq::NlqProfile.description = 'Enumerates the collateral types which are accepted by the Seller.'}
    collateralType: collateral::CollateralTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines collateral substitution provisions such as how many and with how much notice are substitutions allowed.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::SubstitutionProvisions
{
    {nlq::NlqProfile.description = 'Specifies if 1 or more substitutions are allowed.'}
    numberOfSubstitutionsAllowed: Integer[0..1];
    {nlq::NlqProfile.description = 'A specific date and time for the notice deadline'}
    noticeDeadlineDateTime: DateTime[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class specifying the Independent Amount as the combination of a payer/receiver, a payment amount, a payment date and an associated payment calcul...',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::IndependentAmount
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to specify a credit notation.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::AgencyRatingCriteria
{
    {nlq::NlqProfile.description = 'Indicator for options to be used if several agency ratings (>1) are specified and its necessary to identify specific ...'}
    mismatchResolution: observable::CreditNotationMismatchResolutionEnum[0..1];
    {nlq::NlqProfile.description = 'identifies the dominant reference agency if there is a missmatch and several reference agencies exsist.'}
    referenceAgency: observable::CreditRatingAgencyEnum[0..1];
    {nlq::NlqProfile.description = 'Indicates the boundary of a credit agency rating i.e minimum or maximum.'}
    boundary: observable::CreditNotationBoundaryEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Specification of the valuation treatment for the specified collateral.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralValuationTreatment
{
    {nlq::NlqProfile.description = 'Specifies a haircut percentage to be applied to the value of asset and used as a discount factor to the value of the ...', nlq::NlqProfile.unit = 'percent'}
    haircutPercentage: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies a percentage value of transaction needing to be posted as collateral expressed as a valuation. As an exampl...', nlq::NlqProfile.unit = 'percent'}
    marginPercentage: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies an FX haircut applied to a specific asset which is agreed between the parties (for example, if pledgor elig...', nlq::NlqProfile.unit = 'percent'}
    fxHaircutPercentage: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies a percentage value of any additional haircut to be applied to a collateral asset,the percentage value is ex...', nlq::NlqProfile.unit = 'percent'}
    additionalHaircutPercentage: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a set of criteria used to specify eligible collateral.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::EligibleCollateralSpecification
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a set of criteria used to specify and describe collateral.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralCriteriaBase
{
    {nlq::NlqProfile.description = 'The specific criteria that applies. It can be created using AND, OR and NOT logic, and both asset and issuer characte...'}
    collateralCriteria: String[0..1];
    {nlq::NlqProfile.description = 'Specifies which of the two counterparties the criteria applies to (either one or both counterparties). This attribute...'}
    appliesTo: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Restrict the criteria to only apply to a specific type of margin, ie IM or VM.'}
    restrictTo: collateral::CollateralMarginTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Denotes which Criteria has priority if more than one agency rating applies.'}
    ratingPriorityResolution: collateral::RatingPriorityResolutionEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a set of criteria used to specify eligible collateral.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::EligibleCollateralCriteria
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the treatment terms for the eligible collateral criteria specified.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralTreatment
{
    {nlq::NlqProfile.description = 'A boolean attribute to specify whether collateral critieria are inclusion (True) or exclusion (False) criteria.'}
    isIncluded: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to describe concentration limits that may be applicable to eligible collateral criteria.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::ConcentrationLimit
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Respresents a class to describe a set of criteria to describe specific assets that the concentration limits apply to.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::ConcentrationLimitCriteria
{
    {nlq::NlqProfile.description = 'Specifies the type of concentration limit to be applied.'}
    concentrationLimitType: collateral::ConcentrationLimitTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the average trading volume of an Equity product upon an exchange or set of exchanges.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::AverageTradingVolume
{
    {nlq::NlqProfile.description = 'Indicates the type of equity average trading volume being stated (single) the highest amount on one exchange, or (con...'}
    methodology: collateral::AverageTradingVolumeMethodologyEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'IssuerCountryOfOrigin',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::IssuerCountryOfOrigin
{
    {nlq::NlqProfile.description = 'Represents a filter on the issuing entity country of origin based on the ISO Standard 3166, which is the same as filt...'}
    issuerCountryOfOrigin: asset::ISOCountryCodeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'AssetCountryOfOrigin',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::AssetCountryOfOrigin
{
    {nlq::NlqProfile.description = 'Represents a filter on the asset country of origin based on the ISO Standard 3166.'}
    assetCountryOfOrigin: asset::ISOCountryCodeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'IssuerName',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::IssuerName
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'IssuerAgencyRating',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::IssuerAgencyRating
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SovereignAgencyRating',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::SovereignAgencyRating
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'AssetAgencyRating',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::AssetAgencyRating
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'AssetMaturity',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::AssetMaturity
{
    {nlq::NlqProfile.description = 'Specifies whether the maturity range is the remaining or original maturity.'}
    maturityType: asset::MaturityTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a filter based on a stock exchange.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::ListingExchange
{
    {nlq::NlqProfile.description = 'Represents a filter based on the Primary Stock Exchange facilitating the listing of companies, exchange of Stocks, Ex...'}
    exchange: String[1..*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a filter based on an industry sector.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::ListingSector
{
    {nlq::NlqProfile.description = 'Represents a filter based on an industry sector defined under a system for classifying industry types such as Global ...'}
    sector: String[1..*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'DomesticCurrencyIssued',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::DomesticCurrencyIssued
{
    {nlq::NlqProfile.description = 'Identifies that the Security must be denominated in the domestic currency of the issuer.'}
    domesticCurrencyIssued: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'CounterpartyOwnIssuePermitted',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CounterpartyOwnIssuePermitted
{
    {nlq::NlqProfile.description = 'Represents a filter based on whether it is permitted for the underlying asset to be issued by the posting entity or p...'}
    counterpartyOwnIssuePermitted: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used to combine two or more Collateral Criteria using AND logic.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::AllCriteria
{
    {nlq::NlqProfile.description = 'allCriteria'}
    allCriteria: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used to combine two or more Collateral Criteria using OR logic.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::AnyCriteria
{
    {nlq::NlqProfile.description = 'anyCriteria'}
    anyCriteria: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used to apply a NOT logic condition to a single Collateral Criteria.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::NegativeCriteria
{
    {nlq::NlqProfile.description = 'negativeCriteria'}
    negativeCriteria: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Distributions and Interest Payment provisions applicable to the collateral agreement.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::DistributionAndInterestPayment
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the floating interest calculation and distribution parameters for a single currency.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralInterestParameters
{
    {nlq::NlqProfile.description = 'Represents the party to which these parameters apply (the applicable party).  In other words, if the parameters are d...'}
    postingParty: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the type of margin for which interest is being calculated, if the parameters are different depending on typ...'}
    marginType: collateral::CollateralMarginTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the currency for which the parameters are captured.'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents parameters for calculating the amount the floating interest calculation, e.g.  for a single currency or defaults for all currencies.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralInterestCalculationParameters
{
    {nlq::NlqProfile.description = 'Specifies the applicable fixed rate  if used.', nlq::NlqProfile.unit = 'percent'}
    fixedRate: Float[0..1];
    {nlq::NlqProfile.description = 'If True, specifies that the interest transfers should be converted to base currency equivalent, or if False specifies...'}
    inBaseCurrency: Boolean[1];
    {nlq::NlqProfile.description = 'Specifies the type of compounding to be applied (None, Business, Calendar).'}
    compoundingType: datetime::CompoundingTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the applicable business centers for compounding.'}
    compoundingBusinessCenter: String[*];
    {nlq::NlqProfile.description = 'Specifies the day count fraction to use for that currency.'}
    dayCountFraction: other::DayCountFractionEnum[1];
    {nlq::NlqProfile.description = 'Specifies when/how often is rounding applied?'}
    roundingFrequency: datetime::RoundingFrequencyEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the withholding tax rate if a withholding tax is applicable.', nlq::NlqProfile.unit = 'percent'}
    withholdingTaxRate: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the parameters needed to calculate the floating rate paid on collateral holdings.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralAgreementFloatingRate
{
    {nlq::NlqProfile.description = 'Specifies how negative rates should be applied.  If rates go negative, should the payment be reversed (true) or zeroe...'}
    negativeInterest: Boolean[1];
    {nlq::NlqProfile.description = 'Specifies how spreads should be applied in a low/negative rate environment.  If true, spread is applied only if rate ...'}
    compressibleSpread: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents parameters that describe how calculated interest amounts are handled, i.e. are they transferred/distributed, or is the collateral balanc...',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralInterestHandlingParameters
{
    {nlq::NlqProfile.description = 'Specifies how the collateral interest is to be handled.'}
    interestPaymentHandling: collateral::CollateralInterestHandlingEnum[1];
    {nlq::NlqProfile.description = 'Specifies applicable business centers for payments.'}
    paymentBusinessCenter: String[*];
    {nlq::NlqProfile.description = 'Indicates whether to net Held and Posted Interest Payments (i.e. whether interest payable for a period can be netted ...'}
    netPostedAndHeldInterest: Boolean[1];
    {nlq::NlqProfile.description = 'Indicates whether the interest amount may be offset against any margin call deliver or return amounts?   (aka \'net p...'}
    netInterestWithMarginCalls: Boolean[1];
    {nlq::NlqProfile.description = 'Indicates whether or not to include the open interest accrual in the margin calculation.'}
    includeAccrualInMarginCalc: Boolean[1];
    {nlq::NlqProfile.description = 'Indicates whether interest accruing on unsettled interest amount is included (continues to be accrued) in the followi...'}
    accrueInterestOnUnsettledInterest: Boolean[0..1];
    {nlq::NlqProfile.description = 'Indicates the option that accrued interest should be calculated and distributed when a full return of collateral occurs.'}
    onFullReturn: Boolean[1];
    {nlq::NlqProfile.description = 'Indicates the option that accrued interest should be calculated and distributed when a partial return collateral occurs.'}
    onPartialReturn: Boolean[1];
    {nlq::NlqProfile.description = 'Specifies the alternative to interest amounts.'}
    alternativeToInterestAmount: collateral::AlternativeToInterestAmountEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies an alternative to interest amount, when the alternative provision clause is specified.'}
    alternativeProvision: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the time of day that interest needs to be confirmed by.'}
    cutoffTime: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the parameters describing when notifications should be made for required collateral interest transfers.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::CollateralInterestNotification
{
    {nlq::NlqProfile.description = 'Specifies what triggers notification (should be enum) Interest Statement Frequency, Period End Date.'}
    trigger: String[1];
    {nlq::NlqProfile.description = 'Specifies the number of days before (negative) or after (positive) the trigger event.'}
    offset: Float[1];
    {nlq::NlqProfile.description = 'Specifies the time of day that the notification should occur.'}
    notificationTime: String[1];
    {nlq::NlqProfile.description = 'The type of days on which notification should occur.'}
    notificationDayType: datetime::DayTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the application of Interest Amount with respect to the Delivery Amount and the Return Amount.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::InterestAmountApplication
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the application of Interest Amount with respect the Return Amount.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::ReturnAmount
{
    {nlq::NlqProfile.description = 'Default language is included when True, and excluded when False.'}
    includesDefaultLanguage: Boolean[0..1];
    {nlq::NlqProfile.description = 'Custom election that might be specified by the parties to the agreement.'}
    customElection: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the application of Interest Amount with respect the Delivery Amount.',
   nlq::NlqProfile.businessDomain = 'Collateral Management',
   nlq::NlqProfile.whenToUse = 'Use for collateral portfolios, eligibility criteria, and collateral treatment'}
collateral::DeliveryAmount
{
    {nlq::NlqProfile.description = 'The standard election as specified by an enumeration.'}
    standardElection: collateral::DeliveryAmountElectionEnum[0..1];
    {nlq::NlqProfile.description = 'The custom election that might be specified by the parties to the agreement.'}
    customElection: String[0..1];
}

// ─── Credit Reference Data (3 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the ISDA 2003 Term: Not Domestic Currency.',
   nlq::NlqProfile.businessDomain = 'Credit Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for credit obligations, credit entities, and credit-specific reference data'}
credit::NotDomesticCurrency
{
    {nlq::NlqProfile.description = 'Indicates whether the Not Domestic Currency provision is applicable.'}
    applicable: Boolean[1];
    {nlq::NlqProfile.description = 'An explicit specification of the domestic currency. The list of valid currencies is not presently positioned as an en...'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the underlying obligations of the reference entity on which protection is purchased or sold through the Credit Default Swap.',
   nlq::NlqProfile.businessDomain = 'Credit Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for credit obligations, credit entities, and credit-specific reference data'}
credit::Obligations
{
    {nlq::NlqProfile.description = 'Used in both obligations and deliverable obligations to represent a class or type of securities which apply. ISDA 200...'}
    category: credit::ObligationCategoryEnum[1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. An obligation that ranks at least equal with the most senior...'}
    notSubordinated: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Any obligation that is not primarily (majority) owed to a So...'}
    notSovereignLender: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. If the reference entity is a Sovereign, this means any oblig...'}
    notDomesticLaw: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Indicates whether or not the obligation is quoted, listed or...'}
    listed: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Any obligation other than an obligation that was intended to...'}
    notDomesticIssuance: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S....'}
    fullFaithAndCreditObLiability: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S....'}
    generalFundObligationLiability: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S....'}
    revenueObligationLiability: Boolean[0..1];
    {nlq::NlqProfile.description = 'OTE: Only allowed as an obligation characteristic under ISDA Credit 1999. In essence Not Contingent means the repayme...'}
    notContingent: Boolean[0..1];
    {nlq::NlqProfile.description = 'A free format string to specify any excluded obligations or deliverable obligations, as the case may be, of the refer...'}
    excluded: String[0..1];
    {nlq::NlqProfile.description = 'This element is used to specify any other obligations of a reference entity in both obligations and deliverable oblig...'}
    othReferenceEntityObligations: String[0..1];
    {nlq::NlqProfile.description = 'Applies to Loan CDS, to indicate what lien level is appropriate for a deliverable obligation. Applies to European Loa...'}
    designatedPriority: String[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published Standard Terms Supplement for ...'}
    cashSettlementOnly: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published Standard Terms Supplement for ...'}
    deliveryOfCommitments: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published Standard Terms Supplement for ...'}
    continuity: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SpecifiedCurrency',
   nlq::NlqProfile.businessDomain = 'Credit Reference Data',
   nlq::NlqProfile.whenToUse = 'Use for credit obligations, credit entities, and credit-specific reference data'}
credit::SpecifiedCurrency
{
    {nlq::NlqProfile.description = 'Indicates whether the specified currency provision is applicable.'}
    applicable: Boolean[1];
    {nlq::NlqProfile.description = 'The currency in which the specified currency is denominated. The list of valid currencies is not presently positioned...'}
    currency: String[0..1];
}

// ─── Credit Support Annex (CSA) (162 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The set of elections which specify an Initial Margin Credit Support Annex or Deed.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportAgreementInitialMarginElections
{
    {nlq::NlqProfile.description = 'The qualification of whether cross-currency swaps need to be identified in the Confirmation so that the obligations t...'}
    identifiedCrossCurrencySwap: Boolean[0..1];
    {nlq::NlqProfile.description = 'The bespoke provision that might be specified by the parties to the agreement applicable to Interpretations.'}
    interpretationTerms: String[0..1];
    {nlq::NlqProfile.description = 'Any additional amendments that might be specified by the parties to the agreement.'}
    additionalAmendments: String[0..1];
    {nlq::NlqProfile.description = 'Any additional terms that might be specified applicable.'}
    additionalBespokeTerms: String[0..1];
    {nlq::NlqProfile.description = 'The qualification of whether Trust Scheme Addendum is applicable (True) or not applicable (False).'}
    trustSchemeAddendum: Boolean[1];
    {nlq::NlqProfile.description = 'Details of language relating to Client Asset and Money Rules (CASS).'}
    clientAssetSourcebookAdditionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The set of elections which specify a Variation Margin Credit Support Annex or Deed.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportAgreementVariationMarginElections
{
    {nlq::NlqProfile.description = 'The bespoke exchange date terms that might be specified by the parties to the agreement.'}
    exchangeDate: String[0..1];
    {nlq::NlqProfile.description = 'The specification of whether the standard Credit Support Offset provisions are applicable (true) or not applicable (f...'}
    creditSupportOffsets: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The set of elections which specify a Legacy (1994 or 1995) Credit Support Annex or Deed.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportAgreementLegacyElections
{
    {nlq::NlqProfile.description = 'The bespoke exchange date terms that might be specified by the parties to the agreement.'}
    exchangeDate: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container designed to hold a set of related data. In this case, designed to hold a set of clauses that are common amongst Legacy (1994/95...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportAgreementElectionsBase
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The set of elections which specify a Collateral Transfer Agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralTransferAgreementElections
{
    {nlq::NlqProfile.description = 'The qualification of whether cross-currency swaps need to be identified in the Confirmation so that the obligations t...'}
    identifiedCrossCurrencySwap: Boolean[0..1];
    {nlq::NlqProfile.description = 'The bespoke provision that might be specified by the parties to the agreement applicable to Interpretations.'}
    interpretationTerms: String[0..1];
    {nlq::NlqProfile.description = 'Any additional amendments that might be specified by the parties to the agreement.'}
    additionalAmendments: String[0..1];
    {nlq::NlqProfile.description = 'Any additional terms that might be specified applicable.'}
    additionalBespokeTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The set of elections which specify a Security Agremeent.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SecurityAgreementElections
{
    {nlq::NlqProfile.description = 'Delivery In Lieu rights.'}
    deliveryInLieuRight: Boolean[0..1];
    {nlq::NlqProfile.description = 'Full Discharge condition.'}
    fullDischarge: Boolean[0..1];
    {nlq::NlqProfile.description = 'Any additional amendments that might be specified by the parties to the agreement.'}
    additionalAmendments: String[0..1];
    {nlq::NlqProfile.description = 'Any additional terms that might be specified applicable.'}
    additionalBespokeTerms: String[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Posted Credit Support item with corresponding Valuation Percentage, FX Haircut Percentage and any related disputed Posted Credit Support valuation.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::PostedCreditSupportItem
{
    {nlq::NlqProfile.description = 'Valuation Percentage means, for any item of Eligible Collateral (IM), the percentage specified in accordance with Par...', nlq::NlqProfile.unit = 'percent'}
    haircutPercentage: Float[1];
    {nlq::NlqProfile.description = 'FX Haircut Percentage means, for any item of Eligible Collateral (IM), the percentage specified in accordance with Pa...', nlq::NlqProfile.unit = 'percent'}
    fxHaircutPercentage: Float[0..1];
    {nlq::NlqProfile.description = 'Percentage value of any additional haircut to be applied to a collateral asset,the percentage value is expressed as t...', nlq::NlqProfile.unit = 'percent'}
    additionalHaircutPercentage: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Additional Representation.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AdditionalRepresentation
{
    {nlq::NlqProfile.description = 'A supplemental custom election that might be specified by the parties for the purpose of specifying the Additional Re...'}
    customElection: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the parties\' Additional Representation(s) election.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AdditionalRepresentationElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The Additional Representation is applicable when True, and not applicable when False.'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'Details of any Additional Representations given by the relevant parties in relation to the collateral arrangement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify Additional Representations that may be applicable to an agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AdditionalRepresentations
{
    {nlq::NlqProfile.description = 'The qualification of whether Additional Information related to Regulatory Compliance and Concentration Limits is appl...'}
    regulatoryComplianceRepresentation: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Pledgor/Obligor/Chargor Additional Rights Event election.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AdditionalRightsEvent
{
    {nlq::NlqProfile.description = 'The Pledgor Additional Rights Event election is applicable when True, and not applicable when False.'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'The qualification of the Pledgor Additional Rights Event election, when specified.'}
    qualification: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify an optional termination event, additional to the Termination Events that will be deemed an Access Condition (Initial Margin CSA)...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AdditionalTerminationEvent
{
    {nlq::NlqProfile.description = 'The name of the additional termination event.'}
    name: String[1];
    {nlq::NlqProfile.description = 'Whether the additional termination event is applicable for the relevant party.'}
    applicableParty: party::CounterpartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The specification of the Additional Type of transaction that can require the collection or delivery of initial margin under a given regulatory regi...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AdditionalType
{
    {nlq::NlqProfile.description = 'The qualification of the Additional Type of transaction that can require the collection or delivery of initial margin...'}
    standardValue: csa::AdditionalTypeEnum[1];
    {nlq::NlqProfile.description = 'The qualification of the Additional Type of transaction that can require the collection or delivery of initial margin...'}
    customValue: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the effective date of the Amendment to Termination Currency. This date can be specified as either an actual date, a specific dat...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AmendmentEffectiveDate
{
    {nlq::NlqProfile.description = 'The effective date of the Amendment to Termination Currency when specified as an actual date.'}
    date: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The effective date of the Amendment to Termination Currency when specified as relative to another date (e.g. the anne...'}
    specificDate: csa::AmendmentEffectiveDateEnum[0..1];
    {nlq::NlqProfile.description = 'The effective date of the Amendment to Termination Currency when specified as a non normalized custom provision.'}
    customProvision: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the applicable regulatory regime(s) that parties to a legal agreement, such as the ISDA 2016 and 2018 CSA for Initial Margin, mi...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ApplicableRegime
{
    {nlq::NlqProfile.description = 'The applicable regulatory regime, as specified through an enumeration.'}
    regime: csa::RegulatoryRegimeEnum[0..1];
    {nlq::NlqProfile.description = 'The additional regulatory regime as specified by the parties.'}
    additionalRegime: String[0..1];
    {nlq::NlqProfile.description = 'additionalType'}
    additionalType: csa::AdditionalTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The bespoke Additional Type for the purposes of Covered Transactions (IM).'}
    additionalTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Valuation of Appropriated Collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AppropriatedCollateralValuation
{
    {nlq::NlqProfile.description = 'The qualification of whether the Valuation of Appropriate Collateral provision is applicable (True) or not applicable...'}
    isSpecified: Boolean[1];
    {nlq::NlqProfile.description = 'The parties\' election that qualify the Valuation of Appropriate Collateral in the case where it is deemed applicable.'}
    election: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify bespoke Calculation Date terms for the purposes of Initial Margin.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::BespokeCalculationDate
{
    {nlq::NlqProfile.description = 'Additional Calculation Date terms are applicable when True and not applicable when False.'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'The Additional Calculation Date terms for the purposes of Initial Margin.'}
    calculationDateImTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify additional Calculation Time terms for the purposes of Initial Margin.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::BespokeCalculationTime
{
    {nlq::NlqProfile.description = 'If set to True, the Calculation Time for Initial Margin is the time as of which the Calculation Agent (IM) computes i...'}
    asCalculationAgent: Boolean[1];
    {nlq::NlqProfile.description = 'Additional Terms applicable to Calculation Time for Initial Margin.'}
    bespokeCalculationTimeTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify any bespoke Transfer Timing language by each party to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::BespokeTransferTiming
{
    {nlq::NlqProfile.description = 'A boolean flag to specify whether bespoke transfer terms are applicable or not.'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'The bespoke transfer timing terms applicable to the agreement.'}
    bespokeTransferTimingTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Details of the party calculating the value of collateral to be delivered or returned.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CalculationAgentTerms
{
    {nlq::NlqProfile.description = 'The party which is specified as Calculation Agent for Initial Margin.'}
    party: csa::CalculationValuationAgentPartyEnum[0..1];
    {nlq::NlqProfile.description = 'The Calculation Agent (IM) terms when specified.'}
    bespokeCalculationAgentTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Calculation, Valuation and Timing terms specific to the Legacy (1994/95) Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CalculationAndTimingLegacy
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Calculation, Valuation and Timing terms specific to the Variation Margin Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CalculationAndTimingVariationMargin
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Calculation, Valuation and Timing terms specific to the Initial Margin Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CalculationAndTimingInitialMargin
{
    {nlq::NlqProfile.description = 'cashSettlementDay'}
    cashSettlementDay: String[0..1];
    {nlq::NlqProfile.description = 'securitiesSettlementDay'}
    securitiesSettlementDay: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Calculation, Valuation and Timing terms specific to the Initial Margin Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CalculationAndTimingCollateralTransferAgreement
{
    {nlq::NlqProfile.description = 'cashSettlementDay'}
    cashSettlementDay: String[0..1];
    {nlq::NlqProfile.description = 'securitiesSettlementDay'}
    securitiesSettlementDay: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container designed to hold a set of related data. In this case, designed to hold a set of clauses that are common amongst Legacy (1994/95...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CalculationAndTimingBase
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the ISDA SIMM Calculation Currency.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CalculationCurrencyElection
{
    {nlq::NlqProfile.description = 'The party which the SIMM Calculation Currency qualification applies to.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The SIMM Calculation Currency (also known as SIMM Reporting Currency) means the Base Currency when True. It means a d...'}
    isBaseCurrency: Boolean[1];
    {nlq::NlqProfile.description = 'The currency in which the ISDA SIMM Calculation is denominated, when different from the Base Currency. The list of va...'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Calculation Date Location for the respective parties to the legal agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ValuationCalculationDateLocation
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify each of the party elections with respect to the Calculation Date Location.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ValuationCalculationDateLocationElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The Calculation Date Location when specified as a business center which corresponds to the FpML list of business cent...'}
    businessCenter: String[0..1];
    {nlq::NlqProfile.description = 'The Calculation Date Location when specified a location which doesn\'t correspond to the FpML list of business center...'}
    customLocation: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify Collateral Access Breach language.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralAccessBreach
{
    {nlq::NlqProfile.description = 'Collateral Access Breach terms are applicable when True and not applicable when False.'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'Determination of whether the Collateral Access Breach end date is a number of days (True) or specified (False).'}
    cabEndDateElection: Boolean[0..1];
    {nlq::NlqProfile.description = 'The business days following the related Collateral Access Breach when the additional terms end.'}
    cabEndDate: Float[0..1];
    {nlq::NlqProfile.description = 'Specific terms for when Collateral Access Breach terms end.'}
    cabEndDateTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Collateral Management Agreement election.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralManagementAgreement
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Collateral Management Agreement election.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralManagementAgreementElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The designated Collateral Management Agreement with respect to the elective party as the Obligee.'}
    collateralManagementAgreement: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the rounding methodology applicable to the Delivery Amount and the Return Amount.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralRounding
{
    {nlq::NlqProfile.description = 'The nearest integral multiple of Base Currency units to which the Delivery Amount will be rounded in accordance with ...', nlq::NlqProfile.unit = 'currency'}
    deliveryAmount: Float[1];
    {nlq::NlqProfile.description = 'The rounding rule applicable to the Delivery Amount (which can be (i) up to nearest; (ii) down to nearest).'}
    deliveryDirection: math::RoundingModeEnum[1];
    {nlq::NlqProfile.description = 'The nearest integral multiple of Base Currency units to which the Return Amount will be rounded in accordance with th...', nlq::NlqProfile.unit = 'currency'}
    returnAmount: Float[1];
    {nlq::NlqProfile.description = 'The rounding rule applicable to the Return Amount (which can be (i) up to nearest; (ii) down to nearest).'}
    returnDirection: math::RoundingModeEnum[1];
    {nlq::NlqProfile.description = 'The currency in which the Delivery Amount and Return Amount rounding amounts are specified.'}
    currency: asset::ISOCurrencyCodeEnum[1];
    {nlq::NlqProfile.description = 'Utilised where the clause data structure is not able to capture a material aspect of the clause.'}
    other: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the two set of elections that may overwrite the default Condition Precedent provision.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ConditionsPrecedent
{
    {nlq::NlqProfile.description = 'The election to specify whether the standard Conditions Precedent apply.'}
    conditionsPrecedentElection: csa::ExceptionEnum[0..1];
    {nlq::NlqProfile.description = 'The custom provisions that might be specified by the parties to the agreement for the purpose of overwriting the defa...'}
    customProvision: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the relationship between the Control Agreement and the Credit Support Agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ControlAgreement
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Control Agreement election sby each party to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ControlAgreementElections
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The identification of whether the Control Agreement is a Credit Support Document with respect to each party.'}
    controlAgreementAsCsd: Boolean[1];
    {nlq::NlqProfile.description = 'Unless specified as inapplicable in the event of any inconsistency between this Deed and the Control Agreement, this ...'}
    consistencyWithControlAgreement: Boolean[0..1];
    {nlq::NlqProfile.description = 'Unless specified as inapplicable the parties recognise that the Control Agreement is a means by which the parties can...'}
    relationshipWithControlAgreement: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify Control Agreement language related to delivery of a Notice of Exclusive Control.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ControlAgreementNecEvent
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify party specific Control Agreement language related to delivery of a Notice of Exclusive Control.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ControlAgreementNecEventElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Indicates Control Agreement language related to delivery of a Notice of Exclusive Control.'}
    necEvent: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the custodian and custody account details for each party to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::Custodian
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the custodian and custody account details for each party to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CustodianElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Details how the Custodian is determined.'}
    legacyVMCustodian: csa::LegacyVMCustodianEnum[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Custodian Event.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CustodianEvent
{
    {nlq::NlqProfile.description = 'The qualification as to whether the Custodian Event (English Law & New York Law ISDA CSA) or the Collateral Manager E...'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Custodian Event.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CustodianEventEndDate
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Custodian Risk elections specific to a Credit Support Agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CustodianRisk
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Custodian Risk.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CustodianRiskElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'The qualification as to whether the risk is deemed as Specified.'}
    isSpecified: Boolean[1];
    {nlq::NlqProfile.description = 'The Custodian Risk or Collateral Manager Risk qualification.'}
    qualification: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the requirements applicable to the custodian with respect to the holding of posted collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CustodianTerms
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Describes how posted collateral is held, maintained, and safeguarded by a custodian or third-party agent, in accordance with the terms of the gover...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CustodyArrangements
{
    {nlq::NlqProfile.description = 'Unless specified as True, the Control Agreement is not a Credit Support Document under the agreement with respect to ...'}
    isCreditSupportDocument: Boolean[0..1];
    {nlq::NlqProfile.description = 'Control Agreement language is specified when True.'}
    hasControlAgreementLanguage: Boolean[0..1];
    {nlq::NlqProfile.description = 'Other Custom Provisions of Custody Arrangements.'}
    otherProvisions: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the election terms under which a party disputes the Value of any Transfer of Eligible Credit Support or Posted Credit Support.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::DisputeResolution
{
    {nlq::NlqProfile.description = 'The custom Resolution Time election that might be specified by the parties.'}
    otherTerms: String[0..1];
    {nlq::NlqProfile.description = 'The alternative dispute resolution procedure if specified.'}
    alternativeTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the party elective amounts which can be used for the purpose of specifying elections such as the ISDA CSA Threshold and Minimum ...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ElectiveAmountElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Specifies an enumerated election to express the elective amount.'}
    electiveAmount: csa::ElectiveAmountEnum[0..1];
    {nlq::NlqProfile.description = 'The elective amount when expressed as a custom election by the party.'}
    customElection: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify Enforcement Events specific to Security Agreements.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::EnforcementEvent
{
    {nlq::NlqProfile.description = 'The early termination election.'}
    earlyTerminationDate: Boolean[1];
    {nlq::NlqProfile.description = 'The failure to pay election.'}
    failureToPay: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify execution language terms of a Security Agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ExecutionLanguage
{
    {nlq::NlqProfile.description = 'A boolean attribute to determine if standard language is applicable or not.'}
    standardLanguage: Boolean[1];
    {nlq::NlqProfile.description = 'The number of original documents.'}
    numberOfOriginals: String[0..1];
    {nlq::NlqProfile.description = 'Bespoke execution language to be included when specified.'}
    otherLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify execution location terms of a Security Agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ExecutionLocation
{
    {nlq::NlqProfile.description = 'The execution location of the agreement.'}
    executionLocation: legaldoc::ExecutionLocationEnum[1];
    {nlq::NlqProfile.description = 'Bespoke execution location language to be included when specified.'}
    otherLanguage: String[0..1];
    {nlq::NlqProfile.description = 'The payer of documentary duty.'}
    dutyPayer: String[0..1];
    {nlq::NlqProfile.description = 'Bespoke terms specific to the payment of documentary duty.'}
    dutyPayerLanguage: String[0..1];
    {nlq::NlqProfile.description = 'The date that documentary duty will be paid.'}
    dutyPaymentDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Bespoke terms specific to the date that documentary duty will be paid.'}
    dutyPaymentLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify execution location and language of execution to determine duty to be paid.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ExecutionTerms
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify party specific elections when a Collateral Transfer Agreement is governed by French Law.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::FrenchLawAddendum
{
    {nlq::NlqProfile.description = 'The qualification of whether the French Law Addendum is deemed applicable by the parties (True) or not (False).'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify party specific French Law Addendum language.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::FrenchLawAddendumElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The qualification of whether the party elects specific language.'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'The party specific language to be included in the agreement.'}
    addendumLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the reference currency for the purpose of specifying the FX Haircut relating to a posting obligation, as being either the Termin...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::FxHaircutCurrency
{
    {nlq::NlqProfile.description = 'The reference currency for the purpose of specifying the FX Haircut relating to a posting obligation is the Terminati...'}
    isTerminationCurrency: Boolean[1];
    {nlq::NlqProfile.description = 'When specified, the reference currency for the purpose of specifying the FX Haircut relating to a posting obligation....'}
    fxDesignatedCurrency: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the ISDA SIMM as the Method for all Covered Transactions with respect to all Regimes.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::GeneralSimmElections
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the conditions that need to be satisfied before the Secured Party or Custodian acting on its behalf can hold and use posted collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::HoldingAndUsingPostedCollateral
{
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the parties\' elections related to the holding and using of posted collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::HoldingAndUsingPostedCollateralElection
{
    {nlq::NlqProfile.description = 'The party to which the elections apply.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Indicates whether the party has the right to reuse, rehypothecate, or otherwise make use of the posted collateral. \'...'}
    useOfPostedCollateral: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identifies collateral that has been designated as not meeting the eligibility criteria set out in the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::IneligibleCreditSupport
{
    {nlq::NlqProfile.description = 'Specifies the date from which all credit support provided by a party is treated as ineligible under the agreement.'}
    totalIneligibilityDate: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the date from which the transfer of credit support by a party is treated as ineligible under the agreement.'}
    transferIneligibilityDate: String[0..1];
    {nlq::NlqProfile.description = 'Identifies a party designated in the agreement for the purpose of applying particular rights, obligations, or elections.'}
    specifiedParty: party::CounterpartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify whether the Interest Adjustment is applicable and what its periodicity is.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::InterestAdjustment
{
    {nlq::NlqProfile.description = 'The Interest Adjustment is applicable when True and not applicable when False.'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Interest Adjustment periodicity.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::InterestAdjustmentPeriodicity
{
    {nlq::NlqProfile.description = 'The Interest Adjustment periodicity when specified through a standardized election.'}
    standardElection: csa::InterestAdjustmentPeriodicityEnum[0..1];
    {nlq::NlqProfile.description = 'The Interest Adjustment periodicity when specified through a custom election.'}
    customElection: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the application of Interest Amount with respect to the Delivery Amount and the Return Amount.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::InterestAmount
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify Japanese Securities Provision elections.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::JapaneseSecuritiesProvisions
{
    {nlq::NlqProfile.description = 'Japanese Securities Provisions are applicable when True and Not Applicable when False.'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'Recommended Japanese Securities Provisions are applicable when True, additional Provisions are specified when False.'}
    relevantProvisionsElection: Boolean[0..1];
    {nlq::NlqProfile.description = 'Specific terms applicable to Recommended Japanese Securities Provisions.'}
    relevantProvisionsTerms: String[0..1];
    {nlq::NlqProfile.description = 'Additional Amendments to Japanese Securities Provisions are specified when True, and not specified when False.'}
    amendmentsToJapaneseProvisions: Boolean[0..1];
    {nlq::NlqProfile.description = 'Specific terms applicable to Additional Amendments to Japanese Securities Provisions.'}
    amendmentsToJapaneseProvisionsTerms: String[0..1];
    {nlq::NlqProfile.description = 'Specification of whether Clearstream Event amendment language is included (true) or excluded (false).'}
    clearstreamAmendmentToJapaneseProvisions: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify terms jurisdiction related terms.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::JurisdictionRelatedTerms
{
    {nlq::NlqProfile.description = 'Classification of optional exclusive jurisdiction terms.'}
    exclusiveJurisdiction: Boolean[0..1];
    {nlq::NlqProfile.description = 'The Jury Waiver conditions specific to the agreement.'}
    juryWaiver: Boolean[0..1];
    {nlq::NlqProfile.description = 'The qualification of whether the Belgian Law Security Agreement Addendum is deemed applicable by the parties (True) o...'}
    belgianLawSecurityAgreement: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for selection of Margin Approach.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::MarginApproach
{
    {nlq::NlqProfile.description = 'Specifies the margin approach specific to Initial Margin agreements.'}
    marginApproach: csa::MarginApproachEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify whether Amendment to Minimum Transfer Amount language is applicable or not.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::MinimumTransferAmountAmendment
{
    {nlq::NlqProfile.description = 'The definition of Minimum Transfer Amount in any Other Regulatory CSA will be amended when applicable.'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the time by which a demand for the Transfer of Eligible Credit Support or Posted Credit Support needs to be made in order for the transfe...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::NotificationTime
{
    {nlq::NlqProfile.description = 'The determination of whether reference is made to dispute resolution notification timing in the agreement.'}
    disputeNotificationReference: Boolean[0..1];
    {nlq::NlqProfile.description = 'The determination of whether transfer timing language is applicable or not.'}
    transferTimingProviso: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the notification time election by the respective parties to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::NotificationTimeElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The Notification Time as a bespoke election.'}
    customNotification: String[0..1];
    {nlq::NlqProfile.description = 'Whether the Notification Time is precluded on the day being a local business day.'}
    localBusinessDay: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify whether One Way Provisions apply.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::OneWayProvisions
{
    {nlq::NlqProfile.description = 'The determination of whether the One Way Provisions are applicable (true) or not applicable (false).'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'The Posting Party for the purposes of One Way Provisions. It is specified in the case where the One Way Provision is ...'}
    postingParty: party::CounterpartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The bespoke definition of other agreements or other credit support annex terms as specified by the parties to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::OtherAgreements
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the Other Eligible Support elections.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::OtherEligibleAndPostedSupport
{
    {nlq::NlqProfile.description = 'The definition of \'Value\' with respect to Other Eligible Support and Other Posted Support.'}
    applicableValue: Boolean[0..1];
    {nlq::NlqProfile.description = 'The definition of \'Transfer\' with respect to Other Eligible Support and Other Posted Support.'}
    applicableTransfer: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a legal agreement identifier issued by the indicated party.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::PartyAgreementIdentifier
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the collateral posting obligations of the security provider or security providers as specified in the corresponding agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::PostingObligations
{
    {nlq::NlqProfile.description = 'The security provider party(ies) to which the posting obligations apply to, which can be either one of the parties to...'}
    securityProvider: party::CounterpartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the collateral posting obligations for the security provider party(ies).',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::PostingObligationsElection
{
    {nlq::NlqProfile.description = 'Specifies the party providing the security.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'If set to True, the Control Agreement is a Credit Support Document with respect to the party(ies).'}
    asPermitted: Boolean[1];
    {nlq::NlqProfile.description = 'The excluded collateral as specified in relation to the pledgor/chargor/obligor(s) posting obligation.'}
    excludedCollateral: String[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the Process Agent that might be appointed by the parties as part of a Credit Support Annex/Deed or Collateral Transfer Agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ProcessAgent
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the parties\' respective elections with respect to the Process Agent.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ProcessAgentElection
{
    {nlq::NlqProfile.description = 'The qualification of whether the Process Agent is applicable (True) or not applicable (False).'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'Additional information relating to the Process Agent.'}
    additionalInformation: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify terms for Recalculation of the Market Value of Posted Collateral when a dispute has been failed to be resolved by Resolution Time.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RecalculationOfValue
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify Recalculation of Value terms that will be applicable.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RecalculationOfValueElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The procedure for Recalculation of Value.'}
    recalculationOfValueElection: csa::RecalculationOfValueElectionEnum[1];
    {nlq::NlqProfile.description = 'Additional Recalculation of Value terms when specified.'}
    recalculationOfValueTerms: String[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class to specify one or more regimes that may be specified as relevant to a legal agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::Regime
{
    {nlq::NlqProfile.description = 'The specification of the number of days after effective delivery of notice that Mandatory method fallback applies. Sp...'}
    fallbackToMandatoryMethodDays: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class that is used by the ApplicableRegime and the AdditionalRegime classes to specify the regulatory regime terms.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RegimeTerms
{
    {nlq::NlqProfile.description = 'The party for which the regime terms are being specified when acting as collateral taker.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The specification of whether the regime is elected as applicable to the party when acting as collateral taker.'}
    isApplicable: csa::ExceptionEnum[0..1];
    {nlq::NlqProfile.description = 'The bespoke party specific Regime term elections applicable when specified.'}
    asSpecified: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The terms of the Rider for the ISDA Euroclear 2019 Collateral Transfer Agreement with respect to the use of a Pledgee Representative attached to th...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::PledgeeRepresentativeRider
{
    {nlq::NlqProfile.description = 'Identification of whether the representative CTA provisions are applicable (True) or not applicable (False).'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'Identification of the represented party.'}
    party: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'The specific representative terms applicable when specified.'}
    representativeTerms: String[0..1];
    {nlq::NlqProfile.description = 'The specification of whether the representative event terms are applicable.'}
    representativeEvent: csa::ExceptionEnum[0..1];
    {nlq::NlqProfile.description = 'The specific representative event terms applicable when specified.'}
    representativeEventTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the retrospective effect exception to the regulatory regime clause of Initial Margin documents as either a normalized value spec...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RetrospectiveEffect
{
    {nlq::NlqProfile.description = 'The Standard Initial Margin Model exception when specified by the party according to one of the enumerated values.'}
    standardisedException: csa::ExceptionEnum[0..1];
    {nlq::NlqProfile.description = 'The Standard Initial Margin Model exception when specified as a customized approach by the party.'}
    asSpecified: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the rights of Security Taker and/or Security Provider when an Early Termination or Access Condition event has occurred.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RightsEvents
{
    {nlq::NlqProfile.description = 'The specification of whether Delivery In Lieu language is applicable to the agreement (true) or not (false).'}
    deliveryInLieuRight: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify Secured Party Rights Event language.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SecuredPartyRightsEvent
{
    {nlq::NlqProfile.description = 'A boolean attribute to specify whether Failure to Pay Early Termination language in the agreement is deemed applicabl...'}
    failureToPayEarlyTermination: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify party specific Secured Party Rights Event language.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SecuredPartyRightsEventElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'A boolean attribute to specify whether a Secured Party Rights Event will only occur upon the occurrence of one or mor...'}
    rightsEvent: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Pledgor/Obligor/Chargor Rights Event election.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SecurityProviderRightsEvent
{
    {nlq::NlqProfile.description = 'If specified as applicable here, a Pledgor/Obligor/Chargor Rights Event will not occur unless the Pledgor/Obligor/Cha...'}
    fullDischarge: Boolean[0..1];
    {nlq::NlqProfile.description = 'The Automatic Set-Off provision applies when the value is set to True.'}
    automaticSetOff: Boolean[0..1];
    {nlq::NlqProfile.description = 'A custom Pledgor/Obligor/Chargor Rights Event election might be specified by the parties.'}
    customElection: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify party specific Secured Party Rights Event language.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SecurityProviderRightsEventElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'If True, the Rights Event language applies for the specified Party.'}
    rightsEvent: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specificy methodologies to compute sensitivities specific to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SensitivityMethodologies
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specificy methodologies to compute sensitivities specific to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SensitivityMethodologiesPartyElection
{
    {nlq::NlqProfile.description = 'The party to which the election applies.'}
    party: party::CounterpartyRoleEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents risk sensitivity calculated with respect to the value of an individual equity instrument.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SensitivityToEquity
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the methodology according to which sensitivities are computed.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SensitivityMethodology
{
    {nlq::NlqProfile.description = 'The methodology according to which sensitivities will be computed, when specified through a normalized election.'}
    specifiedMethodology: csa::SensitivitiesEnum[0..1];
    {nlq::NlqProfile.description = 'The methodology according to which sensitivities will be computed, when specified through a custom election.'}
    customMethodology: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the SIMM Calculation Currency elections by each party to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SimmCalculationCurrency
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the SIMM exception to the regulatory regime clause.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SimmException
{
    {nlq::NlqProfile.description = 'The Standard Initial Margin Model exception when specified by the party according to one of the enumerated values.'}
    standardisedException: csa::ExceptionEnum[0..1];
    {nlq::NlqProfile.description = 'The Standard Initial Margin model exception approach applicable when specified by the party according to one of the e...'}
    simmExceptionApplicable: csa::SimmExceptionApplicableEnum[0..1];
    {nlq::NlqProfile.description = 'The Standard Initial Margin Model exception when specified as a customized approach by the party.'}
    asSpecified: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the ISDA SIMM version that applies to the ISDA 2018 CSA for Initial Margin.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SimmVersion
{
    {nlq::NlqProfile.description = 'A boolean attribute to determine whether the SIMM version is specified for the purpose of the legal agreement.'}
    isSpecified: Boolean[0..1];
    {nlq::NlqProfile.description = 'The party which the specified SIMM version applies to.'}
    partyVersion: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'The SIMM version exception when specified as a customized approach by the party.'}
    asSpecified: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify each party\'s election with respect to the Substituted Regimes that will be applicable...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SubstitutedRegime
{
    {nlq::NlqProfile.description = 'The applicable regulatory regime, as specified through an enumeration.'}
    regime: csa::RegulatoryRegimeEnum[0..1];
    {nlq::NlqProfile.description = 'The additional regulatory regime as specified by the parties.'}
    additionalRegime: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the applicability of the Substituted Regime as denoted in the Substituted Regime Table as part of certain legal agreements, such as such ...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SubstitutedRegimeTerms
{
    {nlq::NlqProfile.description = 'The party for which the regime terms are being specified when acting as collateral taker.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The specification of whether the regime is elected as applicable to the party when acting as collateral taker.'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the conditions under which the Security Provider can substitute posted collateral. The details required for \'Legacy\' agreement...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::Substitution
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Party specific elections for substitution of posted collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SubstitutionPartyElection
{
    {nlq::NlqProfile.description = 'The party that is acting as the Pledgor/Obligor/Chargor/Security Provider.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The election as to whether the Pledgor/Obligor/Chargor/Security Provider must obtain the Secured Partys consent for a...'}
    needsConsent: Boolean[1];
    {nlq::NlqProfile.description = 'Substitution Date has the meaning specified in Paragraph4(d)(ii), unless otherwise specified.'}
    substitutionDateLanguage: String[0..1];
    {nlq::NlqProfile.description = 'Specific consent language might be specified by the parties.'}
    specificConsentLanguage: String[0..1];
    {nlq::NlqProfile.description = 'The process for substituting/exchanging one form of collateral held by a party for a different form of collateral, us...'}
    legacyConsent: csa::LegacyConsentEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Amendment to Termination Currency elections by the parties to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::TerminationCurrencyAmendment
{
    {nlq::NlqProfile.description = 'The qualification of whether the Amendment to Termination Currency is deemed applicable by the parties (True) or not ...'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Amendment to Termination Currency election by the parties to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::TerminationCurrencyElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'The qualification of whether the Termination Currency is specified in this document (True) or in an Eligible Support ...'}
    isSpecified: Boolean[1];
    {nlq::NlqProfile.description = 'The Termination Currency associated with the party that referenced as part of this class. The list of valid currencie...'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The election of party specific additional obligations applicable to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AdditionalObligations
{
    {nlq::NlqProfile.description = 'The party that the additional obligations apply to.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'The party specific additional obligations applicable to the agreement.'}
    additionalObligations: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The base and eligible currency(ies) for the document as specified by the parties to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::BaseAndEligibleCurrency
{
    {nlq::NlqProfile.description = 'The common agreed currency into which relevant amounts of all collateral arrangements between the parties are convert...'}
    baseCurrency: asset::ISOCurrencyCodeEnum[1];
    {nlq::NlqProfile.description = 'A flag detailing whether the Base Currency is set to  the Termination Currency as defined in the related  Master Agre...'}
    baseCurrencyTerminationCurrency: Boolean[1];
    {nlq::NlqProfile.description = 'Utilised where the clause data structure is not able to capture a material aspect of the clause.'}
    baseCurrencyOther: String[0..1];
    {nlq::NlqProfile.description = 'A definition of a currency agreed by the parties, typically to indicate the currencies of eligible cash collateral.'}
    eligibleCurrency: asset::ISOCurrencyCodeEnum[*];
    {nlq::NlqProfile.description = 'A flag detailing whether the Base Currency is included as an Eligible Currency.'}
    eligibleCurrencyInclBaseCurrency: Boolean[1];
    {nlq::NlqProfile.description = 'Utilised where the clause data structure is not able to capture a material aspect of the clause.'}
    eligibleCurrencyOther: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of Transactions covered by the legal agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CoveredTransactions
{
    {nlq::NlqProfile.description = 'Includes any Transaction specified below that is entered into on or after the specified date.'}
    inclusionDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Covered Transactions when not expressed using the ISDA taxonomy.'}
    bespokeCoveredTransactions: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container designed to hold a set of related data. In this case, designed to hold a set of clauses that are common amongst Legacy (1994/95...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportObligationsBase
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Credit Support Obligations applicable to the Legacy (1994/95) Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportObligationsLegacy
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Credit Support Obligations applicable to the Initial Margin Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportObligationsInitialMargin
{
    {nlq::NlqProfile.description = 'The Other Eligible Support election. If not specified, this election is deemed as not applicable.'}
    otherEligibleSupportIM: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Credit Support Obligations applicable to the Initial Margin Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportObligationsCollateralTransferAgreement
{
    {nlq::NlqProfile.description = 'The Other Eligible Support election. If not specified, this election is deemed as not applicable.'}
    otherEligibleSupportIM: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the Credit Support Obligations applicable to the Variation Margin Credit Support Annex.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportObligationsVariationMargin
{
    {nlq::NlqProfile.description = 'The additional currencies that are specified as Major Currency for the purpose of applying the FX Haircut Percentage.'}
    majorCurrency: String[*];
    {nlq::NlqProfile.description = 'The alternative definition for FX haircut percentage that applies to each party and item of Eligible Collateral unles...'}
    fxHaircut: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the collateral posting obligations of the security provider or security providers as specified in the corresponding agreement',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::EligibleCreditSupport
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the collateral posting obligations for the security provider party(ies).',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::EligibleCollateralElection
{
    {nlq::NlqProfile.description = 'Specifies the Other Eligible Support conditions. If not specified, this election is deemed as not applicable.'}
    otherEligibleSupport: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Security Interest for Obligations clause applicable to 1994 NY CSA, 1995 English Law CSA, 1995 English Law Credit Support Deed, 2016 English Law VM...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SecurityInterestForObligations
{
    {nlq::NlqProfile.description = 'The elective party to which the Security Interest for Obligations is applicable.'}
    party: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'A description of any additional obligations secured by the credit support arrangements.'}
    obligations: csa::SecurityInterestObligationsEnum[1];
    {nlq::NlqProfile.description = 'The party to whom obligations under the Master Agreement are owed and secured by the credit support arrangements.'}
    obligee: csa::SecurityInterestObligeeEnum[1];
    {nlq::NlqProfile.description = 'Exception value.'}
    other: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Where only a single  party is explicitly designated to post collateral, the party which is specified as the sole poster of collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SinglePostingParty
{
    {nlq::NlqProfile.description = 'The party acting as the Single Posting Party.'}
    party: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Utilised where the clause data structure is not able to capture a material aspect of the clause.'}
    other: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the amount of unsecured risk that a party is willing to tolerate without holding any posted collateral provided by the other party.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::Threshold
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container designed to hold a set of related data. In this case, designed to hold a set of information required to specify conditions unde...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ThresholdMinmumTransferAmountBase
{
    {nlq::NlqProfile.description = 'Indicates whether a trigger applies for the Threshold or Minimum Transfer Amount to fall to zero. If \'True\' then su...'}
    zeroEvent: Boolean[1];
    {nlq::NlqProfile.description = 'Specifies the relevant trigger for the Threshold or Minimum Transfer Amount to fall to zero.'}
    event: csa::ZeroEventEnum[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies whether the threshold is rating based, a fixed amount, or infinity.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ThresholdElection
{
    {nlq::NlqProfile.description = 'The party to which the threshold applies.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Specifies that the Threshold is Infinity. If \'True\' then the threshold for the elective party is Infinity.'}
    infinity: Boolean[0..1];
    {nlq::NlqProfile.description = 'Utilised where the clause data structure is not able to capture a material aspect of the clause.'}
    other: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines that the Threshold is based on Ratings condition(s).',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ThresholdRatingsBased
{
    {nlq::NlqProfile.description = 'The threshold currency code.'}
    currency: asset::ISOCurrencyCodeEnum[1];
    {nlq::NlqProfile.description = 'The relevant rating type.'}
    ratingType: csa::RatingTypeEnum[1];
    {nlq::NlqProfile.description = 'The party to which a rating applies.'}
    ratedParty: csa::RatedPartyEnum[0..1];
    {nlq::NlqProfile.description = 'Details the Named Entity where the Rated Party is Named Entity.'}
    namedEntity: String[0..1];
    {nlq::NlqProfile.description = 'Details the Named Affiliate where the Rated Party is Named Affiliate.'}
    namedAffiliate: String[0..1];
    {nlq::NlqProfile.description = 'Where two ratings are specified whether the higher or lower rating prevails.'}
    compare: observable::CreditNotationMismatchResolutionEnum[0..1];
    {nlq::NlqProfile.description = 'What conditions apply where a party has no rating.'}
    noRating: Boolean[1];
    {nlq::NlqProfile.description = 'Defines where conditions apply if no Rating where ratings may not exist.'}
    notRatedBy: csa::NotRatedByEnum[0..1];
    {nlq::NlqProfile.description = 'Defines the number of Rating Agencies that the Party must be rated by.'}
    numberOfRatingAgencies: csa::NumberOfRatingAgenciesEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a combination of Rating Agency, Rating Value, Threshold amount and Currency code.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CSAThresholdVariableSet
{
    {nlq::NlqProfile.description = 'The relevant rating agency.'}
    name: observable::CreditRatingAgencyEnum[0..1];
    {nlq::NlqProfile.description = 'Rating applicable to the party from a given rating agency.'}
    value: String[0..1];
    {nlq::NlqProfile.description = 'The amount value applicable to the Threshold.'}
    amount: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the threshold specified in the agreement below which collateral need not be delivered, and represents the smallest incremental value of ...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::MinimumTransferAmount
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the method by which the minimum transfer amount is defined, such as a fixed amount, ratings based, or an alternative basis set out in the...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::MinimumTransferAmountElection
{
    {nlq::NlqProfile.description = 'The party to which the minimum transfer amount applies.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Utilised where the clause data structure is not able to capture a material aspect of the clause.'}
    other: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the Threshold or the Minimum Transfer Amount (MTA) as a fixed amount.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ThresholdMinimumTransferAmountFixedAmount
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines that the Minimum Transfer Amount (MTA) is based on a Ratings condition(s).',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::MinimumTransferAmountRatingsBased
{
    {nlq::NlqProfile.description = 'The minimum transfer amount currency code.'}
    currency: asset::ISOCurrencyCodeEnum[1];
    {nlq::NlqProfile.description = 'The relevant rating type.'}
    ratingType: csa::RatingTypeEnum[1];
    {nlq::NlqProfile.description = 'The party to which a rating applies.'}
    ratedParty: csa::RatedPartyEnum[0..1];
    {nlq::NlqProfile.description = 'Details the Named Entity where the Rated Party is Named Entity.'}
    namedEntity: String[0..1];
    {nlq::NlqProfile.description = 'Details the Named Affiliate where the Rated Party is Named Affiliate.'}
    namedAffiliate: String[0..1];
    {nlq::NlqProfile.description = 'Where two ratings are specified whether the higher or lower rating prevails.'}
    compare: observable::CreditNotationMismatchResolutionEnum[0..1];
    {nlq::NlqProfile.description = 'What conditions apply where a party has no rating.'}
    noRating: Boolean[1];
    {nlq::NlqProfile.description = 'Defines where conditions apply if no Rating where ratings may not exist.'}
    notRatedBy: csa::NotRatedByEnum[0..1];
    {nlq::NlqProfile.description = 'Defines the number of Rating Agencies that the Party must be rated by.'}
    numberOfRatingAgencies: csa::NumberOfRatingAgenciesEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a combination of Rating Agency, Rating Value, amount and Currency code.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CSAMinimumTransferAmountVariableSet
{
    {nlq::NlqProfile.description = 'The name of the Rating Agency.'}
    name: observable::CreditRatingAgencyEnum[0..1];
    {nlq::NlqProfile.description = 'The value assigned to the rating.'}
    value: String[0..1];
    {nlq::NlqProfile.description = 'The Minimum Transfer Amount (MTA) applicable to the Rating.'}
    amount: Integer[0..1];
    {nlq::NlqProfile.description = 'A flag that defines the Minimum Transfer Amount (MTA) as Infinity.'}
    amountIsInfinity: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the dates agreed by the parties as the date of the Credit Support Annex or Credit Support Deed.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::MasterAgreementDatedAsOfDate
{
    {nlq::NlqProfile.description = 'The date agreed by the parties as the Dated as of Date for the Master Agreement.'}
    masterAgreementDatedAsOfDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'In respect of a Valuation Date, the amount of collateral which a party is entitled to demand to be transferred to it as a Delivery Amount.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CSADeliveryAmount
{
    {nlq::NlqProfile.description = 'Specifies whether the meaning of Delivery Amount follows the pre-print definition or deviates from this (either based...'}
    deliveryAmount: csa::DeliveryReturnAmountEnum[1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'In respect of a Valuation Date, the amount of collateral which a party is entitled to demand to be recalled to it as a Return Amount.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CSAReturnAmount
{
    {nlq::NlqProfile.description = 'Specifies whether the meaning of Return Amount follows the pre-print definition or deviates from this (either based o...'}
    returnAmount: csa::DeliveryReturnAmountEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the time by which the value of the collateral and obligations to transfer or return collateral are to be calculated relative to the Valua...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ValuationTime
{
    {nlq::NlqProfile.description = 'The day in respect of which the Valuation Time is being specified. If not specified, addional language must be used t...'}
    day: csa::ValuationTimeDayEnum[0..1];
    {nlq::NlqProfile.description = 'The location relevant to the timezone for the Valuation Time.'}
    location: String[*];
    {nlq::NlqProfile.description = 'The type of time specified for the Valuation Time.'}
    time: csa::ValuationTimeEnum[0..1];
    {nlq::NlqProfile.description = 'A time specified in a 24-hour notation, e.g. 3pm would be represented as 15:00.'}
    hourminutetime: String[0..1];
    {nlq::NlqProfile.description = 'Any relevant time zone where specified.'}
    timezone: String[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A clause providing that final return collateral is to be provided without consideration of any Minimum Transfer Amount and collateral haircut.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::FinalReturns
{
    {nlq::NlqProfile.description = 'Defines if the clause is applicable to this agreement or any other exceptions.'}
    applicable: Boolean[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the date on which the value of collateral or exposure are calculated in accordance with the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CSAValuationDate
{
    {nlq::NlqProfile.description = 'Defines whether a date is defined by a certain day of the week or a particular date in the month. If not specified he...'}
    date: csa::ValuationDateDateEnum[0..1];
    {nlq::NlqProfile.description = 'Specific day(s) or day of the week, if any, specified for Valuation Time.'}
    day: csa::ValuationDateDayEnum[0..1];
    {nlq::NlqProfile.description = 'Defines the day of the calendar if this is specified for in the ValuationDateDateEnum.'}
    calendarDay: Float[0..1];
    {nlq::NlqProfile.description = 'Defines the regularity of the date specified for the Valuation Date.'}
    frequency: csa::ValuationDateFrequencyEnum[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Details of the party valuating the collateral to be delivered or returned.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ValuationAgent
{
    {nlq::NlqProfile.description = 'Specification of which party calculating the value of collateral to be delivered or returned.'}
    party: csa::CalculationValuationAgentPartyEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies how the Valuation Agent is determined.'}
    valuationAgent: csa::ValuationAgentDeterminationEnum[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Optionally, for each party, specifies the amendments to the included coverage in the calculation of Exposure.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ExposureScope
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of amendments to the calculation of Exposure in terms of the Transactions and Products covered.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::LegacyExposureScopeElection
{
    {nlq::NlqProfile.description = 'The elective party.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'A boolean flag to represent whether any transactions are excluded (ie True) or not (ie False).'}
    excludedTransactions: Boolean[1];
    {nlq::NlqProfile.description = 'The bespoke/additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Description of the relevant derivative transactions excluded from the calculation of exposure.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ExcludedProducts
{
    {nlq::NlqProfile.description = 'Description of the relevant derivative transactions excluded from the calculation of exposure.'}
    product: csa::ExposureScopeProductEnum[*];
    {nlq::NlqProfile.description = 'Description of the specific branch entered into by the relevant party.'}
    branch: String[*];
    {nlq::NlqProfile.description = 'A flag to indicate whether transactions entered into by a specific branch with respect to the relevant party are excl...'}
    excluded: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The total amount one counterparty must deliver to the other at any time: the combination of the Exposure to that party and the net Independent Amou...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportAmount
{
    {nlq::NlqProfile.description = 'Specifies whether the meaning of credit support amount follows the pre-print definition or deviates from the standard...'}
    creditSupportAmount: csa::CreditSupportAmountEnum[1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Alternative procedures to those in the pre-print for resolving collateral related disputes.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::LegacyResolutionAlternative
{
    {nlq::NlqProfile.description = 'Details of the alternative dispute resolution procedure (if any).'}
    resolutionAlternative: csa::LegacyResolutionAlternativeEnum[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Methodology for resolving disputes in respect of the determination of the value of collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::ResolutionValue
{
    {nlq::NlqProfile.description = 'Details of how cash collateral is valued when resolving disputes.'}
    cash: csa::ValueCashEnum[0..1];
    {nlq::NlqProfile.description = 'Details of how securities collateral is valued when resolving disputes.'}
    securities: csa::ValueSecuritiesEnum[0..1];
    {nlq::NlqProfile.description = 'Represents whether a fallback calculation method is applicable. \'True\' if fallback calculation method is applicable.'}
    fallback: Boolean[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of transfer / settlement timing for cash and securities collateral assuming that the notice is provided before the Notification Time ...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralTransferTiming
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of transfer / settlement timing for cash and securities collateral assuming that the notice is provided before the Notification Time ...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::TransferSettlementTiming
{
    {nlq::NlqProfile.description = 'Details the day on which collateral is required to be transferred relative to the Notification Time.'}
    cashCollateralTransferSettlementTime: csa::CashCTSTimeEnum[0..1];
    {nlq::NlqProfile.description = 'Details the day on which collateral is required to be transferred relative to the Notification Time.'}
    securititesCollateralTransferSettlementTime: csa::SecuritiesCTSTimeEnum[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Bespoke language removing the pre-print requirement to transfer legal title of securities collateral through written instructions to the relevant d...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralTransferTimingDefinition
{
    {nlq::NlqProfile.description = 'A boolean flag to represent bespoke amendment to the pre-print definition of Transfer.'}
    isApplicable: Boolean[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Details how particular types of collateral are valued (other than in respect of a default).',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CollateralValueMethod
{
    {nlq::NlqProfile.description = 'Details of how cash collateral is valued.'}
    cashCollateral: csa::ValueCashEnum[0..1];
    {nlq::NlqProfile.description = 'Details of how securities collateral is valued.'}
    securitiesCollateral: csa::ValueSecuritiesEnum[0..1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identification of party specific Credit Support Documents applicable to the document.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportDocument
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The party election of Credit Support Provider(s), if any.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportDocumentElection
{
    {nlq::NlqProfile.description = 'Specification of the Credit Support Document terms.'}
    creditSupportDocumentTerms: legaldoc::CreditSupportDocumentTermsEnum[1];
    {nlq::NlqProfile.description = 'Specification of a document when not captured under RelatedAgreement.'}
    bespokeCreditSuppportDocument: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identification of party specific Credit Support Providers applicable to the document.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportProvider
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The party election of Credit Support Provider(s), if any.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::CreditSupportProviderElection
{
    {nlq::NlqProfile.description = 'Specification of the Credit Support Provider terms.'}
    creditSupportProviderTerms: legaldoc::CreditSupportProviderTermsEnum[1];
    {nlq::NlqProfile.description = '...'}
    bespokeCreditSuppportProvider: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the events elected by the parties that are deemed an Access Condition (for Initial Margin CSA) or a Specified Condition (for Variation Ma...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SpecifiedConditionOrAccessCondition
{
    {nlq::NlqProfile.description = 'Indicates whether events that could temporarily or permanently suspend rights to rehypothecate, transfer or substitut...'}
    isApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The party specific elections in respect to the Specified Condition and Access Condition clause.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::SpecifiedOrAccessConditionPartyElection
{
    {nlq::NlqProfile.description = 'Identifies the party making the election.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Specifies events that may temporarily or permanently suspend a partys rights to rehypothecate, transfer, or substitut...'}
    specifiedOrAccessCondition: csa::CSASpecifiedOrAccessConditionEnum[*];
    {nlq::NlqProfile.description = 'Specifies events that may lead to the early termination of the Master Agreement, including suspension of the affected...'}
    additionalTerminationEvent: csa::AdditionalTerminationEventEnum[*];
    {nlq::NlqProfile.description = 'Specifies any bespoke Additional Termination Event(s) that are set out in the related Specified Condition clause.'}
    specifiedAdditionalTerminationEvent: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Sets out the additional amount of collateral that is required to be delivered by that party irrespective of the mark-to-market exposure under the r...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::LegacyIndependentAmount
{
    {nlq::NlqProfile.description = 'The additional language that might be specified by the parties to the legal agreement.'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The party specific elections for the Independent Amount clause.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::LegacyIndependentAmountParty
{
    {nlq::NlqProfile.description = 'Identifies the Party making the election.'}
    party: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Specifies whether Independent Amount is applicable to the elected party. If applicable, \'True\', and if not applicab...'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container designed to hold a set of related data. In this case, designed to hold a set of information required when Independent Amount is...',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::IndependentAmountRatings
{
    {nlq::NlqProfile.description = 'Specifies how multiple credit ratings are compared when determining the applicable Independent Amount, and whether th...'}
    compare: csa::IndependentAmountCompareEnum[1];
    {nlq::NlqProfile.description = 'Specifies the party to whom the rating agency rating applies to for the purposes of determining the Independent Amount.'}
    ratedParty: csa::RatedPartyEnum[1];
    {nlq::NlqProfile.description = 'The relevant rating type.'}
    ratingType: csa::RatingTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies that the Independent Amount is determined using a credit rating.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::LegacyIndependentAmountRatingsBased
{
    {nlq::NlqProfile.description = 'Specifies the currency applicable to the relevant Independent Amount.'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A logical container to hold a defined set of related data. In this case the collation of Rating Information and an associated Independent Amount.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RatingAgencyAmount
{
    {nlq::NlqProfile.description = 'Specifies the notional or collateral Independent Amount.', nlq::NlqProfile.unit = 'currency'}
    amount: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies that the Independent Amount is determined using both credit rating and exposure metrics.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::LegacyIndependentAmountRatingsXExposure
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A logical container to hold a defined set of related data. In this case the collation of Ratings Information and associated exposure multiplier.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RatingMultiplier
{
    {nlq::NlqProfile.description = 'Specifies the multiplier applied to exposure based on the credit rating of the rated party.'}
    exposureMultiplier: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container to hold a defined set of related data. In this case the collation of Ratings Information and associated exposure multiplier.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::DirectionRatingMultiplier
{
    {nlq::NlqProfile.description = 'A logical container to hold a defined set of related data. In this case the collation of Ratings Agency, Rating value...'}
    variableSet: String[1..*];
    {nlq::NlqProfile.description = 'Specifies the multiplier applied to exposure based on the credit rating of the rated party.'}
    exposureMultiplier: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used to combine two or more Ratings and associated direction using AND logic.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AllDirectionRating
{
    {nlq::NlqProfile.description = 'allDirectionRating'}
    allDirectionRating: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used to combine two or more Ratings and associated direction using OR logic.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AnyDirectionRating
{
    {nlq::NlqProfile.description = 'anyDirectionRating'}
    anyDirectionRating: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container to hold a defined set of related data. In this case the collation of Ratings Agency, Rating value and an associated direction.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::DirectionRating
{
    {nlq::NlqProfile.description = 'Specifies the direction of measurement for the rated party.'}
    direction: math::CompareOp[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the conditions under which a party and its custodian(s) are entitled to hold collateral.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::EligibilityToHoldCollateral
{
    {nlq::NlqProfile.description = 'Specifies whether the party\'s custodian is eligible to hold the other party\'s posted collateral. If \'True\' then t...'}
    custodianEligibility: Boolean[1];
    {nlq::NlqProfile.description = 'A logical container to hold a defined set of related data. In this case the collation of criteria required by the par...'}
    criteria: String[0..1];
    {nlq::NlqProfile.description = 'The restrictions that might be required by a party and its custodian in terms of country(ies) where the other party\'...'}
    eligibleCountry: String[*];
    {nlq::NlqProfile.description = 'Specifies any additional conditions relevant to the Custodian of the respective parties as set out in the Holding and...'}
    custodianCondition: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used to combine two or more Criteria using AND logic.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AllEligibilityToHoldCollateralCriteria
{
    {nlq::NlqProfile.description = 'allCriteria'}
    allCriteria: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used to combine two or more Criteria using OR logic.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AnyEligibilityToHoldCollateralCriteria
{
    {nlq::NlqProfile.description = 'anyCriteria'}
    anyCriteria: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The amount of net capital.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AmountOfNetCapital
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A logical container designed to hold a set of related data. In this case the Rating Agency, Rating Value and Rating Type.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::RatingAgencyValue
{
    {nlq::NlqProfile.description = 'The relevant rating type.'}
    ratingType: csa::RatingTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the address where the demands, specifications and notices will be communicated to for each of the parties to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::DemandsAndNotices
{
    {nlq::NlqProfile.description = 'Specifies if notice shall be deemed to be effective at the time such notice is actually received unless such notice i...'}
    deemedEffectiveNextLBD: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the address for transfer as specified by the respective parties to the agreement.',
   nlq::NlqProfile.businessDomain = 'Credit Support Annex (CSA)',
   nlq::NlqProfile.whenToUse = 'Use for credit support annexes, collateral eligibility, and margin terms'}
csa::AddressesForTransfer
{
}

// ─── Date & Time (28 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining a date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified bus...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustableDate
{
    {nlq::NlqProfile.description = 'A date subject to adjustment. While in FpML this date is required, this cardinality constraint has been relaxed as pa...'}
    unadjustedDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays chan...'}
    adjustedDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining a series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the ...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustableDates
{
    {nlq::NlqProfile.description = 'A date subject to adjustment.'}
    unadjustedDate: StrictDate[*];
    {nlq::NlqProfile.description = 'The date(s) once the adjustment has been performed. (Note that this date may change if the business center holidays c...'}
    adjustedDate: StrictDate[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining a date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified bus...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustableOrAdjustedDate
{
    {nlq::NlqProfile.description = 'A date subject to adjustment.'}
    unadjustedDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays chan...'}
    adjustedDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This Rosetta class specifies the date as either an unadjusted, adjusted or relative date. It supplements the features of the AdjustableOrAdjustedDa...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustableOrAdjustedOrRelativeDate
{
    {nlq::NlqProfile.description = 'A date subject to adjustment.'}
    unadjustedDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays chan...'}
    adjustedDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class giving the choice between defining a date as an explicit date together with applicable adjustments or as relative to some other (anchor) date.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustableOrRelativeDate
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class giving the choice between defining a series of dates as an explicit list of dates together with applicable adjustments or as relative to so...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustableOrRelativeDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type defining a date (referred to as the derived date) as a relative offset from another date (referred to as the anchor date) plus optional date...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustedRelativeDateOffset
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for specifying the business day calendar location used in determining whether a day is a business day or not, either by specifying this bus...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::BusinessCenters
{
    {nlq::NlqProfile.description = 'A code identifying one or several business day calendar location(s). The set of business day calendar locations are s...'}
    businessCenter: String[*];
    {nlq::NlqProfile.description = 'commodityBusinessCalendar'}
    commodityBusinessCalendar: datetime::CommodityBusinessCalendarEnum[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining a time with respect to a business day calendar location. For example, 11:00:00 GBLO.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::BusinessCenterTime
{
    {nlq::NlqProfile.description = 'A time specified in hh:mm:ss format where the second component must be \'00\', e.g. 11am would be represented as 11:0...'}
    hourMinuteTime: String[1];
    {nlq::NlqProfile.description = 'A code identifying a business day calendar location. A business day calendar location is drawn from the list identifi...'}
    businessCenter: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a range of contiguous business days by defining an unadjusted first date, an unadjusted last date and a business day convention an...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::BusinessDateRange
{
    {nlq::NlqProfile.description = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day, as specified by a...'}
    businessDayConvention: datetime::BusinessDayConventionEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the business day convention and financial business centers used for adjusting any relevant date if it would otherwise fall on a da...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::BusinessDayAdjustments
{
    {nlq::NlqProfile.description = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day.'}
    businessDayConvention: datetime::BusinessDayConventionEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a contiguous series of calendar dates. The date range is defined as all the dates between and including the start and the end date...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::DateRange
{
    {nlq::NlqProfile.description = 'The first date of a date range.'}
    startDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The last date of a date range.'}
    endDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'List of dates.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::DateList
{
    {nlq::NlqProfile.description = 'date'}
    date: StrictDate[1..*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'List of dateTimes.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::DateTimeList
{
    {nlq::NlqProfile.description = 'The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset...'}
    dateTime: DateTime[1..*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining a date frequency, e.g. one day, three months, through the combination of an integer value and a standardized period value that...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::Frequency
{
    {nlq::NlqProfile.description = 'A time period multiplier, e.g. 1, 2, or 3. If the period value is T (Term) then period multiplier must contain the va...'}
    periodMultiplier: Integer[1];
    {nlq::NlqProfile.description = 'A time period, e.g. a day, week, month, year or term of the stream.'}
    period: datetime::PeriodExtendedEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining an offset used in calculating a new date relative to a reference date, e.g. calendar days, business days, commodity Business days,...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::Offset
{
    {nlq::NlqProfile.description = 'In the case of an offset specified as a number of days, this element defines whether consideration is given as to whe...'}
    dayType: datetime::DayTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify an offset either as a normalized [multiplier, period, dayType] or as a custom provision of type string.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::CustomisableOffset
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to define recurring periods or time offsets.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::Period
{
    {nlq::NlqProfile.description = 'A time period multiplier, e.g. 1, 2 or 3 etc. A negative value can be used when specifying an offset relative to anot...'}
    periodMultiplier: Integer[1];
    {nlq::NlqProfile.description = 'A time period, e.g. a day, week, month or year of the stream. If the periodMultiplier value is 0 (zero) then period m...'}
    period: datetime::PeriodEnum[1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class describing a set of dates defined as relative to another set of dates.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::RelativeDates
{
    {nlq::NlqProfile.description = 'The number of periods in the referenced date schedule that are between each date in the relative date schedule. Thus ...'}
    periodSkip: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a date (referred to as the derived date) as a relative offset from another date (referred to as the anchor date). If the anchor da...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::RelativeDateOffset
{
    {nlq::NlqProfile.description = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day, as specified by a...'}
    businessDayConvention: datetime::BusinessDayConventionEnum[1];
    {nlq::NlqProfile.description = 'Specifies the anchor as an href attribute. The href attribute value is a pointer style reference to the element or co...'}
    dateRelativeTo: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays chan...'}
    adjustedDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::TimeZone
{
    {nlq::NlqProfile.description = 'The observation time.'}
    time: String[1];
    {nlq::NlqProfile.description = 'FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by I...'}
    location: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Indicates The period range defined as either a lower and upper period bound, or both.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::PeriodRange
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Indicator to specify if the period bound is defined as a period and whether the bound is inclusive.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::PeriodBound
{
    {nlq::NlqProfile.description = 'Specifies whether the period bound is inclusive, e.g. for a lower bound, false would indicate greater than, whereas t...'}
    inclusive: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Class to representing a method for generating a series of dates.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AveragingSchedule
{
    {nlq::NlqProfile.description = 'Date on which this period begins.'}
    startDate: StrictDate[1];
    {nlq::NlqProfile.description = 'Date on which this period ends.'}
    endDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class giving the choice between defining a series of dates as an explicit list of dates together with applicable adjustments or as relative to so...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::AdjustableRelativeOrPeriodicDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for specifying a calculation period schedule.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::PeriodicDates
{
    {nlq::NlqProfile.description = 'Denotes the enumerated values to specify the day type classification used in counting the number of days between two ...'}
    dayType: datetime::DayTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the frequency at which calculation period end dates occur within the regular part of the calculation period schedule and their r...',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::CalculationPeriodFrequency
{
    {nlq::NlqProfile.description = 'The roll convention specifies the period term as part of a periodic schedule, i.e. the calculation period end date wi...'}
    rollConvention: datetime::RollConventionEnum[1];
    {nlq::NlqProfile.description = 'Indicates, when true, that that the first Calculation Period should run from the Effective Date to the end of the cal...'}
    balanceOfFirstPeriod: Boolean[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Represents the parameters for describing how often something (such as collateral interest) is to be calculated.',
   nlq::NlqProfile.businessDomain = 'Date & Time',
   nlq::NlqProfile.whenToUse = 'Use for date adjustments, business day conventions, calculation periods, and date schedules'}
datetime::CalculationFrequency
{
    {nlq::NlqProfile.description = 'Specifies the month of the year if used.'}
    monthOfYear: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies the day of the month if used.'}
    dayOfMonth: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies the day of the week if used.'}
    dayOfWeek: datetime::DayOfWeekEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the week of the month if used.'}
    weekOfMonth: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies how many days from the trigger event should the payment occur.'}
    offsetDays: Float[1];
    {nlq::NlqProfile.description = 'Specifies the business center for adjustment of calculation period.'}
    businessCenter: String[*];
}

// ─── Business Events & Lifecycle (64 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies instructions to create a fully formed contract, with optional legal agreements.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ContractFormationInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Instruction to a function that will be used to perform a business event',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Instruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A Primitive Instruction describes the inputs required to pass into the corresponding PrimitiveEvent function.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::PrimitiveInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A business event represents a life cycle event of a trade. The combination of the state changes results in a qualifiable life cycle event. An examp...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::BusinessEvent
{
    {nlq::NlqProfile.description = 'The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic which qualifies the life...'}
    eventQualifier: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A business event represents a life cycle event of a position. The combination of the state changes results in a qualifiable life cycle event.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CounterpartyPositionBusinessEvent
{
    {nlq::NlqProfile.description = 'The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from t...'}
    intent: event::PositionEventIntentEnum[1];
    {nlq::NlqProfile.description = 'The intent of a corporate action on the position.'}
    corporateActionIntent: event::CorporateActionTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the date on which the event is taking place. This date is equal to the trade date in the case of a simple e...'}
    eventDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date on which the event contractually takes effect, when different from the event date.'}
    effectiveDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies inputs needed to process an observation.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ObservationInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies inputs needed to process a valuation.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ValuationInstruction
{
    {nlq::NlqProfile.description = 'Specifies whether the previous valuation tracks in the valuation history are removed (True) or kept (False).'}
    replace: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies instructions for execution of a transaction, consisting of a product, price, quantity, parties, trade identifier, execution details, and ...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ExecutionInstruction
{
    {nlq::NlqProfile.description = 'Denotes the trade/execution date.'}
    tradeDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the information required to communicate the choices made by the exercising party, in a financial product endowing the party with at least...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ExerciseInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the information needed to create a Reset Business Event.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ResetInstruction
{
    {nlq::NlqProfile.description = 'payout'}
    payout: String[1..*];
    {nlq::NlqProfile.description = 'Specifies the \'Rate Record Day\' for a Fallback rate.  Fallback rate fixing processes typically set the fixing rate ...'}
    rateRecordDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Specifies the date on which the reset is occuring.'}
    resetDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the tradeState or payout on which to create a Transfer along with all necessary resets.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CalculateTransferInstruction
{
    {nlq::NlqProfile.description = 'date'}
    date: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the payout on which to create a Transfer along with all necessary resets.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::TransferInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Instructions required to create a Quantity Change Primitive Event, which can be either an increase, a decrease or a replacement. An increase adds a...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::QuantityChangeInstruction
{
    {nlq::NlqProfile.description = 'Direction of the quantity change specified as either an increase, decrease or replacement.'}
    direction: math::QuantityChangeDirectionEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the information needed to create a Index Transition Business Event.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::IndexTransitionInstruction
{
    {nlq::NlqProfile.description = 'Specifies the effective date of the index transition event. This is first date on which the floating rate calculation...'}
    effectiveDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies instructions for terms change consisting of the new transaction terms, and the renegotiation fee.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::TermsChangeInstruction
{
    {nlq::NlqProfile.description = 'adjustment'}
    adjustment: product::NotionalAdjustmentEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies instructions for a split, consisting of a breakdown of instructions to be applied to each branch of the split. This instruction can be us...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::SplitInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies instruction to change the party on a trade. This primitive instruction is used in a number of scenarios including: clearing, allocation a...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::PartyChangeInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the fundamental financial information that can be changed by a Primitive Event and by extension any business or life-cycle event. Each Trad...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::TradeState
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the fundamental financial information that can be changed by a Primitive Event and by extension any business or life-cycle event. Each Posi...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CounterpartyPositionState
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the necessary information to create any observation event.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ObservationEvent
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the reset value or fixing value produced in cashflow calculations, during the life-cycle of a financial instrument. The reset process defin...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Reset
{
    {nlq::NlqProfile.description = 'Specifies the date on which the reset occurred.'}
    resetDate: StrictDate[1];
    {nlq::NlqProfile.description = 'Specifies the \'Rate Record Day\' for a Fallback rate.  Fallback rate fixing processes typically set the fixing rate ...'}
    rateRecordDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the state of a trade at a point in the Trade\'s life cycle. Trades have many state dimensions, all of which are represented here. For examp...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::State
{
    {nlq::NlqProfile.description = 'Identifies the state of the position, to distinguish if just executed, formed, already settled, closed, etc.'}
    positionState: position::PositionStatusEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the fundamental financial information associated with a Transfer event. Each TransferState specifies where a Transfer is in its life-cycle....',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::TransferState
{
    {nlq::NlqProfile.description = 'Represents the State of the Transfer through its life-cycle.'}
    transferStatus: event::TransferStatusEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the movement of an Asset (eg cash, securities or commodities) between two parties on a date.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Transfer
{
    {nlq::NlqProfile.description = 'Represents the origin to the transfer as a reference for lineage purposes, whether it originated from trade level set...'}
    settlementOrigin: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a transfer expression (cash price, performance amount, scheduled payment amount, etc.) to define the nature of the transfer amount and it...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::TransferExpression
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'An ad-hoc transfer instigated by a party to the contract.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::UnscheduledTransfer
{
    {nlq::NlqProfile.description = 'Specifies the type of unscheduled transfer.'}
    transferType: settlement::UnscheduledTransferEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies a transfer amount exchanged as a price or fee for entering into a Business Event, e.g. Premium, Termination...'}
    priceTransfer: observable::FeeTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A scheduled transfer built into the contract.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ScheduledTransfer
{
    {nlq::NlqProfile.description = 'Specifies the type of scheduled transfer.'}
    transferType: settlement::ScheduledTransferEnum[1];
    {nlq::NlqProfile.description = 'corporateActionTransferType'}
    corporateActionTransferType: event::CorporateActionTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a trade identifier as a special case of the generic identifier type, that also includes the trade identifier class.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::TradeIdentifier
{
    {nlq::NlqProfile.description = 'The enumerated classification of the identifier. Optional as a trade identifier may be party-specific, in which case ...'}
    identifierType: identifier::TradeIdentifierTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a position identifier as a special case of the generic identifier type, that also includes the position identifier class.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::PositionIdentifier
{
    {nlq::NlqProfile.description = 'The enumerated classification of the identifier. Optional as a position identifier may be party-specific, in which ca...'}
    identifierType: identifier::TradeIdentifierTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the value of an investment, asset, or security',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Valuation
{
    {nlq::NlqProfile.description = 'Date and time of the last valuation marked to market, provided by the central counterparty (CCP) or calculated using ...'}
    timestamp: DateTime[1];
    {nlq::NlqProfile.description = 'Method used for the valuation of the transaction by the valuation party.'}
    method: event::ValuationTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Source of the valuation of the transaction by the valuation party.'}
    source: event::ValuationSourceEnum[0..1];
    {nlq::NlqProfile.description = 'Defines the scope of the valuation, what it applies to e.g. the collateral or the trade'}
    scope: event::ValuationScopeEnum[1];
    {nlq::NlqProfile.description = 'The ratio of the change in the price of a derivative transaction to the change in the price of the underlying. This f...'}
    delta: Float[0..1];
    {nlq::NlqProfile.description = 'Denotes when the valuation was sourced during a business day.'}
    valuationTiming: event::PriceTimingEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the output of a financial transaction between parties - a Business Event. A Trade impacts the financial position (i.e. the balance sheet) o...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Trade
{
    {nlq::NlqProfile.description = 'Specifies the date which the trade was agreed.'}
    tradeDate: StrictDate[1];
    {nlq::NlqProfile.description = 'Specifies the date on which a trade is cleared (novated) through a central counterparty clearing service.'}
    clearedDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines specific attributes that relate to trade executions.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ExecutionDetails
{
    {nlq::NlqProfile.description = 'Identifies the type of execution, e.g. via voice, electronically...'}
    executionType: event::ExecutionTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines specific attributes that relate to contractual details of trades.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ContractDetails
{
    {nlq::NlqProfile.description = 'Represents the law governing the trade and associated contractual product terms.'}
    governingLaw: legaldoc::GoverningLawEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to provide lineage information across lifecycle events through a pointer or set of pointers into the event(s), contract(s) and, possibly, p...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Lineage
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Data required to perform a stock split business event.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::StockSplitInstruction
{
    {nlq::NlqProfile.description = 'The number that denotes the cumulative quantity of post-split shares issued to shareholders versus the quantity of pr...'}
    adjustmentRatio: Float[1];
    {nlq::NlqProfile.description = 'The effective date of the stock split, also known as the ex-date. This is the date on which the additional shares are...'}
    effectiveDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the relevant data regarding a credit event.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CreditEvent
{
    {nlq::NlqProfile.description = 'The type of credit event taking place.'}
    creditEventType: event::CreditEventTypeEnum[1];
    {nlq::NlqProfile.description = 'The date in which the credit event is determined by the Credit Derivatives Determinations Comitee.'}
    eventDeterminationDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date on which the auction is scheduled to occur.'}
    auctionDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The percentage of the original value of the asset affected by the credit event that can be recovered.', nlq::NlqProfile.unit = 'percent'}
    recoveryPercent: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the relevant data regarding a corporate action',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CorporateAction
{
    {nlq::NlqProfile.description = 'The type of corporate action taking place.'}
    corporateActionType: event::CorporateActionTypeEnum[1];
    {nlq::NlqProfile.description = 'The date on which the corporate action is known to have taken place.'}
    exDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date on which resulting from the corporate action are delivered.'}
    payDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date on which the account phyical balance and related underlier ownership is recorded by the custodian.'}
    recordDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date on which the corporate action is announced by the issuer.'}
    announcementDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The underlier impacted by the corporate action.'}
    underlier: String[1];
    {nlq::NlqProfile.description = 'Corporate action triggered by the occurrence of an event which description is seperatly agreed between the parties an...'}
    bespokeEventDescription: String[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Describes the terms involved for adjusting the price of the underlier impacted by a Corporate Action.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::AdjustmentFactor
{
    {nlq::NlqProfile.description = 'The multipler value applied to the price of the underlier impacted by a Corporate Action.', nlq::NlqProfile.unit = 'currency'}
    value: Float[1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Describes the input terms involved in the calculation of the adjustment factor applied to the price of the underlier impacted by a Corporate Action.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::AdjustmentFactorCalculationTerms
{
    {nlq::NlqProfile.description = 'Multiple value, say \'M/N\' where \'M\' is the number of shares after the event and \'N\' is the number of shares pri...'}
    shareForShareRatio: Float[0..1];
    {nlq::NlqProfile.description = 'Multiple value, say \'M/N\' where \'M\' is the number of rights after the event, and \'N\' of shares prior to the event.'}
    shareForRightsRatio: Float[0..1];
    {nlq::NlqProfile.description = 'Multipler value (e.g. 85 %, etc.) to calculate net dividend amount, given gross amount before taking into account the...'}
    dividendRatio: Float[0..1];
    {nlq::NlqProfile.description = 'To describe the formula used to calculate the Adjustment Factor.'}
    bespokeCalculationFormula: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The accrual rate and related terms, to adjust the price of an underlier impacted by a Corporate Action when economic impact consists in freezing th...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::AccrualFactor
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Describes the input terms involved in the calculation of the accrual factor. Optionnally, long and short stub interpolation rates can be specified.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::AccrualFactorCalculationTerms
{
    {nlq::NlqProfile.description = 'The duration between last fixing date and the payment date of accruals, calculated in accordance with the appropriate...'}
    tenorTillMaturity: Float[1];
    {nlq::NlqProfile.description = 'The enumerated values to specify the day count fraction.'}
    dayCountFraction: other::DayCountFractionEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the underlier for both the Parent Company and the Child Compagny involved in Spin Off corporate action, as well as th respective price obse...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::SpinOff
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the underlier for both the Purchaser Company and the Acquired Compagny involved in Merger corporate action, as well as th respective price ...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Merger
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'All information required to perform the clear life cycle event; the clearing party (CCP), the two parties facing each other on the alpha contract, ...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ClearingInstruction
{
    {nlq::NlqProfile.description = 'Open Offer'}
    isOpenOffer: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the adjusted dates associated with a particular exercise event.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ExerciseEvent
{
    {nlq::NlqProfile.description = 'The date on which the option exercise takes place. This date should already be adjusted for any applicable business d...'}
    adjustedExerciseDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The effective date of the underlying swap associated with a given exercise date. This date should already be adjusted...'}
    adjustedRelevantSwapEffectiveDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable ...'}
    adjustedCashSettlementValuationDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable busines...'}
    adjustedCashSettlementPaymentDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business d...'}
    adjustedExerciseFeePaymentDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the information required to create the return of a Security Finance Transaction.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ReturnInstruction
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the information required for inclusion in a securities lending billing invoice.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::SecurityLendingInvoice
{
    {nlq::NlqProfile.description = 'The starting date of the period described by this invoice'}
    billingStartDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The ending date of the period described by this invoice'}
    billingEndDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the instructions for creation of a Security Lending billing invoice.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::BillingInstruction
{
    {nlq::NlqProfile.description = 'The starting date of the period described by this invoice'}
    billingStartDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The ending date of the period described by this invoice'}
    billingEndDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the instructions for creation of a billing record.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::BillingRecordInstruction
{
    {nlq::NlqProfile.description = 'The starting date of the period described by this record'}
    recordStartDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The ending date of the period described by this record'}
    recordEndDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date for settlement of the transfer.'}
    settlementDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the instructions for creation of a billing summary.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::BillingSummaryInstruction
{
    {nlq::NlqProfile.description = 'The account level for the billing summary.'}
    summaryAmountType: event::RecordAmountTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies individual records within a billing invoice.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::BillingRecord
{
    {nlq::NlqProfile.description = 'The starting date of the period described by this record'}
    recordStartDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The ending date of the period described by this record'}
    recordEndDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies individual summaries within a billing invoice.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::BillingSummary
{
    {nlq::NlqProfile.description = 'The account level for the billing summary.'}
    summaryAmountType: event::RecordAmountTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The attributes that are specific for consensus based pricing reporting.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::TradePricingReport
{
    {nlq::NlqProfile.description = 'It specifies the interest payable on collateral delivered under a CSA covering the trade.'}
    discountingIndex: other::FloatingRateIndexEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents common attributes required for Issuance and Response to a Margin Call action as a result of a demand for delivery or return of collatera...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::MarginCallBase
{
    {nlq::NlqProfile.description = 'Identifies margin type and if related regulatory mandate'}
    regMarginType: event::RegMarginTypeEnum[1];
    {nlq::NlqProfile.description = 'Indicates the role of the party in an regulatory initial margin call instruction (i.e Pledgor party or Secured party).'}
    regIMRole: event::RegIMRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the current mark to market value or IM calculation value of the trade portfolio as recorded by the principle (in base currency).',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::Exposure
{
    {nlq::NlqProfile.description = 'Indicates the date when the exposure is calculated if different from valuation date.'}
    calculationDateTime: DateTime[0..1];
    {nlq::NlqProfile.description = 'Indicates the valuation date of the exposure underlying the calculation.'}
    valuationDateTime: DateTime[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents attributes required for mark to market value or IM calculation value of the trade portfolio as recorded by the principle (in base curren...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::MarginCallExposure
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents common attributes to define a collateral balance recorded by the principal as held or posted.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CollateralBalance
{
    {nlq::NlqProfile.description = 'Defines the collateral balance breakdown of settlement status.'}
    collateralBalanceStatus: event::CollateralStatusEnum[0..1];
    {nlq::NlqProfile.description = 'Indicates if the collateral balance amount is based on pre or post haircut, if a haircut is associated with the colla...'}
    haircutIndicator: event::HaircutIndicatorEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents common attributes to define the details of collateral assets, to be used in margin call messaging and contribute to collateral balances ...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CollateralPortfolio
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the individual components of collateral positions.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::CollateralPosition
{
    {nlq::NlqProfile.description = 'Indicates the collateral positions settlement status.'}
    collateralPositionStatus: event::CollateralStatusEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents common attributes required for a Margin Call Issuance under a legal agreement such as a credit support document or equivalent.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::MarginCallIssuance
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents enumeration values to specify the call notification type, direction, specific action type.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::MarginCallInstructionType
{
    {nlq::NlqProfile.description = 'Indicates the status of the call message type, such as expected call, notification of a call or an actionable margin ...'}
    callType: event::CallTypeEnum[1];
    {nlq::NlqProfile.description = 'Indicates the choice if the call instruction is visible or not to the other party.'}
    visibilityIndicator: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the margin call action details, including collateral to be moved and its direction.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::MarginCallResponseAction
{
    {nlq::NlqProfile.description = 'Specifies the margin call action details, specified as either Delivery or Return.'}
    marginCallAction: event::MarginCallActionEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents common attributes required for a Margin Call Response under a legal agreement such as a credit support document or equivalent.',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::MarginCallResponse
{
    {nlq::NlqProfile.description = 'Indicates the response type, such as, is the margin call response a \'full\' \'part\' agreement or \'dispute\'.'}
    marginResponseType: event::MarginCallResponseTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to qualify the closed state of an execution or a contract through the combination or a state (e.g. terminated, novated) and a set of dates:...',
   nlq::NlqProfile.businessDomain = 'Business Events & Lifecycle',
   nlq::NlqProfile.whenToUse = 'Use for trade lifecycle events like execution, amendment, termination, novation, and exercise'}
event::ClosedState
{
    {nlq::NlqProfile.description = 'The qualification of what gave way to the contract or execution closure, e.g. allocation, termination, ...'}
    state: event::ClosedStateEnum[1];
    {nlq::NlqProfile.description = 'The activity date on which the closing state took place, i.e. either the event date of the closing event (e.g. option...'}
    activityDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date on which the closing event contractually takes effect, when different from the activity date. When an explic...'}
    effectiveDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date associated with the last payment in relation to the artefact (e.g. contract) to which this closed state appl...'}
    lastPaymentDate: StrictDate[0..1];
}

// ─── Identifiers (4 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the identifier value and its associated version.',
   nlq::NlqProfile.businessDomain = 'Identifiers',
   nlq::NlqProfile.whenToUse = 'Use for trade identifiers, product identifiers, and identifier schemes'}
identifier::AssignedIdentifier
{
    {nlq::NlqProfile.description = 'The identifier value.'}
    identifier: String[1];
    {nlq::NlqProfile.description = 'The identifier version, which is specified as an integer and is meant to be incremented each time the transaction ter...'}
    version: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a generic identifier, applicable to CDM artefacts such as executions, contracts, lifecycle events and legal documents. An issuer...',
   nlq::NlqProfile.businessDomain = 'Identifiers',
   nlq::NlqProfile.whenToUse = 'Use for trade identifiers, product identifiers, and identifier schemes'}
identifier::Identifier
{
    {nlq::NlqProfile.description = 'The identifier issuer, when specified explicitly alongside the identifier value (instead of being specified by refere...'}
    issuer: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Attaches an identifier to a collection of objects, when those objects themselves can each be represented by an identifier. One use case is the repr...',
   nlq::NlqProfile.businessDomain = 'Identifiers',
   nlq::NlqProfile.whenToUse = 'Use for trade identifiers, product identifiers, and identifier schemes'}
identifier::IdentifiedList
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a location identifier. An issuer and an identifier type can be associated with the actual identifier value as a way to properly qualify it.',
   nlq::NlqProfile.businessDomain = 'Identifiers',
   nlq::NlqProfile.whenToUse = 'Use for trade identifiers, product identifiers, and identifier schemes'}
identifier::LocationIdentifier
{
    {nlq::NlqProfile.description = 'Specifies the nature of a location identifier.'}
    locationIdentifierType: identifier::CommodityLocationIdentifierTypeEnum[0..1];
}

// ─── Legal Documentation (63 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'ContractualMatrix',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::ContractualMatrix
{
    {nlq::NlqProfile.description = 'Identifies the form of applicable matrix.'}
    matrixType: legaldoc::MatrixTypeEnum[1];
    {nlq::NlqProfile.description = 'Defines any applicable key into the relevant matrix. For example, the Transaction Type would be the single term requi...'}
    matrixTerm: legaldoc::MatrixTermEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A contractual supplement (such as those published by ISDA) and its publication date that will apply to the trade.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::ContractualTermsSupplement
{
    {nlq::NlqProfile.description = 'Identifies the form of applicable contractual supplement.'}
    contractualTermsSupplementType: legaldoc::ContractualSupplementTypeEnum[1];
    {nlq::NlqProfile.description = 'Specifies the publication date of the applicable version of the contractual supplement.'}
    publicationDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining an agreement executed between parties.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::OtherAgreement
{
    {nlq::NlqProfile.description = 'An identifier that has been created to identify the agreement.'}
    identifier: String[0..1];
    {nlq::NlqProfile.description = 'The agreement executed between the parties and intended to govern product-specific derivatives transactions between t...'}
    otherAgreementType: String[1];
    {nlq::NlqProfile.description = 'The version of the agreement.'}
    version: String[0..1];
    {nlq::NlqProfile.description = 'The date on which the agreement was signed.'}
    date: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Describes the resource that contains the media representation of a business event (i.e used for stating the Publicly Available Information). For ex...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::Resource
{
    {nlq::NlqProfile.description = 'The unique identifier of the resource within the event. FpML specifies this element of type resourceIdScheme but with...'}
    resourceId: String[1];
    {nlq::NlqProfile.description = 'A description of the type of the resource, e.g. a confirmation.'}
    resourceType: legaldoc::ResourceTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Indicates the language of the resource, described using the ISO 639-2/T Code.'}
    language: String[0..1];
    {nlq::NlqProfile.description = 'Indicates the size of the resource in bytes. It could be used by the end user to estimate the download time and stora...'}
    sizeInBytes: Float[0..1];
    {nlq::NlqProfile.description = 'Indicates the type of media used to store the content. mimeType is used to determine the software product(s) that can...'}
    mimeType: String[0..1];
    {nlq::NlqProfile.description = 'The name of the resource.  It is specified as a NormalizedString in FpML.'}
    name: String[0..1];
    {nlq::NlqProfile.description = 'Any additional comments that are deemed necessary. For example, which software version is required to open the docume...'}
    comments: String[0..1];
    {nlq::NlqProfile.description = 'Provides extra information as string. In case the extra information is in XML format, a CDATA section must be placed ...'}
    string: String[0..1];
    {nlq::NlqProfile.description = 'Indicates where the resource can be found, as a URL that references the information on a web server accessible to the...'}
    url: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to indicate the length of the resource.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::ResourceLength
{
    {nlq::NlqProfile.description = 'The length unit of the resource. For example, pages (pdf, text documents) or time (audio, video files).'}
    lengthUnit: legaldoc::LengthUnitEnum[1];
    {nlq::NlqProfile.description = 'The length value of the resource.', nlq::NlqProfile.unit = 'currency'}
    lengthValue: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the content of a legal agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::AgreementTerms
{
    {nlq::NlqProfile.description = 'Specification of whether the agreement terms have been negotiated using the clause library methodology.'}
    clauseLibrary: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The specification of a legal agreement between two parties, being negotiated or having been executed. This includes the baseline information and th...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::LegalAgreement
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the legal agreement baseline information, being negotiated or having been executed. It excludes specialized elections',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::LegalAgreementBase
{
    {nlq::NlqProfile.description = 'The date on which the legal agreement has been agreed between the parties. This corresponds to the Date of Deed in an...'}
    agreementDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date on which, or as of which, the agreement is effective, if different from the agreement date. It is expected t...'}
    effectiveDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the type of legal agreement, identified via a set of composable attributes: agreementName, publisher, governing law and version, e.g. ISD...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::LegalAgreementIdentification
{
    {nlq::NlqProfile.description = 'The law governing the legal agreement, e.g. English Law, New York Law or Japanese Law.'}
    governingLaw: legaldoc::GoverningLawEnum[0..1];
    {nlq::NlqProfile.description = 'The legal agreement publisher, e.g. ISDA.'}
    publisher: legaldoc::LegalAgreementPublisherEnum[0..1];
    {nlq::NlqProfile.description = 'In the case where successive definitions of the legal agreement have been developed, the vintage identification. This...'}
    vintage: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the agreement name through an agreement type and optional detailed sub agreement type.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::AgreementName
{
    {nlq::NlqProfile.description = 'Specification of the legal agreement type.'}
    agreementType: legaldoc::LegalAgreementTypeEnum[1];
    {nlq::NlqProfile.description = 'Specification of the credit support agreement type.'}
    creditSupportAgreementType: collateral::CreditSupportAgreementTypeEnum[0..1];
    {nlq::NlqProfile.description = 'specifies the type of margin for which a legal agreement is named.'}
    creditSupportAgreementMarginType: collateral::CollateralMarginTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The definitions such as those published by ISDA that will define the terms of the trade.'}
    contractualDefinitionsType: legaldoc::ContractualDefinitionsEnum[*];
    {nlq::NlqProfile.description = 'Specification of the master agreement type.'}
    masterAgreementType: legaldoc::MasterAgreementTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The type of master confirmation executed between the parties.'}
    masterConfirmationType: legaldoc::MasterConfirmationTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The type of master confirmation annex executed between the parties.'}
    masterConfirmationAnnexType: legaldoc::MasterConfirmationAnnexTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Definition of an agreement that is not enumerated in the CDM.'}
    otherAgreement: String[0..1];
    {nlq::NlqProfile.description = 'brokerConfirmationType'}
    brokerConfirmationType: legaldoc::BrokerConfirmationTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the set of agreements, the parties of which are set within UmbrellaAgreementSet, beyond the two contracting parties to that agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::UmbrellaAgreement
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the entities that are part of the umbrella agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::UmbrellaAgreementParty
{
    {nlq::NlqProfile.description = 'Specifies the CounterpartyRoleEnum, e.g. either Party1 or Party2, that is associated to the party.'}
    actingAs: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Represents the legal role that each defined entity to the agreement performs within the structure of that agreement.'}
    partyRole: legaldoc::UmbrellaPartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a non-legal entity that exists in the agreement with a defined relationship to a Legal entity to the agreement',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::NonLegalEntity
{
    {nlq::NlqProfile.description = 'Specifies the unique identifier value for a non-legal entity such as a sleeve, or sub account, that is a party to the...'}
    identifier: String[1];
    {nlq::NlqProfile.description = 'Specifies the Identifier type for a non-Legal entity to the agreement, for example the use of an alert code to unique...'}
    identifierType: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the groups of agreement term elections that exist within the agreement and to which entities that particular group of elections apply. W...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::UmbrellaAgreementSet
{
    {nlq::NlqProfile.description = 'Represents any additional language that may need to be captured regarding the structure or application of terms that ...'}
    additionalLanguage: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the party reference and the associated contact information.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::ContactInformationElection
{
    {nlq::NlqProfile.description = 'The party to which the election and details apply.'}
    partyReference: party::CounterpartyRoleEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the party reference and the associated notice and contact information.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::NoticeInformationElection
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies notice information including address and, optionally, an associated person. This type also supports the ISDA CSA representation as a sing...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::NoticeContactInformation
{
    {nlq::NlqProfile.description = 'Additional information on the recipient.'}
    additionalInformation: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies transfer information including address and, optionally, an associated account. This type also supports the ISDA CSA representation as a s...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::TransferContactInformation
{
    {nlq::NlqProfile.description = 'Additional transfer information.'}
    additionalInformation: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a related legal agreement. For example, ISDA 2016 Credit Support Annex for Initial Margin, paragraph 13, General Principles, (s)...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::OtherAgreementTerms
{
    {nlq::NlqProfile.description = 'The qualification of whether some other related agreement is specified (True) or not (False).'}
    isSpecified: Boolean[1];
    {nlq::NlqProfile.description = 'The specification of this other agreement, when the qualification is True.'}
    legalDocument: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of the standard set of terms that define a legal agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::Agreement
{
    {nlq::NlqProfile.description = 'Elections to specify a Credit Support Annex or Credit Support Deed for Intial or Variation Margin.'}
    creditSupportAgreementElections: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The set of elections that define an ISDA Master Agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::MasterAgreement
{
    {nlq::NlqProfile.description = 'Specification of whether the Governing Law clause extends to Non-Contractual Obligations (True) or does not extend to...'}
    nonContractualObligations: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Automatic Early Termination provision applicable to a Master Agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::AutomaticEarlyTermination
{
    {nlq::NlqProfile.description = 'Specifies whether automatic termination applies in the event of certain bankruptcy events.'}
    fallbackAET: Boolean[1];
    {nlq::NlqProfile.description = 'Specifies whether indemnity applies in the event AET is applicable to one or both of the parties.'}
    indemnity: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the party elections specific to the Automatic Early Termination Clause.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::AutomaticEarlyTerminationElection
{
    {nlq::NlqProfile.description = 'A boolean election to specify whether the Automatic Early Termination provisions of Section 6(a) are applicable (True...'}
    isApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies how the Termination Currency for the agreement will be determined.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::TerminationCurrency
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies Termination Currency where a currency is stated at the time the agreement is entered into.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::TerminationCurrencySelection
{
    {nlq::NlqProfile.description = 'Specifies a single Termination Currency for the agreement.'}
    statedCurrency: String[0..1];
    {nlq::NlqProfile.description = 'Specifies a single fallback Termination Currency should the stated currency not be freely available.'}
    fallbackCurrency: String[0..1];
    {nlq::NlqProfile.description = 'Specifies fallback Termination Currency where both parties are Affected Parties.'}
    bothAffected: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies mechanism for Termination currency to be selected by the Non-defaulting Party/party which is not the Affected Party.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::PartyOptionTerminationCurrency
{
    {nlq::NlqProfile.description = 'Specifies termination currency where there are two Affected Parties and they cannot agree on the termination currency.'}
    bothAffectedTermCurrencyOption: String[0..1];
    {nlq::NlqProfile.description = 'Specifies alternative conditions for selection of the termination currency.'}
    terminationCurrencySpecifiedCondition: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the enumerated conditions for selection of the termination currency.'}
    terminationCurrencyCondition: legaldoc::TerminationCurrencyConditionEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the termination currency to be used by a party when it is the Non-Defaulting Party or the Party which is not the Affected Party.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::PartyTerminationCurrencySelection
{
    {nlq::NlqProfile.description = 'Specifies termination Currency.'}
    statedPartyCurrency: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A provision that allows each party to specify its Specified Entities for certain Events of Default and Termination Events.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::SpecifiedEntities
{
    {nlq::NlqProfile.description = 'The Event of Default or Termination event for which Specified Entities terms are being defined.'}
    specifiedEntityClause: legaldoc::SpecifiedEntityClauseEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The party specific election of Specified Entities for the Event of Default or Termination Event specified.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::SpecifiedEntity
{
    {nlq::NlqProfile.description = 'The specified entity terms for the Event of Default or Termination Event specified.'}
    specifiedEntityTerms: legaldoc::SpecifiedEntityTermsEnum[1];
    {nlq::NlqProfile.description = 'The meaning of Material Subsidiary for the Event of Default or Termination Event specified.'}
    materialSubsidiaryTerms: String[0..1];
    {nlq::NlqProfile.description = 'The non standard terms for the Event of Default or Termination Event specified.'}
    otherSpecifiedEntityTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The set of elections which specify a Master Agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::MasterAgreementSchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines clauses that make up a Master Agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::MasterAgreementClause
{
    {nlq::NlqProfile.description = 'Unique identifier for the clause.'}
    identifer: legaldoc::MasterAgreementClauseIdentifierEnum[1];
    {nlq::NlqProfile.description = 'Optional textual description of the clause.'}
    name: String[0..1];
    {nlq::NlqProfile.description = 'Optional counterparty role. This can be used where a clause needs to be assigned to a specific party on the agreement...'}
    counterparty: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Optional party. This can be required for umbrella agreements where a clause may need to be assigned to a specific par...'}
    otherParty: party::PartyRoleEnum[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Sets the details for a specific variant associated to a clause in a Master Agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::MasterAgreementClauseVariant
{
    {nlq::NlqProfile.description = 'Unique identifier for this variant.'}
    identifier: legaldoc::MasterAgreementVariantIdentifierEnum[1];
    {nlq::NlqProfile.description = 'Optional textual description of the variant.'}
    name: String[0..1];
    {nlq::NlqProfile.description = 'Optional counterparty role. This can be used where a clause needs to assign a different variant to the different part...'}
    counterparty: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Optional party. This can be used where a clause needs to assign different variants to different parties who may or ma...'}
    otherParty: party::PartyRoleEnum[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a type where additional variables associated to clauses and their variants can be described.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::MasterAgreementVariableSet
{
    {nlq::NlqProfile.description = 'The name of the variable.'}
    name: String[0..1];
    {nlq::NlqProfile.description = 'The value for this variable.'}
    value: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'TransactionAdditionalTerms which apply to the CurrencyPair asset class.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::FxAdditionalTerms
{
    {nlq::NlqProfile.description = 'noFaultTermination'}
    noFaultTermination: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Representations',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::Representations
{
    {nlq::NlqProfile.description = 'If true, then non reliance is applicable.'}
    nonReliance: Boolean[1];
    {nlq::NlqProfile.description = 'If true, then agreements regarding hedging are applicable.'}
    agreementsRegardingHedging: Boolean[1];
    {nlq::NlqProfile.description = 'If present and true, then index disclaimer is applicable.'}
    indexDisclaimer: Boolean[0..1];
    {nlq::NlqProfile.description = 'If true, then additional acknowledgements are applicable.'}
    additionalAcknowledgements: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the specification of the consequences of Index Events',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::IndexAdjustmentEvents
{
    {nlq::NlqProfile.description = 'Consequence of index modification.'}
    indexModification: observable::IndexEventConsequenceEnum[1];
    {nlq::NlqProfile.description = 'Consequence of index cancellation.'}
    indexCancellation: observable::IndexEventConsequenceEnum[1];
    {nlq::NlqProfile.description = 'Consequence of index disruption.'}
    indexDisruption: observable::IndexEventConsequenceEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the roles and related terms which document the agreement of parties about any determination requirements ; mostly about Extraordinary Event...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::DeterminationRolesAndTerms
{
    {nlq::NlqProfile.description = 'Defines the enumerated values to specify the determination roles to the transaction. Such roles mostly address any de...'}
    determinationRole: legaldoc::DeterminationRoleEnum[1];
    {nlq::NlqProfile.description = 'Designates which Counterparty to the transaction is granted with the particular role ; cardinality of this object is ...'}
    whoToDetermine: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Where the party who is not granted with the determination role at least has a right to dispute the determination give...'}
    disputingParty: party::CounterpartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining the merger events and their treatment.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::EquityCorporateEvents
{
    {nlq::NlqProfile.description = 'Shall occur if a Merger Event occurs and the consideration for the relevant Security consists solely of Combined Cons...'}
    shareForShare: observable::ShareExtraordinaryEventEnum[1];
    {nlq::NlqProfile.description = 'Shall occur if a Merger Event occurs and the consideration for the relevant Security consists solely of Other Conside...'}
    shareForOther: observable::ShareExtraordinaryEventEnum[1];
    {nlq::NlqProfile.description = 'Shall occur if a Merger Event occurs and the consideration for the relevant Security consists solely of Combined Cons...'}
    shareForCombined: observable::ShareExtraordinaryEventEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Additional Provisions for a Confirmation of an FX or Currency Option Transaction',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::FxDisruptionEvents
{
    {nlq::NlqProfile.description = 'illegalityOrImpossibility'}
    illegalityOrImpossibility: legaldoc::FxIllegalityOrImpossibilityEnum[0..1];
    {nlq::NlqProfile.description = 'forceMajeureOrActOfSState'}
    forceMajeureOrActOfSState: legaldoc::FxForceMajeureOrActOfSStateEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'GovernmentalAuthorityDefault',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::GovernmentalAuthorityDefault
{
    {nlq::NlqProfile.description = 'governmentalAuthorityDefaultIsApplicable'}
    governmentalAuthorityDefaultIsApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'localSubstituteProvisionType'}
    localSubstituteProvisionType: legaldoc::FxSubstitutionProvisionTypeEnum[0..1];
    {nlq::NlqProfile.description = 'specifiedValue'}
    specifiedValue: legaldoc::SpecifiedValueEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Illiquidity',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::Illiquidity
{
    {nlq::NlqProfile.description = 'illiquidityIsApplicable'}
    illiquidityIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'MaterialChangeInCircumstance',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::MaterialChangeInCircumstance
{
    {nlq::NlqProfile.description = 'materialChangeInCircumstanceIsApplicable'}
    materialChangeInCircumstanceIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Nationalization',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::Nationalization
{
    {nlq::NlqProfile.description = 'nationalizationIsApplicable'}
    nationalizationIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'PriceMateriality',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::PriceMateriality
{
    {nlq::NlqProfile.description = 'priceMaterialityIsApplicable'}
    priceMaterialityIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FxPriceSourceDisruption',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::FxPriceSourceDisruption
{
    {nlq::NlqProfile.description = 'priceSourceDisruptionIsApplicable'}
    priceSourceDisruptionIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FxBenchmarkObligationDefault',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::FxBenchmarkObligationDefault
{
    {nlq::NlqProfile.description = 'benchmarkObligationDefaultIsApplicable'}
    benchmarkObligationDefaultIsApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'specifiedValue'}
    specifiedValue: legaldoc::SpecifiedValueEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FxDualExchangeRate',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::FxDualExchangeRate
{
    {nlq::NlqProfile.description = 'dualExchangeRateIsApplicable'}
    dualExchangeRateIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FxInconvertibilityOrNonTransferability',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::FxInconvertibilityOrNonTransferability
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'GeneralInconvertibility',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::GeneralInconvertibility
{
    {nlq::NlqProfile.description = 'generalInconvertibilityIsApplicable'}
    generalInconvertibilityIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'GeneralNonTransferability',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::GeneralNonTransferability
{
    {nlq::NlqProfile.description = 'generalNonTransferabilityIsApplicable'}
    generalNonTransferabilityIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SpecificInconvertibility',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::SpecificInconvertibility
{
    {nlq::NlqProfile.description = 'specificInconvertibilityIsApplicable'}
    specificInconvertibilityIsApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'relevantClass'}
    relevantClass: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SpecificNonTransferability',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::SpecificNonTransferability
{
    {nlq::NlqProfile.description = 'specificNonTransferabilityIsApplicable'}
    specificNonTransferabilityIsApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'localSubstituteProvisionType'}
    localSubstituteProvisionType: legaldoc::FxSubstitutionProvisionTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Refers to the segregation deposit procedure parties may want to commmit into during the time a Disruption Event is effective',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::EscrowArrangement
{
    {nlq::NlqProfile.description = 'escrowArrangementIsApplicable'}
    escrowArrangementIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the currency referenced as such in any terms related to FX Disruption Events',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::EventCurrency
{
    {nlq::NlqProfile.description = 'Defines the currency referenced as such in any terms related to FX Disruption Events'}
    eventCurrency: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'NonDeliverableSubstitute',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::NonDeliverableSubstitute
{
    {nlq::NlqProfile.description = 'nonDeliverableSubstituteIsApplicable'}
    nonDeliverableSubstituteIsApplicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Additional specification for the extraordinary events that may affect a trade and the related contractual rights and obligation of the parties when...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::TransactionAdditionalTerms
{
    {nlq::NlqProfile.description = 'commoditiesAdditionalTerms'}
    commoditiesAdditionalTerms: String[0..1];
    {nlq::NlqProfile.description = 'interestRateAdditionalTerms'}
    interestRateAdditionalTerms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Transaction AdditionalTerms that apply to Equity asset class.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::EquityAdditionalTerms
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Where parties describe any substitution terms.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::UnderlierSubstitutionProvision
{
    {nlq::NlqProfile.description = 'Designates which Counterparty to the transaction who has the right to trigger a substitution or to provide related de...'}
    whoMaySubstitute: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Where the party who is not granted with the substitution role at least has a right to dispute the determination given...'}
    disputingParty: party::CounterpartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Where the underlying is shares, defines market events affecting the issuer of those shares that may require the terms of the transaction to be adju...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::ExtraordinaryEvents
{
    {nlq::NlqProfile.description = 'compositionOfCombinedConsideration'}
    compositionOfCombinedConsideration: Boolean[0..1];
    {nlq::NlqProfile.description = 'delisting'}
    delisting: legaldoc::NationalizationOrInsolvencyOrDelistingEventEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type for defining the Additional Disruption Events.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::AdditionalDisruptionEvents
{
    {nlq::NlqProfile.description = 'changeInLaw'}
    changeInLaw: Boolean[0..1];
    {nlq::NlqProfile.description = 'insolvencyFiling'}
    insolvencyFiling: Boolean[0..1];
    {nlq::NlqProfile.description = 'increasedCostOfHedging'}
    increasedCostOfHedging: Boolean[0..1];
    {nlq::NlqProfile.description = 'lossOfStockBorrow'}
    lossOfStockBorrow: Boolean[0..1];
    {nlq::NlqProfile.description = 'increasedCostOfStockBorrow'}
    increasedCostOfStockBorrow: Boolean[0..1];
    {nlq::NlqProfile.description = 'Specifies the party which determines additional disruption events.'}
    determiningParty: party::AncillaryRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type for documenting additional clause that cannot yet be represented with the model and yet needed for a digital representation of the agreement.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::Clause
{
    {nlq::NlqProfile.description = 'The  name or identifier associated to this clause.'}
    identifier: String[0..1];
    {nlq::NlqProfile.description = 'Content of this bespoke clause.'}
    terms: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identifies the market sector in which the trade has been arranged.',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::BrokerConfirmation
{
    {nlq::NlqProfile.description = 'The type of broker confirmation executed between the parties.'}
    brokerConfirmationType: legaldoc::BrokerConfirmationTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification for the General Terms and Relationship Supplement Elections as provided in the 2018 ISDA CDM Equity Confirmation for Security Equity ...',
   nlq::NlqProfile.businessDomain = 'Legal Documentation',
   nlq::NlqProfile.whenToUse = 'Use for master agreements, legal documentation, and contractual terms'}
legaldoc::EquitySwapMasterConfirmation2018
{
    {nlq::NlqProfile.description = 'Per Part 1 Section 4, \'Dividend Obligations\', of the 2018 ISDA CDM Equity Confirmation, Para 4.2 \'Dividend Returns\'.'}
    typeOfSwapElection: product::ReturnTypeEnum[1];
    {nlq::NlqProfile.description = 'Per Part 1 Section 3, \'Floating Obligations\', of the 2018 ISDA CDM Equity Confirmation. Para 3.3.'}
    linearInterpolationElection: observable::InterpolationMethodEnum[1];
}

// ─── Margin & Collateral Scheduling (3 types) ───

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'StandardizedSchedule',
   nlq::NlqProfile.businessDomain = 'Margin & Collateral Scheduling',
   nlq::NlqProfile.whenToUse = 'Use for margin schedules, initial margin, and variation margin calculations'}
margin::StandardizedSchedule
{
    {nlq::NlqProfile.description = 'assetClass'}
    assetClass: margin::StandardizedScheduleAssetClassEnum[1];
    {nlq::NlqProfile.description = 'notional', nlq::NlqProfile.unit = 'currency'}
    notional: Float[1];
    {nlq::NlqProfile.description = 'durationInYears'}
    durationInYears: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'StandardizedScheduleTradeInfo',
   nlq::NlqProfile.businessDomain = 'Margin & Collateral Scheduling',
   nlq::NlqProfile.whenToUse = 'Use for margin schedules, initial margin, and variation margin calculations'}
margin::StandardizedScheduleTradeInfo
{
    {nlq::NlqProfile.description = 'assetClass'}
    assetClass: margin::StandardizedScheduleAssetClassEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'StandardizedScheduleInitialMargin',
   nlq::NlqProfile.businessDomain = 'Margin & Collateral Scheduling',
   nlq::NlqProfile.whenToUse = 'Use for margin schedules, initial margin, and variation margin calculations'}
margin::StandardizedScheduleInitialMargin
{
}

// ─── Mathematics & Quantities (13 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the unit to be used for price, quantity, or other purposes',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::UnitType
{
    {nlq::NlqProfile.description = 'Provides an enumerated value for a capacity unit, generally used in the context of defining quantities for commodities.'}
    capacityUnit: math::CapacityUnitEnum[0..1];
    {nlq::NlqProfile.description = 'Provides an enumerated values for a weather unit, generally used in the context of defining quantities for commodities.'}
    weatherUnit: math::WeatherUnitEnum[0..1];
    {nlq::NlqProfile.description = 'Provides an enumerated value for financial units, generally used in the context of defining quantities for securities.'}
    financialUnit: math::FinancialUnitEnum[0..1];
    {nlq::NlqProfile.description = 'Defines the currency to be used as a unit for a price, quantity, or other purpose.'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Provides an abstract type to define a measure as a number associated to a unit. This type is abstract because all its attributes are optional. The ...',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::MeasureBase
{
    {nlq::NlqProfile.description = 'Specifies the value of the measure as a number. Optional because in a measure vector or schedule, this single value m...', nlq::NlqProfile.unit = 'currency'}
    value: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A set of measures, all in the same unit, where the values are defined through a schedule of steps. The initial value may be defined either as part ...',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::MeasureSchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a quantity schedule to be associated to a financial product to represent a trade amount. This data type extends MeasureSchedule with seve...',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::QuantitySchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a step date and non-negative step value pair. This step definitions are used to define varying rate or amount schedules, e.g. a no...',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::NonNegativeStep
{
    {nlq::NlqProfile.description = 'The date on which the associated stepValue becomes effective. This day may be subject to adjustment in accordance wit...'}
    stepDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The non-negative rate or amount which becomes effective on the associated stepDate. A rate of 5% would be represented...', nlq::NlqProfile.unit = 'currency'}
    stepValue: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines rounding rules and precision to be used in the rounding of a number.',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::Rounding
{
    {nlq::NlqProfile.description = 'Specifies the rounding rounding rule as up, down, or nearest.'}
    roundingDirection: math::RoundingDirectionEnum[1];
    {nlq::NlqProfile.description = 'Specifies the rounding precision in terms of a number of decimal places when the number is evaluated in decimal form ...'}
    precision: Integer[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class defining a schedule of rates or amounts in terms of an initial value and then a series of step date and value pairs. On each step date the ...',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::Schedule
{
    {nlq::NlqProfile.description = 'The initial rate or amount, as the case may be. An initial rate of 5% would be represented as 0.05.', nlq::NlqProfile.unit = 'currency'}
    value: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a date and value pair. This definition is used for varying rate or amount schedules, e.g. a notional amortisation or a step-up coupon sched...',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::DatedValue
{
    {nlq::NlqProfile.description = 'The date on which the associated step value becomes effective. This day may be subject to adjustment in accordance wi...'}
    date: StrictDate[1];
    {nlq::NlqProfile.description = 'The rate of amount which becomes effective on the associated step date. A rate of 5% would be represented as 0.05.', nlq::NlqProfile.unit = 'currency'}
    value: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The number range defined as either a lower and upper number bound, or both.',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::NumberRange
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The number bound is defined as a number and whether the bound is inclusive.',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::NumberBound
{
    {nlq::NlqProfile.description = 'The number to be used as the bound, e.g. 5.'}
    number: Float[1];
    {nlq::NlqProfile.description = 'Whether the number bound is inclusive, e.g. for a lower bound, false would indicate greater than, whereas true would ...'}
    inclusive: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The money range defined as either a lower and upper money bound, or both.',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::MoneyRange
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The money bound is defined as a money amount and whether the bound is inclusive.',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::MoneyBound
{
    {nlq::NlqProfile.description = 'Whether the money amount bound is inclusive, e.g. for a lower bound, false would indicate greater than, whereas true ...'}
    inclusive: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the ways in which multiple values can be aggregated into a single value.',
   nlq::NlqProfile.businessDomain = 'Mathematics & Quantities',
   nlq::NlqProfile.whenToUse = 'Use for quantities, measures, rounding rules, and mathematical concepts'}
math::AveragingCalculationMethod
{
    {nlq::NlqProfile.description = 'Identifies whether the average values will be weighted or unweighted.'}
    isWeighted: Boolean[1];
    {nlq::NlqProfile.description = 'Identifies which of the Pythagorean means is being used to compute an average value.'}
    calculationMethod: math::AveragingCalculationMethodEnum[1];
}

// ─── Market Observables & Indices (80 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the structures needed to represent the calculation parameters for daily averaged and compounded modular rates as defined in the 2021 ISDA D...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateCalculationParameters
{
    {nlq::NlqProfile.description = 'calculation type (averaging or compounding).'}
    calculationMethod: observable::CalculationMethodEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the structure needed to represent fallback rate parameters. This type is used to represent modular computed rates in interestRatePayouts.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FallbackRateParameters
{
    {nlq::NlqProfile.description = 'The floating rate index that is used as the basis of the fallback rate.'}
    floatingRateIndex: other::FloatingRateIndexEnum[1];
    {nlq::NlqProfile.description = 'The date the fallback rate takes effect.'}
    effectiveDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The economic spread applied to the underlying fallback rate to replicate the original risky rate.', nlq::NlqProfile.unit = 'percent'}
    spreadAdjustment: Float[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Defines business day shifts for daily componded or averaged rates.  This type is used for lookback and lockout rates. This type is used to represen...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::OffsetCalculation
{
    {nlq::NlqProfile.description = 'The number of business days offset.'}
    offsetDays: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Parameters to describe the observation shift for a daily compounded or averaged floating rate. This type is used to represent modular computed rate...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ObservationShiftCalculation
{
    {nlq::NlqProfile.description = 'The number of days of observation shift.'}
    offsetDays: Integer[0..1];
    {nlq::NlqProfile.description = 'Whether the rate is calculated in advance, in arrears, or relative to a reset date.'}
    calculationBase: observable::ObservationPeriodDatesEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Parameters on daily observed computed rates, specifically daily caps and floors. This type is used to represent modular computed rates in interestR...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ObservationParameters
{
    {nlq::NlqProfile.description = 'A daily observation cap rate.', nlq::NlqProfile.unit = 'percent'}
    observationCapRate: Float[0..1];
    {nlq::NlqProfile.description = 'A daily observation floor rate.', nlq::NlqProfile.unit = 'percent'}
    observationFloorRate: Float[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Type for reporting details of calculated rates, including the observations that went into the final reported rate.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CalculatedRateDetails
{
    {nlq::NlqProfile.description = 'The weighted value of each observation.', nlq::NlqProfile.unit = 'percent'}
    weightedRates: Float[*];
    {nlq::NlqProfile.description = 'The daily growth factors, showing the weighted rates divided by the day count basis plus one, giving how much the val...'}
    growthFactor: Float[*];
    {nlq::NlqProfile.description = 'The compounding curve, showing how the initial value grew during the calculation period.'}
    compoundedGrowth: Float[*];
    {nlq::NlqProfile.description = 'The total sum or product of all the individual terms that went into the calculated rate.', nlq::NlqProfile.unit = 'currency'}
    aggregateValue: Float[0..1];
    {nlq::NlqProfile.description = 'The total weight of all the terms that went into the calculated rate.', nlq::NlqProfile.unit = 'units'}
    aggregateWeight: Float[0..1];
    {nlq::NlqProfile.description = 'The resulting calculated weight.', nlq::NlqProfile.unit = 'percent'}
    calculatedRate: Float[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Type for reporting observations that went into the final reported rate.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CalculatedRateObservations
{
    {nlq::NlqProfile.description = 'The observation date upon which the rate is observed.'}
    observationDates: StrictDate[*];
    {nlq::NlqProfile.description = 'The corresponding weight for each date.', nlq::NlqProfile.unit = 'units'}
    weights: Float[*];
    {nlq::NlqProfile.description = 'The value observed for that date', nlq::NlqProfile.unit = 'percent'}
    observedRates: Float[*];
    {nlq::NlqProfile.description = 'The value after any processing, such as application of caps or floors.', nlq::NlqProfile.unit = 'percent'}
    processedRates: Float[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Type for reporting the observations dates and the corresponding weights going into a daily calculated rate',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CalculatedRateObservationDatesAndWeights
{
    {nlq::NlqProfile.description = 'The observation date upon which the rate is observed.'}
    observationDates: StrictDate[*];
    {nlq::NlqProfile.description = 'The corresponding weight for each date.', nlq::NlqProfile.unit = 'units'}
    weights: Float[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FloatingRateIndexDefinition',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexDefinition
{
    {nlq::NlqProfile.description = 'The source of an FRO, particularly if not a Contractual Definition (e.g. the broker rates matrix).'}
    definitionalSource: String[0..1];
    {nlq::NlqProfile.description = 'designatedMaturityApplicable'}
    designatedMaturityApplicable: Boolean[0..1];
    {nlq::NlqProfile.description = 'YES / NO to flag FROs identified by the FpML Syndicated Loan WG as having underlying benchmark that may also be refer...'}
    inLoan: Boolean[0..1];
    {nlq::NlqProfile.description = 'Deprecation and Code Descriptions'}
    deprecationReason: String[0..1];
    {nlq::NlqProfile.description = 'FpML Description'}
    fpmlDescription: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FloatingRateIndexIdentification',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexIdentification
{
    {nlq::NlqProfile.description = 'The reference index that is used to specify the floating interest rate. The FpML standard maintains the list of such ...'}
    floatingRateIndex: other::FloatingRateIndexEnum[0..1];
    {nlq::NlqProfile.description = 'FRO currency - 3 character ISO currrency code'}
    currency: asset::ISOCurrencyCodeEnum[0..1];
    {nlq::NlqProfile.description = 'FRO type (e.g. OIS)'}
    froType: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This holds the rate calculation defaults applicable for a floating rate index.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexCalculationDefaults
{
    {nlq::NlqProfile.description = 'The ISDA FRO category (e.g. screen rate or calculated rate).'}
    category: observable::FloatingRateIndexCategoryEnum[0..1];
    {nlq::NlqProfile.description = 'The ISDA FRO style (e.g. term rate, swap rate, etc).'}
    indexStyle: observable::FloatingRateIndexStyleEnum[0..1];
    {nlq::NlqProfile.description = 'The ISDA FRO calculation method (e.g. OIS Compounding).'}
    method: observable::FloatingRateIndexCalculationMethodEnum[0..1];
    {nlq::NlqProfile.description = 'The default day count fraction.'}
    dayCountFraction: other::DayCountFractionEnum[0..1];
    {nlq::NlqProfile.description = 'Publication Calendar (e.g. EUR-ICESWAP)'}
    publicationCalendar: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'ContractualDefinition',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ContractualDefinition
{
    {nlq::NlqProfile.description = '2021-06-11'}
    publicationDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'ContractualDefinitionIdentifier',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ContractualDefinitionIdentifier
{
    {nlq::NlqProfile.description = 'e.g. ISDA2021Definitions'}
    contractualDefinitionType: legaldoc::ContractualDefinitionsEnum[1];
    {nlq::NlqProfile.description = 'e.g. V1'}
    contractualDefinitionVersion: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A map for a single FRO to or from an equivalent or similar FRO in a different contractual definitions version.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexMap
{
    {nlq::NlqProfile.description = 'The FRO name that is being mapped to/from.'}
    index: other::FloatingRateIndexEnum[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This type defines mappings between FROs in different definitional versions.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexMappings
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A map for a single FRO to or from an equivalent or similar codes in a different standard such as ISO.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexExternalMap
{
    {nlq::NlqProfile.description = 'The FRO name that is being mapped to/from.'}
    externalId: String[1];
    {nlq::NlqProfile.description = 'The standard/version to which the map applies.'}
    externalStandard: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the mappings of FRO codes to other.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexExternalMappings
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FRO History',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FroHistory
{
    {nlq::NlqProfile.description = 'The date the Floating Rate Option was added to the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. 2017/04/06)'}
    startDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date the Floating Rate Option was last updated in the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. 2021/0...'}
    updateDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date the Floating Rate Option was removed from the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. 2014/01/01)'}
    endDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This type holds parameters defining the fixingt time and offset for a floating rate index.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexFixingDetails
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This type holds parameters defining the normal fixing time for a floating rate index.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexFixingTime
{
    {nlq::NlqProfile.description = 'Allows a designed maturity to be specified for the fixing time.'}
    designatedMaturity: String[0..1];
    {nlq::NlqProfile.description = 'Legal text that underlies the Fixing Time. ISDA Fixing Time Definition. (e.g. 09:30, Sydney time).'}
    fixingTimeDefinition: String[0..1];
    {nlq::NlqProfile.description = 'Fixing Reason'}
    fixingReason: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This type holds parameters defining the normal fixing offset for a floating rate index.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndexFixingOffset
{
    {nlq::NlqProfile.description = 'Allows a reason to be specified for using the alternative fixing offset.'}
    designatedMaturity: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This allows an offset to be specified as, for instance, N business days, with a business centers specified as included.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::BusinessDayOffset
{
    {nlq::NlqProfile.description = 'Legal text that underlies the Fixing Offset. ISDA Fixing Offset Definition. (e.g. One day that is either a Sydney Bus...'}
    fixingOffsetDefinition: String[0..1];
    {nlq::NlqProfile.description = 'Fixing Offset Reason'}
    fixingOffsetReason: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identifies an index by referencing an identifier.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::IndexBase
{
    {nlq::NlqProfile.description = 'A description of the Index.'}
    name: String[0..1];
    {nlq::NlqProfile.description = 'The Asset Class of the Index.'}
    assetClass: asset::AssetClassEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of an interest rate index which can change over time, e.g. the SONIA (Sterling Overnight Index Average) in the UK.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FloatingRateIndex
{
    {nlq::NlqProfile.description = 'The reference index that is used to specify the floating interest rate.'}
    floatingRateIndex: other::FloatingRateIndexEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of a rate based on the exchange of a pair of cash assets in specific currencies, e.g. USD versus GBP.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ForeignExchangeRateIndex
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of an index that measures inflation in a specific market, e.g. the US Consumer Price Index.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::InflationIndex
{
    {nlq::NlqProfile.description = 'The reference index that is used to specify the inflation interest rate.'}
    inflationRateIndex: other::InflationRateIndexEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of an index based on credit risk, typically composed using corporate debt instruments in a region or industry sector, e.g. the iTraxx...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CreditIndex
{
    {nlq::NlqProfile.description = 'A CDS index series identifier, e.g. 1, 2, 3 etc.'}
    indexSeries: Integer[0..1];
    {nlq::NlqProfile.description = 'A CDS index series version identifier, e.g. 1, 2, 3 etc.'}
    indexAnnexVersion: Integer[0..1];
    {nlq::NlqProfile.description = 'A CDS index series annex date.'}
    indexAnnexDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'A CDS index series annex source.'}
    indexAnnexSource: product::IndexAnnexSourceEnum[0..1];
    {nlq::NlqProfile.description = 'Index Factor is the index version factor or percent, expressed as an absolute decimal value between 0 and 1, that mul...'}
    indexFactor: Float[0..1];
    {nlq::NlqProfile.description = 'Seniority of debt instruments comprising the index.'}
    seniority: product::CreditSeniorityEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of an index based on equity securities, e.g. the S&P 500..',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::EquityIndex
{
    {nlq::NlqProfile.description = 'The equity index value speciied from the EquityIndexEnum.'}
    equityIndex: other::EquityIndexEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specification of a user-defined index that does not meet the criteria of other Index data types.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::OtherIndex
{
    {nlq::NlqProfile.description = 'A description that defines the OtherIndex.'}
    description: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a settlement as an exchange between two parties of a specified quantity of an asset (the quantity) against a specified quantity of another ...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::PriceQuantity
{
    {nlq::NlqProfile.description = 'Specifies the object to be observed for a price, it could be an asset or an index. The cardinality is optional as som...'}
    observable: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This class corresponds to the FpML Premium.model group for representing the option premium when expressed in a way other than an amount.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::PremiumExpression
{
    {nlq::NlqProfile.description = 'Forward start premium type'}
    premiumType: observable::PremiumTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The amount of premium to be paid expressed as a percentage of the notional value of the transaction. A percentage of ...', nlq::NlqProfile.unit = 'currency'}
    percentageOfNotional: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the nature of a cash price either as a fee type, cash price type, or premium expression.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CashPrice
{
    {nlq::NlqProfile.description = 'Specifies the type of Cash Price.'}
    priceSubType: observable::PriceSubTypeEnum[1];
    {nlq::NlqProfile.description = 'Specifies the event type associated with a fee.'}
    feeType: observable::FeeTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the inputs required to calculate a price as a simple composite of 2 other values. The inputs consist of 2 numbers and a simple arithmetic o...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::PriceComposite
{
    {nlq::NlqProfile.description = 'The 1st value in the arithmetic operation, which may be non-commutative in some cases: Subtract, Divide). This 1st op...', nlq::NlqProfile.unit = 'currency'}
    baseValue: Float[1];
    {nlq::NlqProfile.description = 'The 2nd value in the arithmetic operation, which may be non-commutative in some cases: Subtract, Divide). The 2nd ope...'}
    operand: Float[1];
    {nlq::NlqProfile.description = 'Specifies the arithmetic operator via an enumeration.'}
    arithmeticOperator: math::ArithmeticOperationEnum[1];
    {nlq::NlqProfile.description = 'Optionally qualifies the type of operand: e.g. accrued or forward point.'}
    operandType: observable::PriceOperandEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the price of a financial instrument in a trade as a schedule of measures. A price generically expresses the value of an exchange as a rat...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::PriceSchedule
{
    {nlq::NlqProfile.description = 'Specifies the price type as an enumeration: interest rate, exchange rate, asset price etc. This attribute is mandator...'}
    priceType: observable::PriceTypeEnum[1];
    {nlq::NlqProfile.description = 'Allows further classification of the chosen price type.'}
    priceSubType: observable::PriceSubTypeEnum[0..1];
    {nlq::NlqProfile.description = '(Optionally) Specifies whether the price is expressed in absolute or percentage terms.'}
    priceExpression: observable::PriceExpressionEnum[0..1];
    {nlq::NlqProfile.description = '(Optionally) When the price is to be understood as an operator to apply to an observable, i.e. a spread, multiplier o...'}
    arithmeticOperator: math::ArithmeticOperationEnum[0..1];
    {nlq::NlqProfile.description = '(Optionally) Additional attribute that can further define any premium to the price.'}
    premiumType: observable::PremiumTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a custom basket by referencing an identifier and its constituents.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::Basket
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Identifies the constituents of the basket',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::BasketConstituent
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the source for a piece of information (e.g. a rate fix or an FX fixing). The attribute names have been adjusted from FpML to addre...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::InformationSource
{
    {nlq::NlqProfile.description = 'An information source for obtaining a market data point. For example Bloomberg, Reuters, Telerate, etc.'}
    sourceProvider: observable::InformationProviderEnum[1];
    {nlq::NlqProfile.description = 'A specific page for the source for obtaining a market data point. In FpML, this is specified as a scheme, rateSourceP...'}
    sourcePage: String[0..1];
    {nlq::NlqProfile.description = 'The heading for the source on a given source page.'}
    sourcePageHeading: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class that describes the composition of a rate that has been quoted or is to be quoted. This includes the two currencies and the quotation relati...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::QuotedCurrencyPair
{
    {nlq::NlqProfile.description = 'The first currency specified when a pair of currencies is to be evaluated.'}
    currency1: String[1];
    {nlq::NlqProfile.description = 'The second currency specified when a pair of currencies is to be evaluated.'}
    currency2: String[1];
    {nlq::NlqProfile.description = 'The method by which the exchange rate is quoted.'}
    quoteBasis: observable::QuoteBasisEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Curve',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::Curve
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'InterestRateCurve',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::InterestRateCurve
{
    {nlq::NlqProfile.description = 'floatingRateIndex'}
    floatingRateIndex: other::FloatingRateIndexEnum[1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class to represent the transacted price attributes that are positioned as part of the FpML FeeLeg.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::TransactedPrice
{
    {nlq::NlqProfile.description = 'An optional element that only has meaning in a credit index trade. This element contains the credit spread (\'fair va...', nlq::NlqProfile.unit = 'percent'}
    marketFixedRate: Float[0..1];
    {nlq::NlqProfile.description = 'An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints val...'}
    initialPoints: Float[0..1];
    {nlq::NlqProfile.description = 'An optional element that only has meaning in a credit index trade. This element contains the price at which the trade...', nlq::NlqProfile.unit = 'currency'}
    marketPrice: Float[0..1];
    {nlq::NlqProfile.description = 'An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints val...'}
    quotationStyle: observable::QuotationStyleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A complex type used to specify the option and convertible bond option strike when expressed in reference to a swap curve.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ReferenceSwapCurve
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the amount to be paid by the buyer of the option if the option is exercised prior to the Early Call Date (typically applicable t...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::MakeWholeAmount
{
    {nlq::NlqProfile.description = 'The type of interpolation method that the calculation agent reserves the right to use.'}
    interpolationMethod: observable::InterpolationMethodEnum[0..1];
    {nlq::NlqProfile.description = 'Date prior to which the option buyer will have to pay a Make Whole Amount to the option seller if he/she exercises th...'}
    earlyCallDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a valuation swap curve, which is used as part of the strike construct for the bond and convertible bond options.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::SwapCurveValuation
{
    {nlq::NlqProfile.description = 'floatingRateIndex'}
    floatingRateIndex: other::FloatingRateIndexEnum[1];
    {nlq::NlqProfile.description = 'Spread in basis points over the floating rate index.', nlq::NlqProfile.unit = 'percent'}
    spread: Float[1];
    {nlq::NlqProfile.description = 'The side (bid/mid/ask) of the measure.'}
    side: observable::QuotationSideEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines how and when a performance type option or performance type swap is to be valued, including initial, interim and final valuation dates.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ValuationDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines how and when a performance type option or performance type swap is to be valued.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::PerformanceValuationDates
{
    {nlq::NlqProfile.description = 'Specifies the method according to which an amount or a date is determined.'}
    determinationMethod: observable::DeterminationMethodEnum[1];
    {nlq::NlqProfile.description = 'The time of day at which the calculation agent values the underlying, for example the official closing time of the ex...'}
    valuationTimeType: observable::TimeTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Describes a rate source to be fixed and the date the fixing occurs',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FxRateSourceFixing
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Information source specific to Foreign Exchange products.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FxInformationSource
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The method, prioritised by the order it is listed in this element, to get a replacement rate for the disrupted settlement rate option.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FallbackReferencePrice
{
    {nlq::NlqProfile.description = 'This settlement rate option will be used in its place.'}
    fallBackSettlementRateOption: observable::SettlementRateOptionEnum[*];
    {nlq::NlqProfile.description = 'Request rate quotes from the market. This element is set as type Empty in FpML. When present, the FpML synonym is map...'}
    fallbackSurveyValuationPostponement: Boolean[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Specifies how long to wait to get a quote from a settlement rate option upon a price source disruption.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ValuationPostponement
{
    {nlq::NlqProfile.description = 'The maximum number of days to wait for a quote from the disrupted settlement rate option before proceeding to the nex...'}
    maximumDaysOfPostponement: Integer[1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class describing the rate of a currency conversion: pair of currency, quotation mode and exchange rate.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FxRate
{
    {nlq::NlqProfile.description = 'The rate of exchange between the two currencies of the leg of a deal. Must be specified with a quote basis.', nlq::NlqProfile.unit = 'percent'}
    rate: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the rate source and fixing time for an FX rate.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FxSpotRateSource
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class defining parameters associated with an individual observation or fixing. This class forms part of the cashflow representation of a stream.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::RateObservation
{
    {nlq::NlqProfile.description = 'The reset date.'}
    resetDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The adjusted fixing date, i.e. the actual date the rate is observed. The date should already be adjusted for any appl...'}
    adjustedFixingDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The actual observed rate before any required rate treatment is applied, e.g. before converting a rate quoted on a dis...', nlq::NlqProfile.unit = 'percent'}
    observedRate: Float[0..1];
    {nlq::NlqProfile.description = 'The observed rate after any required rate treatment is applied. A treated rate of 5% would be represented as 0.05.', nlq::NlqProfile.unit = 'percent'}
    treatedRate: Float[0..1];
    {nlq::NlqProfile.description = 'The number of days weighting to be associated with the rate observation, i.e. the number of days such rate is in effe...'}
    observationWeight: Integer[0..1];
    {nlq::NlqProfile.description = 'The value representing the forecast rate used to calculate the forecast future value of the accrual period.A value of...', nlq::NlqProfile.unit = 'percent'}
    forecastRate: Float[0..1];
    {nlq::NlqProfile.description = 'The value representing the forecast rate after applying rate treatment rules. A value of 1% should be represented as ...', nlq::NlqProfile.unit = 'percent'}
    treatedForecastRate: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to specify the credit notation as the combination of agency, notation, scale and debt type qualifications.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CreditNotation
{
    {nlq::NlqProfile.description = 'Specifies The credit agency to which the other variables (notation, scale, debt type) refer to.'}
    agency: observable::CreditRatingAgencyEnum[1];
    {nlq::NlqProfile.description = 'Specifies The credit rating notation. As it varies among credit rating agencies, FpML doesn\'t specify a default scheme.'}
    notation: String[1];
    {nlq::NlqProfile.description = 'Specifies the credit rating scale, with a typical distinction between short term, long term. FpML doesn\'t specify a ...'}
    scale: String[0..1];
    {nlq::NlqProfile.description = 'Assesses the potential direction of a long-term credit rating over the intermediate term, which is generally up to tw...'}
    outlook: observable::CreditRatingOutlookEnum[0..1];
    {nlq::NlqProfile.description = 'Indicates the potential direction of a short-term or long-term rating. It focuses on identifiable events and short-te...'}
    creditWatch: observable::CreditRatingCreditWatchEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents the credit rating notation higher level construct, which provides the ability to specify multiple rating notations.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CreditNotations
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the credit rating debt type(s) associated with the credit rating notation and scale. When several debt types are specified, they must be ...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CreditRatingDebt
{
    {nlq::NlqProfile.description = 'Specifies when there is only one debt type. FpML doesn\'t specify values in relation to the associated scheme, which ...'}
    debtType: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represetns a class to specify multiple credit notations alongside a conditional \'any\' or \'all\' qualifier.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::MultipleCreditNotations
{
    {nlq::NlqProfile.description = 'mismatchResolution'}
    mismatchResolution: observable::CreditNotationMismatchResolutionEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a class to specify multiple credit debt types alongside a conditional \'any\' or \'all\' qualifier.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::MultipleDebtTypes
{
    {nlq::NlqProfile.description = 'The type of debt, e.g. long term debt, deposit, ... FpML doesn\'t specific a scheme value, hence no enumeration is sp...'}
    debtType: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The source of the Foreign Exchange settlement rate.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FxSettlementRateSource
{
    {nlq::NlqProfile.description = 'Indicates that an officially defined rate settlement rate option will be the used for the fixing.'}
    settlementRateOption: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CalculationAgent
{
    {nlq::NlqProfile.description = 'Specifies the party which is the ISDA Calculation Agent for the trade. If more than one party is referenced then the ...'}
    calculationAgentParty: party::AncillaryRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the ISDA calculation agent responsible for performing duties as defined in the applicable product definitio...'}
    calculationAgentPartyEnum: observable::PartyDeterminationEnum[0..1];
    {nlq::NlqProfile.description = 'The city in which the office through which ISDA Calculation Agent is acting for purposes of the transaction is locate...'}
    calculationAgentBusinessCenter: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the settlement rate option to use for fixing in case of cash settlement. Currently only applicable to foreign exchange fixing in case of cr...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::SettlementRateOption
{
    {nlq::NlqProfile.description = 'The rate source for the conversion to the settlement currency. This source is specified through a scheme that reflect...'}
    settlementRateOption: observable::SettlementRateOptionEnum[1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'MultipleValuationDates',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::MultipleValuationDates
{
    {nlq::NlqProfile.description = 'The number of business days between successive valuation dates when multiple valuation dates are applicable for cash ...'}
    businessDaysThereafter: Integer[0..1];
    {nlq::NlqProfile.description = 'Where multiple valuation dates are specified as being applicable for cash settlement, this element specifies (a) the ...'}
    numberValuationDates: Integer[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class to specify the number of business days after satisfaction of all conditions to settlement.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::SingleValuationDate
{
    {nlq::NlqProfile.description = 'A number of business days. Its precise meaning is dependant on the context in which this element is used. ISDA 2003 T...'}
    businessDays: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class describing the method for obtaining a settlement rate, specified through either an information source (page), a settlement rate option (fix...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ValuationSource
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the parameters used to get a price quote to replace the settlement rate option that is disrupted.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::PriceSourceDisruption
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the parameters required to obtain a valuation, including the source, quotation method (bid, mid etc.) and any applicable quotation amount.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ValuationMethod
{
    {nlq::NlqProfile.description = 'The type of price quotations to be requested from dealers when determining the market value of the reference obligati...'}
    quotationMethod: observable::QuotationRateTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The ISDA defined methodology for determining the final price of the reference obligation for purposes of cash settlem...'}
    valuationMethod: observable::ValuationMethodEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This type is a generic structure that can represent the parameters of several mid-market valuation and replacement value methods described in the 2...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CashCollateralValuationMethod
{
    {nlq::NlqProfile.description = 'This may be used to specify what type of CSA (credit support annex/agreement) is to be used for cash settlement purpo...'}
    applicableCsa: observable::CsaTypeEnum[0..1];
    {nlq::NlqProfile.description = 'This may be used to indicate the currency of cash collateral for cash settlement purposes.'}
    cashCollateralCurrency: String[0..1];
    {nlq::NlqProfile.description = 'This may be used to indicate the interest rate to be used for cash collateral for cash settlement purposes.'}
    cashCollateralInterestRate: String[0..1];
    {nlq::NlqProfile.description = 'This may be used to indicate the discount rate to be used for cash collateral for cash settlement purposes.'}
    agreedDiscountRate: String[0..1];
    {nlq::NlqProfile.description = 'This may be used to specify which party is protected (e.g. under Replacement Value cash settlement methods).'}
    protectedParty: observable::PartyDeterminationEnum[0..1];
    {nlq::NlqProfile.description = 'This may be used to indicate that \'prescribed documentation adjustment\' is applicable.'}
    prescribedDocumentationAdjustment: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The parameters which define whether dividends are applicable',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::DividendApplicability
{
    {nlq::NlqProfile.description = 'If present and true, then options exchange dividends are applicable.'}
    optionsExchangeDividends: Boolean[0..1];
    {nlq::NlqProfile.description = 'If present and true, then additional dividends are applicable.'}
    additionalDividends: Boolean[0..1];
    {nlq::NlqProfile.description = 'Represents the European Master Confirmation value of \'All Dividends\' which, when applicable, signifies that, for a ...'}
    allDividends: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Trigger point at which feature is effective.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::Trigger
{
    {nlq::NlqProfile.description = 'The Triggering condition.'}
    triggerType: observable::TriggerTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The valuation time type of knock condition.'}
    triggerTimeType: observable::TriggerTimeTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Observation point for trigger.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::TriggerEvent
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the applicable Credit Events that would trigger a settlement, as specified in the related Confirmation and defined in the ISDA 2...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CreditEvents
{
    {nlq::NlqProfile.description = 'A credit event. The reference entity has been dissolved or has become insolvent. It also covers events that may be a ...'}
    bankruptcy: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. Corresponds to the failure by the Reference Entity to pay an expected principal amount or the payment...'}
    failureToPayPrincipal: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. Corresponds to the failure by the Reference Entity to pay an expected interest amount or the payment ...'}
    failureToPayInterest: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. One or more of the obligations have become capable of being declared due and payable before they woul...'}
    obligationDefault: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. One or more of the obligations have been declared due and payable before they would otherwise have be...'}
    obligationAcceleration: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. The reference entity, or a governmental authority, either refuses to recognise or challenges the vali...'}
    repudiationMoratorium: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. A governmental intervention is an event resulting from an action by a governmental authority that mat...'}
    governmentalIntervention: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. Results from the fact that the rating of the reference obligation is down-graded to a distressed rati...'}
    distressedRatingsDowngrade: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. Results from the fact that the underlier fails to make principal payments as expected.'}
    maturityExtension: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. Results from the fact that the underlier writes down its outstanding principal amount.'}
    writedown: Boolean[0..1];
    {nlq::NlqProfile.description = 'A credit event. Results from the fact that losses occur to the underlying instruments that do not result in reduction...'}
    impliedWritedown: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'CreditEventNotice',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::CreditEventNotice
{
    {nlq::NlqProfile.description = 'The notifying party is the party that notifies the other party when a credit event has occurred by means of a credit ...'}
    notifyingParty: party::CounterpartyRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Inclusion of this business center element implies that Greenwich Mean Time in Section 3.3 of the 2003 ISDA Credit Der...'}
    businessCenter: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FailureToPay',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FailureToPay
{
    {nlq::NlqProfile.description = 'Indicates whether the failure to pay provision is applicable.'}
    applicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'GracePeriodExtension',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::GracePeriodExtension
{
    {nlq::NlqProfile.description = 'Indicates whether the grace period extension provision is applicable.'}
    applicable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'PubliclyAvailableInformation',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::PubliclyAvailableInformation
{
    {nlq::NlqProfile.description = 'If this element is specified and set to \'true\', indicates that ISDA defined Standard Public Sources are applicable.'}
    standardPublicSources: Boolean[0..1];
    {nlq::NlqProfile.description = 'A public information source, e.g. a particular newspaper or electronic news service, that may publish relevant inform...'}
    publicSource: String[*];
    {nlq::NlqProfile.description = 'The minimum number of the specified public information sources that must publish information that reasonably confirms...'}
    specifiedNumber: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Restructuring',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::Restructuring
{
    {nlq::NlqProfile.description = 'Indicates whether the restructuring provision is applicable.'}
    applicable: Boolean[1];
    {nlq::NlqProfile.description = 'Specifies the type of restructuring that is applicable.'}
    restructuringType: observable::RestructuringEnum[0..1];
    {nlq::NlqProfile.description = 'In relation to a restructuring credit event, unless multiple holder obligation is not specified restructurings are li...'}
    multipleHolderObligation: Boolean[0..1];
    {nlq::NlqProfile.description = 'Presence of this element and value set to \'true\' indicates that Section 3.9 of the 2003 Credit Derivatives Definiti...'}
    multipleCreditEventNotices: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Payment made following trigger occurrence.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::FeaturePayment
{
    {nlq::NlqProfile.description = 'The trigger level percentage.', nlq::NlqProfile.unit = 'percent'}
    levelPercentage: Float[0..1];
    {nlq::NlqProfile.description = 'The monetary quantity in currency units.', nlq::NlqProfile.unit = 'currency'}
    amount: Float[0..1];
    {nlq::NlqProfile.description = 'The feature payment time.'}
    time: observable::TimeTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The currency in which an amount is denominated.'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a single, numerical value that was observed in the marketplace. Observations of market data are made independently to business events or tr...',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::Observation
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the parameters needed to uniquely identify a piece of data among the population of all available market data.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::ObservationIdentifier
{
    {nlq::NlqProfile.description = 'Represents the asset or rate to which the observation relates.'}
    observable: String[1];
    {nlq::NlqProfile.description = 'Specifies the date value to use when resolving the market data.'}
    observationDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the method according to which an amount or a date is determined.',
   nlq::NlqProfile.businessDomain = 'Market Observables & Indices',
   nlq::NlqProfile.whenToUse = 'Use for market observables, floating rate indices, price sources, and calculated rates'}
observable::DeterminationMethodology
{
    {nlq::NlqProfile.description = 'Represents a more granular dimention of observation. Typically relevent for resolving a unique equity price, which ca...'}
    determinationMethod: observable::DeterminationMethodEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies enumerations for the type of averaging calculation.'}
    averagingMethod: math::AveragingCalculationMethodEnum[0..1];
}

// ─── Party & Counterparty (22 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a counterparty enumerated value, e.g. Party1 or Party2, with an associated party reference. The product is agnostic to the actual parties t...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::Counterparty
{
    {nlq::NlqProfile.description = 'Specifies the CounterpartyEnum, e.g. either Party1 or Party2, that is associated to the partyReference.'}
    role: party::CounterpartyRoleEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines an ancillary role enumerated value with an associated party reference. The product is agnostic to the actual parties involved in the transa...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::AncillaryParty
{
    {nlq::NlqProfile.description = 'Specifies the AncillaryRoleEnum that is associated to the party reference. An ancillary party is any involved party t...'}
    role: party::AncillaryRoleEnum[1];
    {nlq::NlqProfile.description = 'Optionally specifies the counterparty that the ancillary party is acting on behalf of.'}
    onBehalfOf: party::CounterpartyRoleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This class corresponds to the FpML BuyerSeller.model construct.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::BuyerSeller
{
    {nlq::NlqProfile.description = 'Buyer party that can be resolved as one of the two principal parties to the transaction. The party that buys this ins...'}
    buyer: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Seller party that can be resolved as one of the two principal parties to the transaction. The party that sells (\'wri...'}
    seller: party::CounterpartyRoleEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the parties responsible for making and receiving payments defined by this structure.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::PayerReceiver
{
    {nlq::NlqProfile.description = 'Specifies the counterparty responsible for making the payments defined by this structure.  The party is one of the tw...'}
    payer: party::CounterpartyRoleEnum[1];
    {nlq::NlqProfile.description = 'Specifies the party that receives the payments corresponding to this structure.  The party is one of the two counterp...'}
    receiver: party::CounterpartyRoleEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the parties responsible for making and receiving payments defined by this structure.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::PartyReferencePayerReceiver
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to describe an institution (party) identified by means of a coding scheme and an optional name.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::ReferenceBank
{
    {nlq::NlqProfile.description = 'An institution (party) identifier, e.g. a bank identifier code (BIC). FpML specifies a referenceBankIdScheme.'}
    referenceBankId: String[1];
    {nlq::NlqProfile.description = 'The name of the institution (party). A free format string. FpML does not define usage rules for the element.'}
    referenceBankName: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the list of reference institutions polled for relevant rates or prices when determining the cash settlement amount for a product w...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::ReferenceBanks
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'RelatedParty',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::RelatedParty
{
    {nlq::NlqProfile.description = 'The category of the relationship. The related party performs the role specified in this field for the base party. For...'}
    role: party::PartyRoleEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify an account as an account number alongside, optionally. an account name, an account type, an account beneficiary and a servicing ...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::Account
{
    {nlq::NlqProfile.description = 'The account number.'}
    accountNumber: String[1];
    {nlq::NlqProfile.description = 'The name by which the account is known.'}
    accountName: String[0..1];
    {nlq::NlqProfile.description = 'The type of account, e.g. client, house.'}
    accountType: party::AccountTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a post or street address.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::Address
{
    {nlq::NlqProfile.description = 'The set of street and building number information that identifies a postal address within a city.'}
    street: String[1..*];
    {nlq::NlqProfile.description = 'The city component of the postal address.'}
    city: String[0..1];
    {nlq::NlqProfile.description = 'A country subdivision used in postal addresses in some countries. For example, US states, Canadian provinces, Swiss c...'}
    state: String[0..1];
    {nlq::NlqProfile.description = 'The ISO 3166 standard code for the country within which the postal address is located.'}
    country: String[0..1];
    {nlq::NlqProfile.description = 'The code, required for computerized mail sorting systems, that is allocated to a physical address by a national posta...'}
    postalCode: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify an organizational unit.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::BusinessUnit
{
    {nlq::NlqProfile.description = 'A name used to describe the organizational unit'}
    name: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify contact information associated with a party: telephone, postal/street address, email and web page.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::ContactInformation
{
    {nlq::NlqProfile.description = 'The email address.'}
    email: String[*];
    {nlq::NlqProfile.description = 'The web page. This attribute is not specified as part of the FpML ContactInformation complex type.'}
    webPage: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a legal entity, with a required name and an optional entity identifier (such as the LEI).',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::LegalEntity
{
    {nlq::NlqProfile.description = 'The legal entity name.'}
    name: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to represent the attributes that are specific to a natural person.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::NaturalPerson
{
    {nlq::NlqProfile.description = 'An honorific title, such as Mr., Ms., Dr. etc.'}
    honorific: String[0..1];
    {nlq::NlqProfile.description = 'The natural person\'s first name. It is optional in FpML.'}
    firstName: String[0..1];
    {nlq::NlqProfile.description = 'The natural person\'s middle name(s). If a middle name is provided then an initial should be absent.'}
    middleName: String[*];
    {nlq::NlqProfile.description = 'The natural person\'s middle initial(s). If a middle initial is provided then a name should be absent.'}
    initial: String[*];
    {nlq::NlqProfile.description = 'The natural person\'s surname.'}
    surname: String[0..1];
    {nlq::NlqProfile.description = 'Name suffix, such as Jr., III, etc.'}
    suffix: String[0..1];
    {nlq::NlqProfile.description = 'The natural person\'s date of birth.'}
    dateOfBirth: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the role(s) that natural person(s) may have in relation to the contract.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::NaturalPersonRole
{
    {nlq::NlqProfile.description = 'FpML specifies a person role that is distinct from the party role.'}
    role: party::NaturalPersonRoleEnum[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a party, without a qualification as to whether this party is a legal entity or a natural person, although the model provides the...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::Party
{
    {nlq::NlqProfile.description = 'The party name.'}
    name: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Comprises an identifier and a source. The associated metadata key denotes the ability to associate a hash value to the PartyIdentifier instantiatio...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::PartyIdentifier
{
    {nlq::NlqProfile.description = 'Provides an identifier associated with a party. The identifier is unique within the public source specified in the so...'}
    identifier: String[1];
    {nlq::NlqProfile.description = 'Defines the source of the identifier.'}
    identifierType: party::PartyIdentifierTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Comprises an identifier and a source. The associated metadata key denotes the ability to associate a hash value to the EntityIdentifier instantiati...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::EntityIdentifier
{
    {nlq::NlqProfile.description = 'Provides an identifier associated with a legal entity.'}
    identifier: String[1];
    {nlq::NlqProfile.description = 'Defines the source of the identifier.'}
    identifierType: party::EntityIdentifierTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Comprises an identifier and a source. The associated metadata key denotes the ability to associate a hash value to the PersonIdentifier instantiati...',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::PersonIdentifier
{
    {nlq::NlqProfile.description = 'Provides an identifier associated with a person. The identifier is unique within the public source specified in the s...'}
    identifier: String[1];
    {nlq::NlqProfile.description = 'Defines the source of the identifier.'}
    identifierType: party::PersonIdentifierTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The ISO 3166 standard code for the country issuing the identifier.'}
    country: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the role(s) that party(ies) may have in relation to the execution, contract or other legal agreement.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::PartyRole
{
    {nlq::NlqProfile.description = 'The party role.'}
    role: party::PartyRoleEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a telephone number as a type of phone number (e.g. work, personal, ...) alongside with the actual number.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::TelephoneNumber
{
    {nlq::NlqProfile.description = 'The type of telephone number, e.g. work, mobile.'}
    telephoneNumberType: party::TelephoneTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The actual telephone number.'}
    number: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Holds an identifier for an ancillary entity, either identified directly via its ancillary role or directly as a legal entity.',
   nlq::NlqProfile.businessDomain = 'Party & Counterparty',
   nlq::NlqProfile.whenToUse = 'Use for parties, counterparties, accounts, and party roles in transactions'}
party::AncillaryEntity
{
    {nlq::NlqProfile.description = 'Identifies a party via its ancillary role on a transaction (e.g. CCP or DCO through which the trade should be cleared.)'}
    ancillaryParty: party::AncillaryRoleEnum[0..1];
}

// ─── Positions & Portfolio (10 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Encapsulates data features common to trade and position.',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::ContractBase
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A Position describes the accumulated effect of a set of securities or financial transactions.',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::CounterpartyPosition
{
    {nlq::NlqProfile.description = 'The date and time when the position was opened.'}
    openDateTime: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Base class to describe a Position, which could be a group of products (e.g. trade portfolio) or a group of assets (e.g. collateral portfolio).',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::PositionBase
{
    {nlq::NlqProfile.description = 'The product underlying the position.'}
    product: String[0..1];
    {nlq::NlqProfile.description = 'The asset that underlies the position.'}
    asset: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'State-full representation of a Portfolio that describes all the positions held at a given time, in various states which can be either traded, settl...',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::PortfolioState
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Parameters to be used to filter events that are relevant to a given portfolio in order to calculate the state of this portfolio. The attributes cor...',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::AggregationParameters
{
    {nlq::NlqProfile.description = 'To aggregate as of a particular date'}
    dateTime: DateTime[1];
    {nlq::NlqProfile.description = 'Specifies whether to calculate total position to given date, or only daily position for the given date.'}
    totalPosition: Boolean[0..1];
    {nlq::NlqProfile.description = 'To aggregate based on position status (EXECUTED, SETTLED etc)'}
    positionStatus: position::PositionStatusEnum[0..1];
    {nlq::NlqProfile.description = 'To aggregate based on a selection of product type(s).'}
    productQualifier: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A Portfolio represents an aggregation of multiple Positions, by describing the parameters that this Portfolio should be aggregated based on. The re...',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::Portfolio
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data type that can be used to describe an inventory of securities.',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::Inventory
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'An individual piece of inventory. This represents a single security.',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::InventoryRecord
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data type that can be used to describe the inventory of securities that a party holds. The securities are held in the AvailableInventoryRecord, w...',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::AvailableInventory
{
    {nlq::NlqProfile.description = 'Defines the purpose of this inventory.'}
    availableInventoryType: position::AvailableInventoryTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'An individual piece of available inventory. This represents a single security and its associated criteria. The criteria are used to describe any re...',
   nlq::NlqProfile.businessDomain = 'Positions & Portfolio',
   nlq::NlqProfile.whenToUse = 'Use for portfolio positions, position states, and aggregated holdings'}
position::AvailableInventoryRecord
{
    {nlq::NlqProfile.description = 'There may be a set period/time restriction associated to the security.'}
    expirationDateTime: DateTime[0..1];
}

// ─── Product & Payout Definitions (58 types) ───

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Type for reporting the detailed results of calculating a cash flow for a calculation period.  This is enhanced relative to the FpML-based cashflows...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingAmountCalculationDetails
{
    {nlq::NlqProfile.description = 'The rate that was actually applied, after all calculations and treatments.', nlq::NlqProfile.unit = 'percent'}
    appliedRate: Float[1];
    {nlq::NlqProfile.description = 'The fraction of a year that this calculation represents, according to the day count fraction method.'}
    yearFraction: Float[1];
    {nlq::NlqProfile.description = 'The amount of the cash flow that was computed, including any spreads and other processing.', nlq::NlqProfile.unit = 'currency'}
    calculatedAmount: Float[1];
    {nlq::NlqProfile.description = 'The amount of the cash flow excluding any spread, for subsequent processing.', nlq::NlqProfile.unit = 'currency'}
    spreadExclusiveCalculatedAMount: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Type for reporting the raw (untreated) observed or calculated rate for a calculation period.  If this is a calculated rate, it allows details of th...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingRateSettingDetails
{
    {nlq::NlqProfile.description = 'The day upon which the rate was observed (for term rates).'}
    observationDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The day for which the rate is needed (e.g. period beginning or end date).'}
    resetDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The resulting rate that was observed or calculated.', nlq::NlqProfile.unit = 'percent'}
    floatingRate: Float[1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Type for reporting the details of the rate treatment.  This could potentially be replaced by the existing FloatingRateDefinition type , but this is...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingRateProcessingDetails
{
    {nlq::NlqProfile.description = 'The raw or untreated rate, prior to any of the rate treatments.', nlq::NlqProfile.unit = 'percent'}
    rawRate: Float[1];
    {nlq::NlqProfile.description = 'The value of the processed rate without the spread applied, for subsequent compounding, etc.', nlq::NlqProfile.unit = 'percent'}
    spreadExclusiveRate: Float[1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Type to hold the processing parameters that should be or were used to calculate a floating amount.  These parameters can vary over a schedule so th...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingRateProcessingParameters
{
    {nlq::NlqProfile.description = 'floating rate multiplier.'}
    multiplier: Float[0..1];
    {nlq::NlqProfile.description = 'spread to be added to the floating rate.', nlq::NlqProfile.unit = 'percent'}
    spread: Float[0..1];
    {nlq::NlqProfile.description = 'US rate treatment (Bond Equivalent Yield or Money Market Yield, if applicable.'}
    treatment: product::RateTreatmentEnum[0..1];
    {nlq::NlqProfile.description = 'capt to be applied to the floating rate.', nlq::NlqProfile.unit = 'percent'}
    capRate: Float[0..1];
    {nlq::NlqProfile.description = 'floor to be applied to the floating rate.', nlq::NlqProfile.unit = 'percent'}
    floorRate: Float[0..1];
    {nlq::NlqProfile.description = 'How to handle negative interest rates.'}
    negativeTreatment: product::NegativeInterestRateTreatmentEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Payout based on the averaged price of a referenced underlier. (e.g. Commodities). Can represent both average (average of many) & bullet (average of...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::CommodityPayout
{
    {nlq::NlqProfile.description = 'Identifies the underlying product that is referenced for pricing of the applicable leg in a swap. Referenced in the \...'}
    underlier: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Contains the information relative to the delivery of the asset.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::AssetDeliveryInformation
{
    {nlq::NlqProfile.description = 'Grade of product being delivered (e.g., grade of oil).'}
    commodityGrade: other::ProductGradeEnum[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the periods of delivery, including the delivery profile.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::AssetDeliveryPeriods
{
    {nlq::NlqProfile.description = 'Delivery start date'}
    startDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Delivery end date'}
    endDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Period and time profile over which the delivery takes place.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::CalculationScheduleDeliveryPeriods
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the delivery profile of the asset, including the load type and the delivery intervals.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::AssetDeliveryProfile
{
    {nlq::NlqProfile.description = 'Identification of the delivery profile.'}
    loadType: product::LoadTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies whether the dates defined include holidays or not.'}
    bankHolidaysTreatment: product::BankHolidayTreatmentEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines a delivery profile block, including start and end time, days of the week, duration, delivery capacity and price time interval quantity.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::AssetDeliveryProfileBlock
{
    {nlq::NlqProfile.description = 'The start time of the delivery interval for each block or shape.'}
    startTime: String[0..1];
    {nlq::NlqProfile.description = 'The end time of the delivery interval for each block or shape.'}
    endTime: String[0..1];
    {nlq::NlqProfile.description = 'The days of the week of the delivery.'}
    dayOfWeek: datetime::DayOfWeekEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The credit default payout specification provides the details necessary for determining when a credit payout will be triggered as well as the parame...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::CreditDefaultPayout
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class specifying a set of non-monetary terms for the Credit Derivative Transaction, including the buyer and seller and selected items from the IS...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::GeneralTerms
{
    {nlq::NlqProfile.description = 'This attribute is used for representing information contained in the Additional Terms field of the 2003 Master Credit...'}
    additionalTerm: String[*];
    {nlq::NlqProfile.description = 'Value of this attribute set to \'true\' indicates that substitution is applicable.'}
    substitution: Boolean[0..1];
    {nlq::NlqProfile.description = 'Value of this attribute set to \'true\' indicates that modified equity delivery is applicable.'}
    modifiedEquityDelivery: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify all of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The inte...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::InterestRatePayout
{
    {nlq::NlqProfile.description = 'The specification of the rate value(s) applicable to the contract using either a floating rate calculation, a single ...'}
    rateSpecification: String[0..1];
    {nlq::NlqProfile.description = 'The day count fraction. The cardinality has been relaxed when compared with the FpML interest rate swap for the purpo...'}
    dayCountFraction: other::DayCountFractionEnum[0..1];
    {nlq::NlqProfile.description = 'Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a ...'}
    paymentDelay: Boolean[0..1];
    {nlq::NlqProfile.description = 'If one or more calculation period contributes to a single payment amount this element specifies whether compounding i...'}
    compoundingMethod: product::CompoundingMethodEnum[0..1];
    {nlq::NlqProfile.description = 'Fixed Amount Calculation'}
    fixedAmount: String[0..1];
    {nlq::NlqProfile.description = 'Floating Amount Calculation'}
    floatingAmount: String[0..1];
    {nlq::NlqProfile.description = 'Method by which spread is calculated. For example on an asset swap: \'ParPar\' or \'Proceeds\' may be the method indi...'}
    spreadCalculationMethod: product::SpreadCalculationMethodEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class describing the dividend payout ratio associated with an equity underlier. In certain cases the actual ratio is not known on trade inception...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::DividendPayoutRatio
{
    {nlq::NlqProfile.description = 'Specifies the total actual dividend payout ratio associated with the equity underlier. A ratio of 90% should be expre...'}
    totalRatio: Float[1];
    {nlq::NlqProfile.description = 'Specifies the cash actual dividend payout ratio associated with the equity underlier. A ratio of 90% should be expres...'}
    cashRatio: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies the non cash actual dividend payout ratio associated with the equity underlier. A ratio of 90% should be ex...'}
    nonCashRatio: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the events that will give rise to the payment additional fixed payments.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::AdditionalFixedPayments
{
    {nlq::NlqProfile.description = 'An additional Fixed Payment Event. Corresponds to the payment by or on behalf of the Issuer of an actual interest amo...'}
    interestShortfallReimbursement: Boolean[0..1];
    {nlq::NlqProfile.description = 'An additional Fixed Payment Event. Corresponds to the payment by or on behalf of the Issuer of an actual principal am...'}
    principalShortfallReimbursement: Boolean[0..1];
    {nlq::NlqProfile.description = 'An Additional Fixed Payment. Corresponds to the payment by or on behalf of the issuer of an amount in respect to the ...'}
    writedownReimbursement: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'CDS Basket Reference Information.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::BasketReferenceInformation
{
    {nlq::NlqProfile.description = 'The name of the basket expressed as a free format string. FpML does not define usage rules for this element.'}
    basketName: String[0..1];
    {nlq::NlqProfile.description = 'A CDS basket identifier.'}
    basketId: String[*];
    {nlq::NlqProfile.description = 'N th reference obligation to default triggers payout.'}
    nthToDefault: Integer[0..1];
    {nlq::NlqProfile.description = 'M th reference obligation to default to allow representation of N th to M th defaults.'}
    mthToDefault: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the ISDA terms relating to the floating rate payment events and the implied additional fixed payments, applicable to the credit ...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingAmountEvents
{
    {nlq::NlqProfile.description = 'A floating rate payment event. Corresponds to the failure by the Reference Entity to pay an expected principal amount...'}
    failureToPayPrincipal: Boolean[0..1];
    {nlq::NlqProfile.description = 'A floating rate payment event. Results from the fact that the underlier writes down its outstanding principal amount....'}
    writedown: Boolean[0..1];
    {nlq::NlqProfile.description = 'A floating rate payment event. Results from the fact that losses occur to the underlying instruments that do not resu...'}
    impliedWritedown: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FloatingAmountProvisions',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingAmountProvisions
{
    {nlq::NlqProfile.description = 'As specified by the ISDA Supplement for use with trades on mortgage-backed securities, \'WAC Cap\' means a weighted a...'}
    wacCapInterestProvision: Boolean[0..1];
    {nlq::NlqProfile.description = 'As specified by the ISDA Standard Terms Supplement for use with trades on mortgage-backed securities. The presence of...'}
    stepUpProvision: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the interest shortfall floating rate payment event.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::InterestShortFall
{
    {nlq::NlqProfile.description = 'Specifies the nature of the interest Shortfall cap (i.e. Fixed Cap or Variable Cap) in the case where it is applicabl...'}
    interestShortfallCap: product::InterestShortfallCapEnum[1];
    {nlq::NlqProfile.description = 'compounding'}
    compounding: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the terms for calculating a payout to protect the buyer of the swap in the case of a qualified credit event. These terms include...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ProtectionTerms
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class specifying the Credit Default Swap Reference Information.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ReferenceInformation
{
    {nlq::NlqProfile.description = 'Used to indicate that there is no Reference Obligation associated with this Credit Default Swap and that there will n...'}
    noReferenceObligation: Boolean[0..1];
    {nlq::NlqProfile.description = 'Used to indicate that the Reference obligation associated with the Credit Default Swap is currently not known. This i...'}
    unknownReferenceObligation: Boolean[0..1];
    {nlq::NlqProfile.description = 'Indicates whether an obligation of the Reference Entity, guaranteed by the Reference Entity on behalf of a non-Affili...'}
    allGuarantees: Boolean[0..1];
    {nlq::NlqProfile.description = 'Applicable to the transactions on mortgage-backed security, which can make use of a reference policy. Presence of the...'}
    referencePolicy: Boolean[0..1];
    {nlq::NlqProfile.description = 'With respect to any day, the list of Syndicated Secured Obligations of the Designated Priority of the Reference Entit...'}
    securedList: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the reference obligation that is associated with a credit derivative instrument.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ReferenceObligation
{
    {nlq::NlqProfile.description = 'A pointer style reference to a reference entity defined elsewhere in the document. Used when the reference entity is ...'}
    guarantorReference: String[0..1];
    {nlq::NlqProfile.description = 'Indicates if the reference obligation is a Standard Reference Obligation. ISDA 2014 Term: Standard Reference Obligation.'}
    standardReferenceObligation: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'ReferencePair',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ReferencePair
{
    {nlq::NlqProfile.description = 'Used to indicate that there is no Reference Obligation associated with this Credit Default Swap and that there will n...'}
    noReferenceObligation: Boolean[0..1];
    {nlq::NlqProfile.description = 'Defines the reference entity types corresponding to a list of types in the ISDA First to Default documentation.'}
    entityType: party::EntityTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This type contains all the reference pool items to define the reference entity and reference obligation(s) in the basket.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ReferencePool
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This type contains all the constituent weight and reference information.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ReferencePoolItem
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Relevant Settled Entity Matrix.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::SettledEntityMatrix
{
    {nlq::NlqProfile.description = 'Relevant settled entity matrix source.'}
    matrixSource: product::SettledEntityMatrixSourceEnum[1];
    {nlq::NlqProfile.description = 'Specifies the publication date of the applicable version of the matrix. When this element is omitted, the Standard Te...'}
    publicationDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'The class to represent a CDS Tranche.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::Tranche
{
    {nlq::NlqProfile.description = 'Lower bound percentage of the loss that the Tranche can endure, expressed as a decimal. An attachment point of 5% wou...'}
    attachmentPoint: Float[1];
    {nlq::NlqProfile.description = 'Upper bound percentage of the loss that the Tranche can endure, expressed as a decimal. An exhaustion point of 5% wou...'}
    exhaustionPoint: Float[1];
    {nlq::NlqProfile.description = 'Outstanding Swap Notional Amount is defined at any time on any day, as the greater of: (a) Zero; If Incurred Recovery...'}
    incurredRecoveryApplicable: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the currency in which the dividends will be denominated, i.e. either in the dividend currency or in a currency specified as part...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::DividendCurrency
{
    {nlq::NlqProfile.description = 'The currency in which the dividend is denominated. The list of valid currencies is not presently positioned as an enu...'}
    currency: String[0..1];
    {nlq::NlqProfile.description = 'Specifies the method according to which the dividend is determined, e.g. the dividend currency.'}
    determinationMethod: observable::DeterminationMethodEnum[0..1];
    {nlq::NlqProfile.description = 'Reference to a currency specified elsewhere in the document'}
    currencyReference: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the dividend date by reference to another date, with the ability to apply and offset. This class doesn\'t exist in FpML and is m...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::DividendDateReference
{
    {nlq::NlqProfile.description = 'Specification of the dividend date using an enumeration, with values such as the pay date, the ex-date or the record ...'}
    dateReference: product::DividendDateReferenceEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class describing the date on which the dividend will be paid/received. This class is also used to specify the date on which the FX rate will be d...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::DividendPaymentDate
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class describing the conditions governing the payment of dividends to the receiver of the equity return, with the exception of the dividend payou...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::DividendReturnTerms
{
    {nlq::NlqProfile.description = 'Boolean element that defines whether the dividend will be reinvested or not.'}
    dividendReinvestment: Boolean[0..1];
    {nlq::NlqProfile.description = 'Defines the date on which the receiver of the equity return is entitled to the dividend.'}
    dividendEntitlement: product::DividendEntitlementEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies whether the dividend is paid with respect to the Dividend Period.'}
    dividendAmountType: product::DividendAmountTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security E...'}
    performance: String[0..1];
    {nlq::NlqProfile.description = '2002 ISDA Equity Derivatives Definitions: Dividend Period as either the First Period or the Second Period. |'}
    firstOrSecondPeriod: product::DividendPeriodEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the party which determines if dividends are extraordinary in relation to normal levels.'}
    extraordinaryDividendsParty: party::AncillaryRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Determination of Gross Cash Dividend per Share.'}
    excessDividendAmount: product::DividendAmountTypeEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the treatment of Non-Cash Dividends.'}
    nonCashDividendTreatment: product::NonCashDividendTreatmentEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies how the composition of Dividends is to be determined.'}
    dividendComposition: product::DividendCompositionEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the method according to which special dividends are determined.'}
    specialDividends: Boolean[0..1];
    {nlq::NlqProfile.description = 'If present and true, then material non cash dividends are applicable.'}
    materialDividend: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Time bounded dividend payment periods, each with a dividend payment date per period.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::DividendPeriod
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'PriceReturnTerms',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::PriceReturnTerms
{
    {nlq::NlqProfile.description = 'The type of return associated with the equity swap.'}
    returnType: product::ReturnTypeEnum[1];
    {nlq::NlqProfile.description = 'Defines the conversion applied if the quantity unit on contract is different from unit on referenced underlier.'}
    conversionFactor: Float[0..1];
    {nlq::NlqProfile.description = 'Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security E...'}
    performance: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Contains all common elements in variance, volatility and correlation return Terms.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ReturnTermsBase
{
    {nlq::NlqProfile.description = 'This specifies the numerator of an annualization factor. Frequently this number is equal to the number of observation...'}
    annualizationFactor: Integer[0..1];
    {nlq::NlqProfile.description = 'Indicates whether the price of shares is adjusted for dividends or not.'}
    sharePriceDividendAdjustment: Boolean[0..1];
    {nlq::NlqProfile.description = 'Expected number of trading days.'}
    expectedN: Integer[1];
    {nlq::NlqProfile.description = 'Contract will strike off this initial level. Providing just the initialLevel without initialLevelSource, infers that ...'}
    initialLevel: Float[0..1];
    {nlq::NlqProfile.description = 'In this context, this is AgreedInitialPrice - a specified Initial Index Level.'}
    initialLevelSource: observable::DeterminationMethodEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies whether Mean Adjustment is applicable or not in the calculation of the Realized Volatility, Variance or Cor...'}
    meanAdjustment: Boolean[0..1];
    {nlq::NlqProfile.description = 'Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security E...'}
    performance: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'VarianceReturnTerms',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::VarianceReturnTerms
{
    {nlq::NlqProfile.description = 'Specification of the exchange traded contract nearest.'}
    exchangeTradedContractNearest: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'VolatilityReturnTerms',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::VolatilityReturnTerms
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'CorrelationReturnTerms',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::CorrelationReturnTerms
{
    {nlq::NlqProfile.description = 'Number of data series, normal market practice is that correlation data sets are drawn from geographic market areas, s...'}
    numberOfDataSeries: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'ValuationTerms',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ValuationTerms
{
    {nlq::NlqProfile.description = 'The official settlement price as announced by the related exchange is applicable, in accordance with the ISDA 2002 de...'}
    futuresPriceValuation: Boolean[0..1];
    {nlq::NlqProfile.description = 'The official settlement price as announced by the related exchange is applicable, in accordance with the ISDA 2002 de...'}
    optionsPriceValuation: Boolean[0..1];
    {nlq::NlqProfile.description = 'The number of valuation dates between valuation start date and valuation end date.'}
    numberOfValuationDates: Integer[0..1];
    {nlq::NlqProfile.description = 'Specifies the fallback provisions for Hedging Party in the determination of the Final Price.'}
    fPVFinalPriceElectionFallback: product::FPVFinalPriceElectionFallbackEnum[0..1];
    {nlq::NlqProfile.description = 'For an index option transaction, a flag to indicate whether a relevant Multiple Exchange Index Annex is applicable to...'}
    multipleExchangeIndexAnnexFallback: Boolean[0..1];
    {nlq::NlqProfile.description = 'For an index option transaction, a flag to indicate whether a relevant Component Security Index Annex is applicable t...'}
    componentSecurityIndexAnnexFallback: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'EquityUnderlierProvisions',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::EquityUnderlierProvisions
{
    {nlq::NlqProfile.description = 'For an index option or swap transaction, a flag to indicate whether a relevant Multiple Exchange Index Annex is appli...'}
    multipleExchangeIndexAnnexFallback: Boolean[0..1];
    {nlq::NlqProfile.description = 'For an index option or swap transaction, a flag to indicate whether a relevant Component Security Index Annex is appl...'}
    componentSecurityIndexAnnexFallback: Boolean[0..1];
    {nlq::NlqProfile.description = 'The ISO 3166 standard code for the country within which the postal address is located.'}
    localJurisdiction: String[0..1];
    {nlq::NlqProfile.description = 'The ISO 3166 standard code for the country within which the postal address is located.'}
    relevantJurisdiction: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'VarianceCapFloor',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::VarianceCapFloor
{
    {nlq::NlqProfile.description = 'If present and true, then variance cap is applicable.'}
    varianceCap: Boolean[1];
    {nlq::NlqProfile.description = 'For use when varianceCap is applicable. Contains the scaling factor of the Variance Cap that can differ on a trade-by...'}
    unadjustedVarianceCap: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'BoundedVariance',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::BoundedVariance
{
    {nlq::NlqProfile.description = 'The contract specifies which price must satisfy the boundary condition.'}
    realisedVarianceMethod: product::RealisedVarianceMethodEnum[1];
    {nlq::NlqProfile.description = 'The contract specifies whether the notional should be scaled by the Number of Days in Range divided by the Expected N...'}
    daysInRangeAdjustment: Boolean[1];
    {nlq::NlqProfile.description = 'All observations above this price level will be excluded from the variance calculation.'}
    upperBarrier: Float[0..1];
    {nlq::NlqProfile.description = 'All observations below this price level will be excluded from the variance calculation.'}
    lowerBarrier: Float[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Contains volatility-based barriers. Volatility Cap needs to be specified in accordance with the ISDA 2011 Equity Derivatives Definitions.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::VolatilityCapFloor
{
    {nlq::NlqProfile.description = 'Indicates whether the volatility cap is applicable in accordance with the ISDA 2011 Equity Derivatives Definitions. S...'}
    applicable: Boolean[1];
    {nlq::NlqProfile.description = 'Volatility Cap Amount in accordance with the ISDA 2011 Equity Derivatives Definitions. This means the Volatility Cap ...'}
    totalVolatilityCap: Float[0..1];
    {nlq::NlqProfile.description = 'Volatility Cap Amount in accordance with the ISDA 2011 Equity Derivatives Definitions. The Calculated VolCapAmt can b...'}
    volatilityCapFactor: Float[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Describes correlation bounds, which form a cap and a floor on the realized correlation.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::BoundedCorrelation
{
    {nlq::NlqProfile.description = 'Minimum Boundary as a percentage of the Strike Price.', nlq::NlqProfile.unit = 'percent'}
    minimumBoundaryPercent: Float[0..1];
    {nlq::NlqProfile.description = 'Maximum Boundary as a percentage of the Strike Price.', nlq::NlqProfile.unit = 'percent'}
    maximumBoundaryPercent: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'From FpML: A type defining either a spot or forward FX transactions.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::ForeignExchange
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Reference to a bond underlier to represent an asset swap or Condition Precedent Bond.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::BondReference
{
    {nlq::NlqProfile.description = 'To indicate whether the Condition Precedent Bond is applicable. The swap contract is only valid if the bond is issued...'}
    conditionPrecedentBond: Boolean[1];
    {nlq::NlqProfile.description = 'To indicate whether the Discrepancy Clause is applicable.'}
    discrepancyClause: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the cashflow representation of a swap trade.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::CashflowRepresentation
{
    {nlq::NlqProfile.description = 'A true/false flag to indicate whether the cashflows match the parametric definition of the stream, i.e. whether the c...'}
    cashflowsMatchParameters: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  discounting information. The 2000 ISDA definitions, section 8.4. discounting (related to the calculation of a discounted fixed am...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::DiscountingMethod
{
    {nlq::NlqProfile.description = 'The discounting method that is applicable.'}
    discountingType: product::DiscountingTypeEnum[1];
    {nlq::NlqProfile.description = 'A discount rate, expressed as a decimal, to be used in the calculation of a discounted amount. A discount amount of 5...', nlq::NlqProfile.unit = 'percent'}
    discountRate: Float[0..1];
    {nlq::NlqProfile.description = 'A discount day count fraction to be used in the calculation of a discounted amount.'}
    discountRateDayCountFraction: other::DayCountFractionEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A data defining:  parameters associated with a floating rate reset. This data forms:  part of the cashflows representation of a stream.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingRateDefinition
{
    {nlq::NlqProfile.description = 'The final calculated rate for a calculation period after any required averaging of rates A calculated rate of 5% woul...', nlq::NlqProfile.unit = 'percent'}
    calculatedRate: Float[0..1];
    {nlq::NlqProfile.description = 'A rate multiplier to apply to the floating rate. The multiplier can be a positive or negative decimal. This element s...', nlq::NlqProfile.unit = 'percent'}
    floatingRateMultiplier: Float[0..1];
    {nlq::NlqProfile.description = 'The ISDA Spread, if any, which applies for the calculation period. The spread is a per annum rate, expressed as a dec...', nlq::NlqProfile.unit = 'percent'}
    spread: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  specify the inflation rate.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::InflationRateSpecification
{
    {nlq::NlqProfile.description = 'The reference source such as Reuters or Bloomberg. FpML specifies indexSource to be of type rateSourcePageScheme, but...'}
    indexSource: String[1];
    {nlq::NlqProfile.description = 'The current main publication source such as relevant web site or a government body. FpML specifies mainPublication to...'}
    mainPublication: String[1];
    {nlq::NlqProfile.description = 'The method used when calculating the Inflation Index Level from multiple points. The most common is Linear.'}
    interpolationMethod: observable::InterpolationMethodEnum[1];
    {nlq::NlqProfile.description = 'Initial known index level for the first calculation period.'}
    initialIndexLevel: Float[0..1];
    {nlq::NlqProfile.description = 'The applicability of a fallback bond as defined in the 2006 ISDA Inflation Derivatives Definitions, sections 1.3 and ...'}
    fallbackBondApplicable: Boolean[1];
    {nlq::NlqProfile.description = 'Indicates how to use the inflation index to calculate the payment (e.g. Ratio, Return, Spread). Added for Inflation A...'}
    calculationMethod: observable::InflationCalculationMethodEnum[0..1];
    {nlq::NlqProfile.description = 'Indicates the style of how the inflation index calculates the payment (e.g. YearOnYear, ZeroCoupon).'}
    calculationStyle: observable::InflationCalculationStyleEnum[0..1];
    {nlq::NlqProfile.description = 'To be specified only for products that embed a redemption payment.'}
    finalPrincipalExchangeCalculation: product::FinalPrincipalExchangeCalculationEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a floating interest rate through the specification of the floating rate index, the tenor, the multiplier schedule, the spread, the...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingRateBase
{
    {nlq::NlqProfile.description = 'rateOption'}
    rateOption: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FloatingRate',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingRate
{
    {nlq::NlqProfile.description = 'The specification of any rate conversion which needs to be applied to the observed rate before being used in any calc...'}
    rateTreatment: product::RateTreatmentEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the floating interest rate by extending the floating rate definition with a set of attributes that specify such rate: the initia...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FloatingRateSpecification
{
    {nlq::NlqProfile.description = 'If averaging is applicable, this component specifies whether a weighted or unweighted average method of calculation i...'}
    averagingMethod: math::AveragingWeightingMethodEnum[0..1];
    {nlq::NlqProfile.description = 'The specification of any provisions for calculating payment obligations when a floating rate is negative (either due ...'}
    negativeInterestRateTreatment: product::NegativeInterestRateTreatmentEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Type defining the specification for a fixed rate.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FixedRateSpecification
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a currency and a future value date.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FutureValueAmount
{
    {nlq::NlqProfile.description = 'The currency in which the an amount is denominated. The list of valid currencies is not presently positioned as an en...'}
    currency: String[1];
    {nlq::NlqProfile.description = 'The number of days from the adjusted calculation period start date to the adjusted value date, calculated in accordan...'}
    calculationPeriodNumberOfDays: Integer[1];
    {nlq::NlqProfile.description = 'Adjusted value date of the future value amount.'}
    valueDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Adds an optional spread type element to the Schedule to identify a long or short spread value.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::SpreadSchedule
{
    {nlq::NlqProfile.description = 'An element which purpose is to identify a long or short spread value.'}
    spreadScheduleType: product::SpreadScheduleTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a floating rate.',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::StubFloatingRate
{
    {nlq::NlqProfile.description = 'The floating rate index.'}
    floatingRateIndex: other::FloatingRateIndexEnum[1];
    {nlq::NlqProfile.description = 'The specification of any rate conversion which needs to be applied to the observed rate before being used in any calc...'}
    rateTreatment: product::RateTreatmentEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A type defining how a stub calculation period amount is calculated. A single floating rate tenor different to that used for the regular part of the...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::StubValue
{
    {nlq::NlqProfile.description = 'An actual rate to apply for the initial or final stub period may have been agreed between the principal parties (in a...', nlq::NlqProfile.unit = 'percent'}
    stubRate: Float[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Type for reporting the detailed results of calculating a cash flow for a calculation period.  This is enhanced relative to the FpML-based cashflows...',
   nlq::NlqProfile.businessDomain = 'Product & Payout Definitions',
   nlq::NlqProfile.whenToUse = 'Use for derivative product definitions, payouts, economic terms, and asset payoffs'}
product::FixedAmountCalculationDetails
{
    {nlq::NlqProfile.description = 'The value of the fixed rate that was used.', nlq::NlqProfile.unit = 'percent'}
    fixedRate: Float[1];
    {nlq::NlqProfile.description = 'The fraction of a year that this calculation represents, according to the day count fraction method.'}
    yearFraction: Float[1];
    {nlq::NlqProfile.description = 'The amount of the cash flow that was computed, including any spreads and other processing.', nlq::NlqProfile.unit = 'currency'}
    calculatedAmount: Float[1];
}

// ─── Regulatory Reporting (29 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Document',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Document
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FinInstrmRptgTxRpt',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::FinInstrmRptgTxRpt
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Tx',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Tx
{
    {nlq::NlqProfile.description = 'tradDt'}
    tradDt: String[1];
    {nlq::NlqProfile.description = 'tradgCpcty'}
    tradgCpcty: String[1];
    {nlq::NlqProfile.description = 'tradVn'}
    tradVn: String[1];
    {nlq::NlqProfile.description = 'ctryOfBrnch'}
    ctryOfBrnch: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'New',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::New
{
    {nlq::NlqProfile.description = 'txId'}
    txId: String[1];
    {nlq::NlqProfile.description = 'exctgPty'}
    exctgPty: String[1];
    {nlq::NlqProfile.description = 'invstmtPtyInd'}
    invstmtPtyInd: String[1];
    {nlq::NlqProfile.description = 'submitgPty'}
    submitgPty: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Sellr',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Sellr
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Sngl',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Sngl
{
    {nlq::NlqProfile.description = 'isin'}
    isin: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'OrdrTrnsmssn',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::OrdrTrnsmssn
{
    {nlq::NlqProfile.description = 'trnsmssnInd'}
    trnsmssnInd: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'DerivInstrmAttrbts',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::DerivInstrmAttrbts
{
    {nlq::NlqProfile.description = 'xpryDt'}
    xpryDt: String[1];
    {nlq::NlqProfile.description = 'pricMltplr'}
    pricMltplr: String[1];
    {nlq::NlqProfile.description = 'dlvryTp'}
    dlvryTp: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'UndrlygInstrm',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::UndrlygInstrm
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'AcctOwnr',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::AcctOwnr
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'InvstmtDcsnPrsn',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::InvstmtDcsnPrsn
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Buyr',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Buyr
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Qty',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Qty
{
    {nlq::NlqProfile.description = 'unit'}
    unit: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FinInstrm',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::FinInstrm
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Pric',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Pric
{
    {nlq::NlqProfile.description = 'bsisPts'}
    bsisPts: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Prsn',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Prsn
{
    {nlq::NlqProfile.description = 'ctryOfBrnch'}
    ctryOfBrnch: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'FinInstrmGnlAttrbts',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::FinInstrmGnlAttrbts
{
    {nlq::NlqProfile.description = 'fullNm'}
    fullNm: String[1];
    {nlq::NlqProfile.description = 'clssfctnTp'}
    clssfctnTp: String[1];
    {nlq::NlqProfile.description = 'ntnlCcy'}
    ntnlCcy: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Nm',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Nm
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SwpOut',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::SwpOut
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Othr',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Othr
{
    {nlq::NlqProfile.description = 'id'}
    id: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'ExctgPrsn',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::ExctgPrsn
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Term',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Term
{
    {nlq::NlqProfile.description = 'unit'}
    unit: String[1];
    {nlq::NlqProfile.description = 'val'}
    val: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Swp',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Swp
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SchmeNm',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::SchmeNm
{
    {nlq::NlqProfile.description = 'prtry'}
    prtry: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'RefRate',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::RefRate
{
    {nlq::NlqProfile.description = 'indx'}
    indx: String[1];
    {nlq::NlqProfile.description = 'nm'}
    nm: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'AddtlAttrbts',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::AddtlAttrbts
{
    {nlq::NlqProfile.description = 'rskRdcgTx'}
    rskRdcgTx: String[1];
    {nlq::NlqProfile.description = 'sctiesFincgTxInd'}
    sctiesFincgTxInd: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'SwpIn',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::SwpIn
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Indx',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Indx
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Id',
   nlq::NlqProfile.businessDomain = 'Regulatory Reporting',
   nlq::NlqProfile.whenToUse = 'Use for regulatory reporting fields, EMIR, MiFID, Dodd-Frank, and other regulations'}
regulation::Id
{
    {nlq::NlqProfile.description = 'lei'}
    lei: String[1];
}

// ─── Calculation Schedules (29 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'CalculationPeriodData',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::CalculationPeriodData
{
    {nlq::NlqProfile.description = 'startDate'}
    startDate: StrictDate[1];
    {nlq::NlqProfile.description = 'daysInPeriod'}
    daysInPeriod: Integer[1];
    {nlq::NlqProfile.description = 'isFirstPeriod'}
    isFirstPeriod: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining how the initial or final stub calculation period amounts is calculated. For example, the rate to be applied to the initial or fina...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::StubPeriod
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The calculation period adjusted start and end dates, which are the baseline arguments needed to compute an interest accrual calculation.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::CalculationPeriodBase
{
    {nlq::NlqProfile.description = 'The calculation period start date, adjusted according to any relevant business day convention.'}
    adjustedStartDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The calculation period end date, adjusted according to any relevant business day convention.'}
    adjustedEndDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A data defining:  the parameters used in the calculation of a fixed or floating rate calculation period amount. This data forms:  part of cashflows...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::CalculationPeriod
{
    {nlq::NlqProfile.description = 'The calculation start date, unadjusted.'}
    unadjustedStartDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The calculation end date, unadjusted.'}
    unadjustedEndDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The number of days from the adjusted effective / start date to the adjusted termination / end date calculated in acco...'}
    calculationPeriodNumberOfDays: Integer[0..1];
    {nlq::NlqProfile.description = 'The amount that a cashflow will accrue interest on.', nlq::NlqProfile.unit = 'currency'}
    notionalAmount: Float[0..1];
    {nlq::NlqProfile.description = 'The calculation period fixed rate. A per annum rate, expressed as a decimal. A fixed rate of 5% would be represented ...', nlq::NlqProfile.unit = 'percent'}
    fixedRate: Float[0..1];
    {nlq::NlqProfile.description = 'The year fraction value of the calculation period, result of applying the ISDA rules for day count fraction defined i...'}
    dayCountYearFraction: Float[0..1];
    {nlq::NlqProfile.description = 'A value representing the forecast rate used to calculate the forecast future value of the accrual period. This is a c...', nlq::NlqProfile.unit = 'percent'}
    forecastRate: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data for:  defining the parameters used to generate the calculation period dates schedule, including the specification of any initial or final st...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::CalculationPeriodDates
{
    {nlq::NlqProfile.description = 'The start date of the regular part of the calculation period schedule. It must only be specified if there is an initi...'}
    firstRegularPeriodStartDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The end date of the initial compounding period when compounding is applicable. It must only be specified when the com...'}
    firstCompoundingPeriodEndDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The end date of the regular part of the calculation period schedule. It must only be specified if there is a final st...'}
    lastRegularPeriodEndDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Method to allocate any irregular period remaining after regular periods have been allocated between the effective and...'}
    stubPeriodType: schedule::StubPeriodTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  provide the ability to point to multiple payment nodes in the document through the unbounded paymentDatesReference.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::DateRelativeToCalculationPeriodDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  provide the ability to point to multiple payment nodes in the document through the unbounded paymentDatesReference.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::DateRelativeToValuationDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  provide the ability to point to multiple payment nodes in the document through the unbounded paymentDatesReference.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::DateRelativeToPaymentDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  describe the cashflow representation for FX linked notionals.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::FxLinkedNotionalAmount
{
    {nlq::NlqProfile.description = 'The reset date.'}
    resetDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date on which the FX spot rate is observed. This date should already be adjusted for any applicable business day ...'}
    adjustedFxSpotFixingDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The actual observed FX spot rate.', nlq::NlqProfile.unit = 'percent'}
    observedFxSpotRate: Float[0..1];
    {nlq::NlqProfile.description = 'The calculation period notional amount.', nlq::NlqProfile.unit = 'currency'}
    notionalAmount: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  describe a notional schedule where each notional that applies to a calculation period is calculated with reference to a notional amount...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::FxLinkedNotionalSchedule
{
    {nlq::NlqProfile.description = 'The currency of the varying notional amount, i.e. the notional amount being determined periodically based on observat...'}
    varyingNotionalCurrency: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the adjusted payment date and associated calculation period parameters required to calculate the actual or projected payment amou...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::PaymentCalculationPeriod
{
    {nlq::NlqProfile.description = 'The unadjusted payment date.'}
    unadjustedPaymentDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The adjusted payment date. This date should already be adjusted for any applicable business day convention. This comp...'}
    adjustedPaymentDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'A decimal value representing the discount factor used to calculate the present value of cash flow.'}
    discountFactor: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining a schedule of rates or amounts in terms of an initial value and then a series of step date and value pairs. On each step date the ...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::RateSchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Describes date details for a set of observation dates in parametric or non-parametric form.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::ObservationDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a single date on which market observations take place and specifies optional associated weighting.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::ObservationSchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a single date on which market observations take place and specifies optional associated weighting.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::ObservationDate
{
    {nlq::NlqProfile.description = 'A date subject to adjustment.'}
    unadjustedDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays chan...'}
    adjustedDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Specifies the degree of importance of the observation.', nlq::NlqProfile.unit = 'units'}
    weight: Float[0..1];
    {nlq::NlqProfile.description = 'Specifies an identification key for the market observation. This attribute can be used as a reference to assign weigh...'}
    observationReference: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Class containing terms that are associated with observing a price/benchmark/index across either single or multiple observations.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::ObservationTerms
{
    {nlq::NlqProfile.description = 'The enumerated values to specify points in the day when option exercise and valuation can occur.'}
    observationTimeType: observable::TimeTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The number of observation dates between observation start date and observation end date.'}
    numberOfObservationDates: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines rules for the dates on which the price will be determined.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::ParametricDates
{
    {nlq::NlqProfile.description = 'Denotes the enumerated values to specify the day type classification used in counting the number of days between two ...'}
    dayType: datetime::DayTypeEnum[1];
    {nlq::NlqProfile.description = 'Denotes the method by which the pricing days are distributed across the pricing period.'}
    dayDistribution: product::DayDistributionEnum[0..1];
    {nlq::NlqProfile.description = 'Indicates the days of the week on which the price will be determined.'}
    dayOfWeek: datetime::DayOfWeekEnum[0..1];
    {nlq::NlqProfile.description = 'Defines the occurrence of the dayOfWeek within the pricing period on which pricing will take place, e.g. the 3rd Frid...'}
    dayFrequency: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The pricing period per calculation period if the pricing days do not wholly fall within the respective calculation period.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::Lag
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the parameters used to generate the reset dates schedule and associated fixing dates. The reset dates are the dates on which the ...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::ResetDates
{
    {nlq::NlqProfile.description = 'Specifies whether the reset dates are determined with respect to each adjusted calculation period start date or adjus...'}
    resetRelativeTo: schedule::ResetRelativeToEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  how the initial or final stub calculation period amounts is calculated. For example, the rate to be applied to the initial or fin...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::StubCalculationPeriodAmount
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'An unordered list of weighted averaging observations.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::AveragingObservationList
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Period over which an average value is taken.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::AveragingPeriod
{
    {nlq::NlqProfile.description = 'The market disruption event as defined by ISDA 2002 Definitions.'}
    marketDisruption: observable::MarketDisruptionEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A single weighted averaging observation.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::WeightedAveragingObservation
{
    {nlq::NlqProfile.description = 'Observation date time, which should be used when literal observation dates are required. The CDM specifies that the z...'}
    dateTime: DateTime[0..1];
    {nlq::NlqProfile.description = 'Observation number, which should be unique, within a series generated by a date schedule.'}
    observationNumber: Integer[0..1];
    {nlq::NlqProfile.description = 'Observation weight, which is used as a multiplier for the observation value.', nlq::NlqProfile.unit = 'units'}
    weight: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a currency amount or a currency amount schedule.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::AmountSchedule
{
    {nlq::NlqProfile.description = 'The currency in which the amount schedule is denominated. The currency is specified outside of the actual schedule in...'}
    currency: String[1..*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A CDM class which purpose is to specify the initial fixing date either alongside the FpML interest rate specification as an offset of another date,...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::InitialFixingDate
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::PaymentDates
{
    {nlq::NlqProfile.description = 'The first unadjusted payment date. This day may be subject to adjustment in accordance with any business day conventi...'}
    firstPaymentDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The last regular payment date when specified as a date, as in the FpML interest rate construct. FpML specifies that t...'}
    lastRegularPaymentDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'Specifies whether the payments occur relative to each adjusted calculation period start date or end date, each reset ...'}
    payRelativeTo: schedule::PayRelativeToEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The payment dates when specified as relative to a set of dates specified somewhere else in the instance document/transaction, e.g. the valuation da...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::PaymentDateSchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the reset frequency. In the case of a weekly reset, also specifies the day of the week that the reset occurs. If the reset frequen...',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::ResetFrequency
{
    {nlq::NlqProfile.description = 'The day of the week on which a weekly reset date occurs. This element must be included if the reset frequency is defi...'}
    weeklyRollConvention: schedule::WeeklyRollConventionEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  define business date convention adjustment to final payment period per leg.',
   nlq::NlqProfile.businessDomain = 'Calculation Schedules',
   nlq::NlqProfile.whenToUse = 'Use for payment schedules, calculation period schedules, and date generation'}
schedule::FinalCalculationPeriodDateAdjustment
{
    {nlq::NlqProfile.description = 'Override business date convention. This takes precedence over leg level information.'}
    businessDayConvention: datetime::BusinessDayConventionEnum[1];
}

// ─── Settlement & Delivery (31 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the outcome of a computed amount, for testing purposes.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::ComputedAmount
{
    {nlq::NlqProfile.description = 'callFunction'}
    callFunction: String[1];
    {nlq::NlqProfile.description = 'The currency in which the computed amount is denominated. The list of valid currencies is not presently positioned as...'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the basic parameters of an asset transfer, e.g. a cashflow: what (the asset), how much (the quantity) and when (the settlement date).',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::AssetFlowBase
{
    {nlq::NlqProfile.description = 'Represents the object that is subject to the transfer, it could be an asset or a reference.'}
    asset: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Class to specify a cashflow, i.e. the outcome of either of computation (e.g. interest accrual) or an assessment of some sort (e.g. a fee). The cash...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::Cashflow
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Characterises the type of cashflow, which can result from either a scheduled or a non-scheduled lifecycle event.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::CashflowType
{
    {nlq::NlqProfile.description = 'Type of cashflow corresponding to a scheduled event.'}
    cashflowType: settlement::ScheduledTransferEnum[0..1];
    {nlq::NlqProfile.description = 'priceExpression'}
    priceExpression: observable::PriceExpressionEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Class to specify a mechanism for a quantity to be set as a multiplier to another (reference) quantity, based on a price observation. At the moment ...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::QuantityMultiplier
{
    {nlq::NlqProfile.description = 'multiplierValue', nlq::NlqProfile.unit = 'currency'}
    multiplierValue: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Generic class to specify the quantity for different payout legs in a contractual product, when that quantity can vary across payout legs or across ...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::ResolvablePriceQuantity
{
    {nlq::NlqProfile.description = 'Whether the quantity is resettable'}
    reset: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data type that contains the common attributes (e.g. payer and receiver parties) and validation conditions that apply across all payout types',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PayoutBase
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Defines parameters in which the commodity price is assessed.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::CommodityPriceReturnTerms
{
    {nlq::NlqProfile.description = 'Defines the conversion applied if the quantity unit on contract is different from unit on referenced underlier.'}
    conversionFactor: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Used in conjunction with an exchange-based pricing source. Identifies a way in which the futures contracts referenced will roll between periods.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::RollFeature
{
    {nlq::NlqProfile.description = 'Used in conjunction with an exchange-based pricing source. Identifies a date source calendar from which the pricing d...'}
    rollSourceCalendar: product::RollSourceCalendarEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies specific dates or parametric rules for the dates on which the price will be determined',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PricingDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A single object that represents the different methods to specify a valuation date, as used for cash settlement. The Single / Multiple ValuationDate...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::ValuationDate
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the terms required to compute and settle a cash settlement amount according to a fixing value, including the fixing source, fixing method a...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::CashSettlementTerms
{
    {nlq::NlqProfile.description = 'Specifies the type of cash settlement method: cash price, yield curve etc.'}
    cashSettlementMethod: settlement::CashSettlementMethodEnum[0..1];
    {nlq::NlqProfile.description = 'Used for fixed recovery, specifies the recovery level, determined at contract formation, to be applied on a default. ...'}
    recoveryFactor: Float[0..1];
    {nlq::NlqProfile.description = 'Used for Recovery Lock, to indicate whether fixed Settlement is Applicable or Not Applicable. If Buyer fails to deliv...'}
    fixedSettlement: Boolean[0..1];
    {nlq::NlqProfile.description = 'Indicates whether accrued interest is included (true) or not (false). For cash settlement this specifies whether quot...'}
    accruedInterest: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify all the ISDA terms relevant to defining the deliverable obligations.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::DeliverableObligations
{
    {nlq::NlqProfile.description = 'Indicates whether accrued interest is included (true) or not (false). For cash settlement this specifies whether quot...'}
    accruedInterest: Boolean[0..1];
    {nlq::NlqProfile.description = 'Used in both obligations and deliverable obligations to represent a class or type of securities which apply. ISDA 200...'}
    category: credit::ObligationCategoryEnum[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. An obligation that ranks at least equal with the most senior...'}
    notSubordinated: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Any obligation that is not primarily (majority) owed to a So...'}
    notSovereignLender: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. If the reference entity is a Sovereign, this means any oblig...'}
    notDomesticLaw: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Indicates whether or not the obligation is quoted, listed or...'}
    listed: Boolean[0..1];
    {nlq::NlqProfile.description = 'A deliverable obligation characteristic. In essence Not Contingent means the repayment of principal cannot be dependa...'}
    notContingent: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Any obligation other than an obligation that was intended to...'}
    notDomesticIssuance: Boolean[0..1];
    {nlq::NlqProfile.description = 'A deliverable obligation characteristic. An obligation that is transferable to institutional investors without any co...'}
    transferable: Boolean[0..1];
    {nlq::NlqProfile.description = 'A deliverable obligation characteristic. An obligation at time of default is due to mature and due to be repaid, or a...'}
    acceleratedOrMatured: Boolean[0..1];
    {nlq::NlqProfile.description = 'A deliverable obligation characteristic. Any obligation that is not a bearer instrument. This applies to Bonds only a...'}
    notBearer: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S....'}
    fullFaithAndCreditObLiability: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S....'}
    generalFundObligationLiability: Boolean[0..1];
    {nlq::NlqProfile.description = 'An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S....'}
    revenueObligationLiability: Boolean[0..1];
    {nlq::NlqProfile.description = 'A free format string to specify any excluded obligations or deliverable obligations, as the case may be, of the refer...'}
    excluded: String[0..1];
    {nlq::NlqProfile.description = 'This element is used to specify any other obligations of a reference entity in both obligations and deliverable oblig...'}
    othReferenceEntityObligations: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify loan with a participation agreement whereby the buyer is capable of creating, or procuring the creation of, a contractual right ...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::LoanParticipation
{
    {nlq::NlqProfile.description = 'If Direct Loan Participation is specified as a deliverable obligation characteristic, this specifies any requirements...'}
    qualifyingParticipationSeller: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify the Partial Cash Deliverable Obligation Characteristic.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PCDeliverableObligationCharac
{
    {nlq::NlqProfile.description = 'Indicates whether the provision is applicable.'}
    applicable: Boolean[1];
    {nlq::NlqProfile.description = 'Specifies whether either \'Partial Cash Settlement of Assignable Loans\', \'Partial Cash Settlement of Consent Requir...'}
    partialCashSettlement: Boolean[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'PhysicalSettlementPeriod',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PhysicalSettlementPeriod
{
    {nlq::NlqProfile.description = 'An explicit indication that a number of business days are not specified and therefore ISDA fallback provisions should...'}
    businessDaysNotSpecified: Boolean[0..1];
    {nlq::NlqProfile.description = 'A number of business days. Its precise meaning is dependant on the context in which this element is used. ISDA 2003 T...'}
    businessDays: Integer[0..1];
    {nlq::NlqProfile.description = 'A maximum number of business days. Its precise meaning is dependant on the context in which this element is used. Int...'}
    maximumBusinessDays: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies Physical Settlement Terms characteristics for the settlement of a Credit Default Swap or Option.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PhysicalSettlementTerms
{
    {nlq::NlqProfile.description = 'Specifies whether the swap resulting from physical settlement of the swaption transaction will clear through a cleari...'}
    clearedPhysicalSettlement: Boolean[0..1];
    {nlq::NlqProfile.description = 'Specifies the clearing organization (CCP, DCO) to which the trade should be cleared.'}
    predeterminedClearingOrganizationParty: party::AncillaryRoleEnum[0..1];
    {nlq::NlqProfile.description = 'If this element is specified and set to \'true\', indicates that physical settlement must take place through the use ...'}
    escrow: Boolean[0..1];
    {nlq::NlqProfile.description = 'If this element is specified and set to \'true\', for a transaction documented under the 2003 ISDA Credit Derivatives...'}
    sixtyBusinessDaySettlementCap: Boolean[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class defining a content model for a calculation rule defined as percentage of the notional amount.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PercentageRule
{
    {nlq::NlqProfile.description = 'A percentage of the notional amount.', nlq::NlqProfile.unit = 'percent'}
    paymentPercent: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining the settlement date(s) for cash or physical settlement as either a set of explicit dates, together with applicable adjustments, or ...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::SettlementDate
{
    {nlq::NlqProfile.description = 'The settlement date for a forward settling product. For Foreign Exchange contracts, this represents a common settleme...'}
    valueDate: StrictDate[0..1];
    {nlq::NlqProfile.description = 'The number of business days used in the determination of the cash settlement payment date. If a cash settlement amoun...'}
    cashSettlementBusinessDays: Integer[0..1];
    {nlq::NlqProfile.description = 'Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a ...'}
    paymentDelay: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Extends the Offset structure to specify an FX fixing date as an offset to dates specified somewhere else in the document.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::FxFixingDate
{
    {nlq::NlqProfile.description = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day, as specified by a...'}
    businessDayConvention: datetime::BusinessDayConventionEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the settlement terms, which can either be cash, physical, or fx-based cash-settlement. This class can be used for the settlement of optio...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::SettlementTerms
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A predefined price accorded by the counterparties.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::FixedPrice
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'PaymentDetail',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PaymentDetail
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'This class corresponds to the FpML PaymentDiscounting.model group for representing the discounting elements that can be associated with a payment.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PaymentDiscounting
{
    {nlq::NlqProfile.description = 'The value representing the discount factor used to calculate the present value of the cash flow.'}
    discountFactor: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the payment calculation rule. As of FpML 5.10, percentage rule is the only calculation rule that has been specified as part of the...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PaymentRule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining which principal exchanges occur for the stream.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PrincipalPayments
{
    {nlq::NlqProfile.description = 'A true/false flag to indicate whether there is an initial exchange of principal on the effective date.'}
    initialPayment: Boolean[1];
    {nlq::NlqProfile.description = 'A true/false flag to indicate whether there is a final exchange of principal on the termination date.'}
    finalPayment: Boolean[1];
    {nlq::NlqProfile.description = 'A true/false flag to indicate whether there are intermediate or interim exchanges of principal during the term of the...'}
    intermediatePayment: Boolean[1];
    {nlq::NlqProfile.description = 'Indicate the Payout legs which nominal amount may vary in regards of FX Fixing dates as determined in the product terms.'}
    varyingLegNotionalCurrency: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Describe dates schedules for Principal Exchanges and related role of the parties when known.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PrincipalPaymentSchedule
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Any kind of principal payments when the amount is known and thus fixed.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::PrincipalPayment
{
    {nlq::NlqProfile.description = 'The value representing the discount factor used to calculate the present value of the principal payment amount.'}
    discountFactor: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A base class to be extended by the SettlementTerms class.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::SettlementBase
{
    {nlq::NlqProfile.description = 'Whether the settlement will be cash, physical, by election, ...'}
    settlementType: settlement::SettlementTypeEnum[1];
    {nlq::NlqProfile.description = 'The qualification as to how the transfer will settle, e.g. a DvP settlement.'}
    transferSettlementType: settlement::TransferSettlementEnum[0..1];
    {nlq::NlqProfile.description = 'The settlement currency is to be specified when the Settlement Amount cannot be known in advance. The list of valid c...'}
    settlementCurrency: String[0..1];
    {nlq::NlqProfile.description = 'Optional settlement centre as an enumerated list: Euroclear, Clearstream.'}
    settlementCentre: settlement::SettlementCentreEnum[0..1];
    {nlq::NlqProfile.description = 'Settlement Style.'}
    standardSettlementStyle: settlement::StandardSettlementStyleEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines parameters that regulate a settlement, for instance whether this settlement should be netted with other ones or broken-down into smaller am...',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::SettlementProvision
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the applicable settlement limits that may require a settlement to be \'shaped\', i.e. broken-down into smaller amounts.',
   nlq::NlqProfile.businessDomain = 'Settlement & Delivery',
   nlq::NlqProfile.whenToUse = 'Use for settlement instructions, delivery methods, and cash/physical settlement'}
settlement::ShapingProvision
{
}

// ─── Product Templates (58 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A TransferableProduct is a type of financial product which can be held or transferred, represented as an Asset with the addition of specific Econom...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::TransferableProduct
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This class represents the full set of price-forming features associated with a contractual product: the payout component, the notional/quantity, th...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::EconomicTerms
{
    {nlq::NlqProfile.description = 'The payout specifies the future cashflow computation methodology which characterizes a financial product.'}
    payout: String[1..*];
    {nlq::NlqProfile.description = 'Specifies, when boolean value is True, that additional economic terms exist that have not been included in the produc...'}
    nonStandardisedTerms: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The option payout specification terms. The associated globalKey denotes the ability to associate a hash value to the respective OptionPayout instan...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::OptionPayout
{
    {nlq::NlqProfile.description = 'The financial product underlying the option, which can be of any type including an Asset, Basket, Index or a NonTrans...'}
    underlier: String[1];
    {nlq::NlqProfile.description = 'The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver in...'}
    optionType: template::OptionTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the type of return of a performance payout.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ReturnTerms
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Contains the necessary specifications for all performance payouts, encompassing equity return, dividend, variance, volatility and correlation produ...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::PerformancePayout
{
    {nlq::NlqProfile.description = 'Identifies the underlying product that is referenced for pricing of the applicable leg in a swap.  Referenced in the ...'}
    underlier: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, ...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::PortfolioReturnTerms
{
    {nlq::NlqProfile.description = 'Defines the product that is the subject of a tradable product definition, an underlying product definition, a physica...'}
    underlier: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data type to specify the financial product\'s economic terms, alongside the product identification and product taxonomy. The non-transferable pro...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::NonTransferableProduct
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the price and quantity of a trade lot, where the same product could be traded multiple times with the same counterparty but in different ...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::TradeLot
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Definition of a product as ready to be traded, i.e. included in an execution or contract, by associating a specific price and quantity to this prod...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::TradableProduct
{
    {nlq::NlqProfile.description = 'Specifies the conditions that govern the adjustment to the quantity of a product being traded: e.g. execution, portfo...'}
    adjustment: product::NotionalAdjustmentEnum[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class describing the weight of each of the underlier constituent within the basket, either in absolute or relative terms.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ConstituentWeight
{
    {nlq::NlqProfile.description = 'The number of units (index or securities) that constitute the underlier of the swap. In the case of a basket swap, th...'}
    openUnits: Float[0..1];
    {nlq::NlqProfile.description = 'The relative weight of each respective basket constituent, expressed in percentage. A basket percentage of 5% would b...', nlq::NlqProfile.unit = 'percent'}
    basketPercentage: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a forward settling payout. The underlier attribute captures the underlying payout, which is settled according to the settlementTerms att...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::SettlementPayout
{
    {nlq::NlqProfile.description = 'The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such ...'}
    underlier: String[1];
    {nlq::NlqProfile.description = 'Also called contract month or delivery month. However, it\'s not always a month. It is usually expressed using a code...'}
    deliveryTerm: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class that allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expre...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::CalculationSchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class that defines the period of a schedule. The period contains a set of start and end dates, quantities, fixing, and pricing data.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::SchedulePeriod
{
    {nlq::NlqProfile.description = 'Adjusted payment date.'}
    paymentDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Represents a fixed price payout. There is no underlier associated with this payout type and is based on fixed pricing per a given unit (e.g. in com...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::FixedPricePayout
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the right of a party to cancel a swap transaction on the specified exercise dates. The provision is for \'walk-away\' cancellatio...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::CancelableProvision
{
    {nlq::NlqProfile.description = 'A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephoni...'}
    followUpConfirmation: Boolean[1];
    {nlq::NlqProfile.description = 'The party with right to exercise a cancellation. Allows for buyer, seller or either.'}
    callingParty: template::CallingPartyEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  define the adjusted dates for a cancelable provision on a swap transaction.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::CancelableProvisionAdjustedDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'The adjusted dates for a specific cancellation date, including the adjusted exercise date and adjusted termination date.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::CancellationEvent
{
    {nlq::NlqProfile.description = 'The date on which option exercise takes place. This date should already be adjusted for any applicable business day c...'}
    adjustedExerciseDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The early termination date that is applicable if an early termination provision is exercised. This date should alread...'}
    adjustedEarlyTerminationDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  define the adjusted dates associated with an early termination provision.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::EarlyTerminationEvent
{
    {nlq::NlqProfile.description = 'The date on which option exercise takes place. This date should already be adjusted for any applicable business day c...'}
    adjustedExerciseDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The early termination date that is applicable if an early termination provision is exercised. This date should alread...'}
    adjustedEarlyTerminationDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable ...'}
    adjustedCashSettlementValuationDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable busines...'}
    adjustedCashSettlementPaymentDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business d...'}
    adjustedExerciseFeePaymentDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  an early termination provision for a swap. This early termination is at fair value, i.e. on termination the fair value of the pro...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::EarlyTerminationProvision
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This defines the time interval to the start of the exercise period, i.e. the earliest exercise date, and the frequency of subsequent exercise dates...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExercisePeriod
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  an option to extend an existing swap transaction on the specified exercise dates for a term ending on the specified new terminati...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExtendibleProvision
{
    {nlq::NlqProfile.description = 'A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephoni...'}
    followUpConfirmation: Boolean[0..1];
    {nlq::NlqProfile.description = 'callingParty'}
    callingParty: template::CallingPartyEnum[0..1];
    {nlq::NlqProfile.description = 'A specific date and time for the notice deadline'}
    noticeDeadlineDateTime: DateTime[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the adjusted dates associated with a provision to extend a swap.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExtendibleProvisionAdjustedDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  define the adjusted dates associated with an individual extension event.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExtensionEvent
{
    {nlq::NlqProfile.description = 'The date on which option exercise takes place. This date should already be adjusted for any applicable business day c...'}
    adjustedExerciseDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The termination date if an extendible provision is exercised. This date should already be adjusted for any applicable...'}
    adjustedExtendedTerminationDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data to:  define an early termination provision for which exercise is mandatory.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::MandatoryEarlyTermination
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the adjusted dates associated with a mandatory early termination provision.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::MandatoryEarlyTerminationAdjustedDates
{
    {nlq::NlqProfile.description = 'The early termination date that is applicable if an early termination provision is exercised. This date should alread...'}
    adjustedEarlyTerminationDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable ...'}
    adjustedCashSettlementValuationDate: StrictDate[1];
    {nlq::NlqProfile.description = 'The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable busines...'}
    adjustedCashSettlementPaymentDate: StrictDate[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  an early termination provision where either or both parties have the right to exercise.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::OptionalEarlyTermination
{
    {nlq::NlqProfile.description = 'Used for specifying whether the Mutual Early Termination Right that is detailed in the Master Confirmation will apply.'}
    mutualEarlyTermination: Boolean[0..1];
    {nlq::NlqProfile.description = 'A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephoni...'}
    followUpConfirmation: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A data defining:  the adjusted dates associated with an optional early termination provision.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::OptionalEarlyTerminationAdjustedDates
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'As per ISDA 2002 Definitions.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::AveragingFeature
{
    {nlq::NlqProfile.description = 'averagingInOut'}
    averagingInOut: template::AveragingInOutEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines parameters for use in cases when a valuation or other term is based on an average of market observations.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::AveragingCalculation
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the terms required to calculate the average observations associated with an averaging strike.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::AveragingStrikeFeature
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'As per ISDA 2002 Definitions.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::Barrier
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type for defining a calendar spread feature.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::CalendarSpread
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies the conditions to be applied for converting into a reference currency when the actual currency rate is not determined upfront.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::Composite
{
    {nlq::NlqProfile.description = 'Specifies the method according to which an amount or a date is determined.'}
    determinationMethod: observable::DeterminationMethodEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type for defining FX Features.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::FxFeature
{
    {nlq::NlqProfile.description = 'Specifies the reference currency of the trade.'}
    referenceCurrency: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines additional optional features that can be included in an option contract.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::OptionFeature
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining option provisions.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::TerminationProvision
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the additional features that allow securities to be recalled by the lender before the term of the loan. A recall is not the same as an earl...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::RecallProvision
{
    {nlq::NlqProfile.description = 'Whether the securities on loan can be recalled by the lender.'}
    isRecallable: Boolean[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines the strike price of an option.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::OptionStrike
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Type which contains pass through payments.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::PassThrough
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Class to represent a single pass through payment.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::PassThroughItem
{
    {nlq::NlqProfile.description = 'Percentage of payments from the underlier which are passed through.', nlq::NlqProfile.unit = 'percent'}
    passThroughPercentage: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Determines the currency rate that the seller of the equity amounts will apply at each valuation date for converting the respective amounts into a c...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::Quanto
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class for defining option strategy features.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::StrategyFeature
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class for defining a strike spread feature.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::StrikeSpread
{
    {nlq::NlqProfile.description = 'Number of options at the upper strike price in a strike spread.', nlq::NlqProfile.unit = 'currency'}
    upperStrikeNumberOfOptions: Float[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining the exercise period for an option together with any rules governing the notional amount of the underlying which can be exercised o...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExerciseTerms
{
    {nlq::NlqProfile.description = 'Whether the option has a single exercise (european), multiple exercise dates (bermuda), or a continuous range of exer...'}
    style: template::OptionExerciseStyleEnum[0..1];
    {nlq::NlqProfile.description = 'The time of day at which the equity option expires, for example the official closing time of the exchange.'}
    expirationTimeType: template::ExpirationTimeTypeEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A type to define automatic exercise of a swaption. With automatic exercise the option is deemed to have exercised if it is in the money by more tha...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::AutomaticExercise
{
    {nlq::NlqProfile.description = 'A threshold rate. The threshold of 0.10% would be represented as 0.001', nlq::NlqProfile.unit = 'percent'}
    thresholdRate: Float[0..1];
    {nlq::NlqProfile.description = 'Boolean that indicates if it has an automaticExercise'}
    isApplicable: Boolean[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class defining the fee payable on exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a dif...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExerciseFee
{
    {nlq::NlqProfile.description = 'The amount of fee to be paid on exercise. The fee currency is that of the referenced notional.', nlq::NlqProfile.unit = 'currency'}
    feeAmount: Float[0..1];
    {nlq::NlqProfile.description = 'A fee represented as a percentage of some referenced notional. A percentage of 5% would be represented as 0.05.', nlq::NlqProfile.unit = 'currency'}
    feeRate: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to define a fee or schedule of fees to be payable on the exercise of an option. This fee may be defined as an amount or a percentage of the...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExerciseFeeSchedule
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines to whom and where notice of execution should be given. The exerciseNoticeGiver refers to one or both of the principal parties of the trade....',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExerciseNotice
{
    {nlq::NlqProfile.description = 'Specifies the principal party of the trade that has the right to exercise.'}
    exerciseNoticeGiver: template::ExerciseNoticeGiverEnum[1];
    {nlq::NlqProfile.description = 'Specifies the party to which notice of exercise should be given, e.g. by the buyer of the option. Although in many ca...'}
    exerciseNoticeReceiver: party::AncillaryRoleEnum[0..1];
    {nlq::NlqProfile.description = 'Specifies the location where the exercise must be reported, e.g. where the exercise notice receiver is based.'}
    businessCenter: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class describing how notice of exercise should be given. This can be either manual or automatic.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ExerciseProcedure
{
    {nlq::NlqProfile.description = 'A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephoni...'}
    followUpConfirmation: Boolean[1];
    {nlq::NlqProfile.description = 'Has the meaning defined as part of the 1997 ISDA Government Bond Option Definitions, section 4.5 Limited Right to Con...'}
    limitedRightToConfirm: Boolean[0..1];
    {nlq::NlqProfile.description = 'Typically applicable to the physical settlement of bond and convertible bond options. If present, means that the part...'}
    splitTicket: Boolean[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class defining manual exercise, i.e. that the option buyer counterparty must give notice to the option seller of exercise.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::ManualExercise
{
    {nlq::NlqProfile.description = 'If fallback exercise is specified then the notional amount of the underlying swap, not previously exercised under the...'}
    fallbackExercise: Boolean[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class defining multiple exercises. As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the righ...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::MultipleExercise
{
    {nlq::NlqProfile.description = 'The maximum notional amount that can be exercised on a given exercise date.', nlq::NlqProfile.unit = 'currency'}
    maximumNotionalAmount: Float[0..1];
    {nlq::NlqProfile.description = 'The maximum number of options that can be exercised on a given exercise date. If the number is not specified, it mean...'}
    maximumNumberOfOptions: Integer[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class defining partial exercise. As defined in the 2000 ISDA Definitions, Section 12.3 Partial Exercise, the buyer of the option may exercise all...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::PartialExercise
{
    {nlq::NlqProfile.description = 'A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exer...', nlq::NlqProfile.unit = 'currency'}
    integralMultipleAmount: Float[0..1];
    {nlq::NlqProfile.description = 'The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.', nlq::NlqProfile.unit = 'currency'}
    minimumNotionalAmount: Float[0..1];
    {nlq::NlqProfile.description = 'The minimum number of options that can be exercised on a given exercise date.'}
    minimumNumberOfOptions: Integer[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class describing a single cap or floor rate.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::Strike
{
    {nlq::NlqProfile.description = 'The rate for a cap or floor.', nlq::NlqProfile.unit = 'currency'}
    strikeRate: Float[1];
    {nlq::NlqProfile.description = 'The buyer of the option.'}
    buyer: party::PayerReceiverEnum[0..1];
    {nlq::NlqProfile.description = 'The party that has sold.'}
    seller: party::PayerReceiverEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class describing a schedule of cap or floor rates.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::StrikeSchedule
{
    {nlq::NlqProfile.description = 'The buyer of the option.'}
    buyer: party::PayerReceiverEnum[0..1];
    {nlq::NlqProfile.description = 'The party that has sold.'}
    seller: party::PayerReceiverEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Security finance payout specification in case the product payout involves some form of security collateral, as in a securities financing transactio...',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::AssetPayout
{
    {nlq::NlqProfile.description = 'Specifies the Purchased Asset, usually a Security.'}
    underlier: String[1];
    {nlq::NlqProfile.description = 'The trade type, eg repurchase transaction or buy/sell-back.'}
    tradeType: template::AssetPayoutTradeTypeEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Information related to dividends and payments.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::DividendTerms
{
    {nlq::NlqProfile.description = 'Defines the date on which the receiver of the equity return is entitled to the dividend.'}
    dividendEntitlement: product::DividendEntitlementEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Defines each asset movement of an asset payout.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::AssetLeg
{
    {nlq::NlqProfile.description = 'Specifies a delivery method for the security transaction.'}
    deliveryMethod: settlement::DeliveryMethodEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies a transaction which automatically extends for a specified timeframe until the exercise of an embedded option.',
   nlq::NlqProfile.businessDomain = 'Product Templates',
   nlq::NlqProfile.whenToUse = 'Use for product templates, economic terms, and transferable product definitions'}
template::EvergreenProvision
{
    {nlq::NlqProfile.description = 'A specific date and time for the notice deadline'}
    noticeDeadlineDateTime: DateTime[0..1];
}

// ─── Workflow & Processing (15 types) ───

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to represent the credit limit utilisation information.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::CreditLimitInformation
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Credit limit utilisation breakdown by executed trades and pending orders.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::CreditLimitUtilisation
{
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'CreditLimitUtilisationPosition',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::CreditLimitUtilisationPosition
{
    {nlq::NlqProfile.description = 'Credit limit utilisation attributable to short positions.'}
    shortPosition: Float[0..1];
    {nlq::NlqProfile.description = 'Credit limit utilisation attributable to long positions.'}
    longPosition: Float[0..1];
    {nlq::NlqProfile.description = 'Global credit limit utilisation amount, agnostic of long/short position direction.'}
    global: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'In its initial iteration, this class is meant to support the DTCC TIW workflow information.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::CustomisedWorkflow
{
    {nlq::NlqProfile.description = 'In this initial iteration, this corresponds to the DTCC TIW element name.'}
    itemName: String[1];
    {nlq::NlqProfile.description = 'In this initial iteration, this corresponds to the DTCC value.'}
    itemValue: String[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Party approvals associated to the current WorkflowStep.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::WorkflowStepApproval
{
    {nlq::NlqProfile.description = 'Flag denoting whether the workflow step is approved or not'}
    approved: Boolean[1];
    {nlq::NlqProfile.description = 'Optional reason for rejecting the workflow step'}
    rejectedReason: String[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A workflow step represents the state of a business event. The workflow step contains a reference to a previous WorkflowStep in order to preserve li...',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::WorkflowStep
{
    {nlq::NlqProfile.description = 'Flags this step as rejected.'}
    rejected: Boolean[0..1];
    {nlq::NlqProfile.description = 'Specifies whether the event is a new, a correction or a cancellation.'}
    action: event::ActionEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A collection of workflow steps which together make up an entire workflow sequence.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::Workflow
{
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'Specifies instructions to create a BusinessEvent.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::EventInstruction
{
    {nlq::NlqProfile.description = 'The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from t...'}
    intent: event::EventIntentEnum[0..1];
    {nlq::NlqProfile.description = 'corporateActionIntent'}
    corporateActionIntent: event::CorporateActionTypeEnum[0..1];
    {nlq::NlqProfile.description = 'The date on which the event contractually takes effect, when different from the event date.'}
    effectiveDate: StrictDate[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to represent the various set of timestamps that can be associated with lifecycle events, as a collection of [dateTime, qualifier].',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::EventTimestamp
{
    {nlq::NlqProfile.description = 'The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset...'}
    dateTime: DateTime[1];
    {nlq::NlqProfile.description = 'The timestamp qualifier is specified through an enumeration because the experience of integrating the DTCC and CME da...'}
    qualification: workflow::EventTimestampQualificationEnum[1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify workflow information, which is conceptually applicable to all lifecycle events.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::WorkflowState
{
    {nlq::NlqProfile.description = 'The workflow status indicator, e.g. Accepted, Rejected, ...'}
    workflowStatus: workflow::WorkflowStatusEnum[1];
    {nlq::NlqProfile.description = 'A comment field to be associated with the workflow, e.g. to specify why a transaction event was rejected by a party.'}
    comment: String[0..1];
    {nlq::NlqProfile.description = 'The identity of the warehouse, if any, that is executing that workflow step.'}
    warehouseIdentity: workflow::WarehouseIdentityEnum[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'LimitApplicable',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::LimitApplicable
{
    {nlq::NlqProfile.description = 'Standard code to indicate which type of credit line is being referred to - i.e. IM, DV01, PV01, CS01, Notional, Clip ...'}
    limitType: workflow::CreditLimitTypeEnum[0..1];
    {nlq::NlqProfile.description = 'This element is required in FpML, optional in CDM for the purpose of accommodating the CME data representation while ...'}
    clipSize: Integer[0..1];
    {nlq::NlqProfile.description = 'The limit utilised by all the cleared trades for the limit level and limit type. While the attribute is of type integ...', nlq::NlqProfile.unit = 'currency'}
    amountUtilized: Float[0..1];
    {nlq::NlqProfile.description = 'The currency in which the applicable limit is denominated. The list of valid currencies is not presently positioned a...'}
    currency: String[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'A class to represent the CDM attributes that are not part of the FpML standard. Once broader usage is confirmed, it is expected that those two clas...',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::LimitApplicableExtended
{
    {nlq::NlqProfile.description = 'The level at which the limit is set: customer business, proprietary business or account level. This attribute is spec...'}
    limitLevel: workflow::LimitLevelEnum[0..1];
    {nlq::NlqProfile.description = 'The total limit available for the limit level and limit type. While the attribute is of type integer in the CME schem...', nlq::NlqProfile.unit = 'currency'}
    limitAmount: Float[0..1];
    {nlq::NlqProfile.description = 'The limit utilized by this specific trade. While the attribute is of type integer in the CME schema, it has been spec...'}
    limitImpactDueToTrade: Float[0..1];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'This class corresponds to the components of the FpML MessageHeader.model.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::MessageInformation
{
    {nlq::NlqProfile.description = 'A unique identifier assigned to the message.'}
    messageId: String[1];
    {nlq::NlqProfile.description = 'The identifier for the originator of a message instance.'}
    sentBy: String[0..1];
    {nlq::NlqProfile.description = 'The identifier(s) for the recipient(s) of a message instance.'}
    sentTo: String[*];
    {nlq::NlqProfile.description = 'A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this mess...'}
    copyTo: String[*];
}

Class <<nlq::NlqProfile.dimension>>
  {nlq::NlqProfile.description = 'A class to specify a party-related, non-standardized data in a generic form.',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::PartyCustomisedWorkflow
{
    {nlq::NlqProfile.description = 'The party name to which the workflow pertains to.'}
    partyName: String[0..1];
}

Class <<nlq::NlqProfile.metric>>
  {nlq::NlqProfile.description = 'Velocity',
   nlq::NlqProfile.businessDomain = 'Workflow & Processing',
   nlq::NlqProfile.whenToUse = 'Use for workflow steps, event timestamps, message headers, and processing states'}
workflow::Velocity
{
    {nlq::NlqProfile.description = 'periodMultiplier'}
    periodMultiplier: Integer[0..1];
}

// ═══════════════════════════════════════════════════════════
// Associations — derived from Rosetta type references
// ═══════════════════════════════════════════════════════════

Association cdm_assoc::AssetBase_AssetIdentifier_identifier
{
    assetBase: asset::AssetBase[*];
    identifier: asset::AssetIdentifier[*];
}

Association cdm_assoc::AssetBase_Taxonomy_taxonomy
{
    assetBase: asset::AssetBase[*];
    taxonomy: asset::Taxonomy[*];
}

Association cdm_assoc::AssetBase_LegalEntity_exchange
{
    assetBase: asset::AssetBase[*];
    exchange: party::LegalEntity[*];
}

Association cdm_assoc::AssetBase_LegalEntity_relatedExchange
{
    assetBase: asset::AssetBase[*];
    relatedExchange: party::LegalEntity[*];
}

Association cdm_assoc::TaxonomyValue_TaxonomyClassification_classification
{
    taxonomyValue: asset::TaxonomyValue[*];
    classification: asset::TaxonomyClassification[*];
}

Association cdm_assoc::Taxonomy_TaxonomyValue_value
{
    taxonomy: asset::Taxonomy[*];
    value: asset::TaxonomyValue[*];
}

Association cdm_assoc::Commodity_CommodityProductDefinition_commodityProductDefinition
{
    commodity: asset::Commodity[*];
    commodityProductDefinition: asset::CommodityProductDefinition[*];
}

Association cdm_assoc::CommodityProductDefinition_CommodityReferenceFramework_referenceFramework
{
    commodityProductDefinition: asset::CommodityProductDefinition[*];
    referenceFramework: asset::CommodityReferenceFramework[*];
}

Association cdm_assoc::CommodityProductDefinition_PriceSource_priceSource
{
    commodityProductDefinition: asset::CommodityProductDefinition[*];
    priceSource: asset::PriceSource[*];
}

Association cdm_assoc::Loan_LegalEntity_borrower
{
    loan: asset::Loan[*];
    borrower: party::LegalEntity[*];
}

Association cdm_assoc::CollateralTaxonomy_CollateralTaxonomyValue_taxonomyValue
{
    collateralTaxonomy: asset::CollateralTaxonomy[*];
    taxonomyValue: asset::CollateralTaxonomyValue[*];
}

Association cdm_assoc::Security_DebtType_debtType
{
    security: asset::Security[*];
    debtType: asset::DebtType[*];
}

Association cdm_assoc::Security_EquityType_equityType
{
    security: asset::Security[*];
    equityType: asset::EquityType[*];
}

Association cdm_assoc::DebtType_DebtEconomics_debtEconomics
{
    debtType: asset::DebtType[*];
    debtEconomics: asset::DebtEconomics[*];
}

Association cdm_assoc::DebtEconomics_SecuredDebt_secured
{
    debtEconomics: asset::DebtEconomics[*];
    secured: asset::SecuredDebt[*];
}

Association cdm_assoc::DebtEconomics_DebtRedemption_redemption
{
    debtEconomics: asset::DebtEconomics[*];
    redemption: asset::DebtRedemption[*];
}

Association cdm_assoc::CollateralIssuerType_QuasiGovernmentIssuerType_quasiGovernmentType
{
    collateralIssuerType: asset::CollateralIssuerType[*];
    quasiGovernmentType: asset::QuasiGovernmentIssuerType[*];
}

Association cdm_assoc::CollateralIssuerType_RegionalGovernmentIssuerType_regionalGovernmentType
{
    collateralIssuerType: asset::CollateralIssuerType[*];
    regionalGovernmentType: asset::RegionalGovernmentIssuerType[*];
}

Association cdm_assoc::CollateralIssuerType_SpecialPurposeVehicleIssuerType_specialPurposeVehicleType
{
    collateralIssuerType: asset::CollateralIssuerType[*];
    specialPurposeVehicleType: asset::SpecialPurposeVehicleIssuerType[*];
}

Association cdm_assoc::AssetType_DebtType_debtType
{
    assetType: asset::AssetType[*];
    debtType: asset::DebtType[*];
}

Association cdm_assoc::AssetType_EquityType_equityType
{
    assetType: asset::AssetType[*];
    equityType: asset::EquityType[*];
}

Association cdm_assoc::CodeList_CodeListIdentification_identification
{
    codeList: codelist::CodeList[*];
    identification: codelist::CodeListIdentification[*];
}

Association cdm_assoc::CodeList_CodeValue_codes
{
    codeList: codelist::CodeList[*];
    codes: codelist::CodeValue[*];
}

Association cdm_assoc::EligibilityQuery_AssetType_collateralAssetType
{
    eligibilityQuery: collateral::EligibilityQuery[*];
    collateralAssetType: asset::AssetType[*];
}

Association cdm_assoc::EligibilityQuery_AgencyRatingCriteria_agencyRating
{
    eligibilityQuery: collateral::EligibilityQuery[*];
    agencyRating: collateral::AgencyRatingCriteria[*];
}

Association cdm_assoc::EligibilityQuery_CollateralIssuerType_issuerType
{
    eligibilityQuery: collateral::EligibilityQuery[*];
    issuerType: asset::CollateralIssuerType[*];
}

Association cdm_assoc::EligibilityQuery_LegalEntity_issuerName
{
    eligibilityQuery: collateral::EligibilityQuery[*];
    issuerName: party::LegalEntity[*];
}

Association cdm_assoc::CheckEligibilityResult_EligibleCollateralCriteria_matchingEligibleCriteria
{
    checkEligibilityResult: collateral::CheckEligibilityResult[*];
    matchingEligibleCriteria: collateral::EligibleCollateralCriteria[*];
}

Association cdm_assoc::CheckEligibilityResult_EligibilityQuery_eligibilityQuery
{
    checkEligibilityResult: collateral::CheckEligibilityResult[*];
    eligibilityQuery: collateral::EligibilityQuery[*];
}

Association cdm_assoc::CheckEligibilityResult_EligibleCollateralSpecification_specification
{
    checkEligibilityResult: collateral::CheckEligibilityResult[*];
    specification: collateral::EligibleCollateralSpecification[*];
}

Association cdm_assoc::Collateral_IndependentAmount_independentAmount
{
    collateral: collateral::Collateral[*];
    independentAmount: collateral::IndependentAmount[*];
}

Association cdm_assoc::Collateral_Identifier_portfolioIdentifier
{
    collateral: collateral::Collateral[*];
    portfolioIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::Collateral_CollateralPortfolio_collateralPortfolio
{
    collateral: collateral::Collateral[*];
    collateralPortfolio: event::CollateralPortfolio[*];
}

Association cdm_assoc::Collateral_CollateralProvisions_collateralProvisions
{
    collateral: collateral::Collateral[*];
    collateralProvisions: collateral::CollateralProvisions[*];
}

Association cdm_assoc::CollateralProvisions_EligibleCollateralCriteria_eligibleCollateral
{
    collateralProvisions: collateral::CollateralProvisions[*];
    eligibleCollateral: collateral::EligibleCollateralCriteria[*];
}

Association cdm_assoc::CollateralProvisions_SubstitutionProvisions_substitutionProvisions
{
    collateralProvisions: collateral::CollateralProvisions[*];
    substitutionProvisions: collateral::SubstitutionProvisions[*];
}

Association cdm_assoc::SubstitutionProvisions_Period_noticeDeadlinePeriod
{
    substitutionProvisions: collateral::SubstitutionProvisions[*];
    noticeDeadlinePeriod: datetime::Period[*];
}

Association cdm_assoc::IndependentAmount_PaymentDetail_paymentDetail
{
    independentAmount: collateral::IndependentAmount[*];
    paymentDetail: settlement::PaymentDetail[*];
}

Association cdm_assoc::AgencyRatingCriteria_CreditNotation_creditNotation
{
    agencyRatingCriteria: collateral::AgencyRatingCriteria[*];
    creditNotation: observable::CreditNotation[*];
}

Association cdm_assoc::EligibleCollateralSpecification_Identifier_identifier
{
    eligibleCollateralSpecification: collateral::EligibleCollateralSpecification[*];
    identifier: identifier::Identifier[*];
}

Association cdm_assoc::EligibleCollateralSpecification_Party_party
{
    eligibleCollateralSpecification: collateral::EligibleCollateralSpecification[*];
    party: party::Party[*];
}

Association cdm_assoc::EligibleCollateralSpecification_Counterparty_counterparty
{
    eligibleCollateralSpecification: collateral::EligibleCollateralSpecification[*];
    counterparty: party::Counterparty[*];
}

Association cdm_assoc::EligibleCollateralSpecification_EligibleCollateralCriteria_criteria
{
    eligibleCollateralSpecification: collateral::EligibleCollateralSpecification[*];
    criteria: collateral::EligibleCollateralCriteria[*];
}

Association cdm_assoc::EligibleCollateralSpecification_PartyRole_partyRole
{
    eligibleCollateralSpecification: collateral::EligibleCollateralSpecification[*];
    partyRole: party::PartyRole[*];
}

Association cdm_assoc::EligibleCollateralCriteria_CollateralTreatment_treatment
{
    eligibleCollateralCriteria: collateral::EligibleCollateralCriteria[*];
    treatment: collateral::CollateralTreatment[*];
}

Association cdm_assoc::CollateralTreatment_CollateralValuationTreatment_valuationTreatment
{
    collateralTreatment: collateral::CollateralTreatment[*];
    valuationTreatment: collateral::CollateralValuationTreatment[*];
}

Association cdm_assoc::CollateralTreatment_ConcentrationLimit_concentrationLimit
{
    collateralTreatment: collateral::CollateralTreatment[*];
    concentrationLimit: collateral::ConcentrationLimit[*];
}

Association cdm_assoc::ConcentrationLimit_ConcentrationLimitCriteria_concentrationLimitCriteria
{
    concentrationLimit: collateral::ConcentrationLimit[*];
    concentrationLimitCriteria: collateral::ConcentrationLimitCriteria[*];
}

Association cdm_assoc::ConcentrationLimit_MoneyRange_valueLimit
{
    concentrationLimit: collateral::ConcentrationLimit[*];
    valueLimit: math::MoneyRange[*];
}

Association cdm_assoc::ConcentrationLimit_NumberRange_percentageLimit
{
    concentrationLimit: collateral::ConcentrationLimit[*];
    percentageLimit: math::NumberRange[*];
}

Association cdm_assoc::ConcentrationLimitCriteria_AverageTradingVolume_averageTradingVolume
{
    concentrationLimitCriteria: collateral::ConcentrationLimitCriteria[*];
    averageTradingVolume: collateral::AverageTradingVolume[*];
}

Association cdm_assoc::AverageTradingVolume_Period_period
{
    averageTradingVolume: collateral::AverageTradingVolume[*];
    period: datetime::Period[*];
}

Association cdm_assoc::IssuerName_LegalEntity_issuerName
{
    issuerName: collateral::IssuerName[*];
    issuerName: party::LegalEntity[*];
}

Association cdm_assoc::IssuerAgencyRating_AgencyRatingCriteria_issuerAgencyRating
{
    issuerAgencyRating: collateral::IssuerAgencyRating[*];
    issuerAgencyRating: collateral::AgencyRatingCriteria[*];
}

Association cdm_assoc::SovereignAgencyRating_AgencyRatingCriteria_sovereignAgencyRating
{
    sovereignAgencyRating: collateral::SovereignAgencyRating[*];
    sovereignAgencyRating: collateral::AgencyRatingCriteria[*];
}

Association cdm_assoc::AssetAgencyRating_AgencyRatingCriteria_assetAgencyRating
{
    assetAgencyRating: collateral::AssetAgencyRating[*];
    assetAgencyRating: collateral::AgencyRatingCriteria[*];
}

Association cdm_assoc::AssetMaturity_PeriodRange_maturityRange
{
    assetMaturity: collateral::AssetMaturity[*];
    maturityRange: datetime::PeriodRange[*];
}

Association cdm_assoc::DistributionAndInterestPayment_CollateralInterestParameters_interestParameters
{
    distributionAndInterestPayment: collateral::DistributionAndInterestPayment[*];
    interestParameters: collateral::CollateralInterestParameters[*];
}

Association cdm_assoc::CollateralInterestParameters_CollateralInterestCalculationParameters_interestCalculationParameters
{
    collateralInterestParameters: collateral::CollateralInterestParameters[*];
    interestCalculationParameters: collateral::CollateralInterestCalculationParameters[*];
}

Association cdm_assoc::CollateralInterestParameters_CalculationFrequency_interestCalculationFrequency
{
    collateralInterestParameters: collateral::CollateralInterestParameters[*];
    interestCalculationFrequency: datetime::CalculationFrequency[*];
}

Association cdm_assoc::CollateralInterestParameters_CollateralInterestHandlingParameters_interestHandlingParameters
{
    collateralInterestParameters: collateral::CollateralInterestParameters[*];
    interestHandlingParameters: collateral::CollateralInterestHandlingParameters[*];
}

Association cdm_assoc::CollateralInterestCalculationParameters_CollateralAgreementFloatingRate_floatingRate
{
    collateralInterestCalculationParameters: collateral::CollateralInterestCalculationParameters[*];
    floatingRate: collateral::CollateralAgreementFloatingRate[*];
}

Association cdm_assoc::CollateralInterestCalculationParameters_Rounding_rounding
{
    collateralInterestCalculationParameters: collateral::CollateralInterestCalculationParameters[*];
    rounding: math::Rounding[*];
}

Association cdm_assoc::CollateralInterestHandlingParameters_InterestAmountApplication_interestAmountApplication
{
    collateralInterestHandlingParameters: collateral::CollateralInterestHandlingParameters[*];
    interestAmountApplication: collateral::InterestAmountApplication[*];
}

Association cdm_assoc::CollateralInterestHandlingParameters_NumberBound_interestRolloverLimit
{
    collateralInterestHandlingParameters: collateral::CollateralInterestHandlingParameters[*];
    interestRolloverLimit: math::NumberBound[*];
}

Association cdm_assoc::CollateralInterestHandlingParameters_NumberBound_writeoffLimit
{
    collateralInterestHandlingParameters: collateral::CollateralInterestHandlingParameters[*];
    writeoffLimit: math::NumberBound[*];
}

Association cdm_assoc::CollateralInterestHandlingParameters_CollateralInterestNotification_notification
{
    collateralInterestHandlingParameters: collateral::CollateralInterestHandlingParameters[*];
    notification: collateral::CollateralInterestNotification[*];
}

Association cdm_assoc::InterestAmountApplication_ReturnAmount_returnAmount
{
    interestAmountApplication: collateral::InterestAmountApplication[*];
    returnAmount: collateral::ReturnAmount[*];
}

Association cdm_assoc::InterestAmountApplication_DeliveryAmount_deliveryAmount
{
    interestAmountApplication: collateral::InterestAmountApplication[*];
    deliveryAmount: collateral::DeliveryAmount[*];
}

Association cdm_assoc::Obligations_SpecifiedCurrency_specifiedCurrency
{
    obligations: credit::Obligations[*];
    specifiedCurrency: credit::SpecifiedCurrency[*];
}

Association cdm_assoc::Obligations_NotDomesticCurrency_notDomesticCurrency
{
    obligations: credit::Obligations[*];
    notDomesticCurrency: credit::NotDomesticCurrency[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_Regime_regime
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    regime: csa::Regime[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_OneWayProvisions_oneWayProvisions
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    oneWayProvisions: csa::OneWayProvisions[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_GeneralSimmElections_generalSimmElections
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    generalSimmElections: csa::GeneralSimmElections[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_SensitivityMethodologies_sensitivityMethodologies
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    sensitivityMethodologies: csa::SensitivityMethodologies[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_FxHaircutCurrency_fxHaircutCurrency
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    fxHaircutCurrency: csa::FxHaircutCurrency[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_PostingObligations_postingObligations
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    postingObligations: csa::PostingObligations[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_SubstitutedRegime_substitutedRegime
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    substitutedRegime: csa::SubstitutedRegime[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_CoveredTransactions_coveredTransactions
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    coveredTransactions: csa::CoveredTransactions[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_RightsEvents_rightsEvents
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    rightsEvents: csa::RightsEvents[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_CustodyArrangements_custodyArrangements
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    custodyArrangements: csa::CustodyArrangements[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_OtherAgreements_otherAgreements
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    otherAgreements: csa::OtherAgreements[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_TerminationCurrencyAmendment_terminationCurrencyAmendment
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    terminationCurrencyAmendment: csa::TerminationCurrencyAmendment[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_MinimumTransferAmountAmendment_minimumTransferAmountAmendment
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    minimumTransferAmountAmendment: csa::MinimumTransferAmountAmendment[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_ProcessAgent_processAgent
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    processAgent: csa::ProcessAgent[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_AppropriatedCollateralValuation_appropriatedCollateralValuation
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    appropriatedCollateralValuation: csa::AppropriatedCollateralValuation[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_JurisdictionRelatedTerms_jurisdictionRelatedTerms
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    jurisdictionRelatedTerms: csa::JurisdictionRelatedTerms[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_CreditSupportObligationsInitialMargin_creditSupportObligations
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    creditSupportObligations: csa::CreditSupportObligationsInitialMargin[*];
}

Association cdm_assoc::CreditSupportAgreementInitialMarginElections_CalculationAndTimingInitialMargin_calculationAndTiming
{
    creditSupportAgreementInitialMarginElections: csa::CreditSupportAgreementInitialMarginElections[*];
    calculationAndTiming: csa::CalculationAndTimingInitialMargin[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_FxHaircutCurrency_fxHaircutCurrency
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    fxHaircutCurrency: csa::FxHaircutCurrency[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_CoveredTransactions_coveredTransactions
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    coveredTransactions: csa::CoveredTransactions[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_CustodyArrangements_custodyArrangements
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    custodyArrangements: csa::CustodyArrangements[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_AddressesForTransfer_addressesForTransfer
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    addressesForTransfer: csa::AddressesForTransfer[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_OtherAgreements_otherAgreements
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    otherAgreements: csa::OtherAgreements[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_SecurityInterestForObligations_securityInterestForObligations
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    securityInterestForObligations: csa::SecurityInterestForObligations[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_CreditSupportObligationsVariationMargin_creditSupportObligations
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    creditSupportObligations: csa::CreditSupportObligationsVariationMargin[*];
}

Association cdm_assoc::CreditSupportAgreementVariationMarginElections_CalculationAndTimingVariationMargin_calculationAndTiming
{
    creditSupportAgreementVariationMarginElections: csa::CreditSupportAgreementVariationMarginElections[*];
    calculationAndTiming: csa::CalculationAndTimingVariationMargin[*];
}

Association cdm_assoc::CreditSupportAgreementLegacyElections_AddressesForTransfer_addressesForTransfer
{
    creditSupportAgreementLegacyElections: csa::CreditSupportAgreementLegacyElections[*];
    addressesForTransfer: csa::AddressesForTransfer[*];
}

Association cdm_assoc::CreditSupportAgreementLegacyElections_SecurityInterestForObligations_securityInterestForObligations
{
    creditSupportAgreementLegacyElections: csa::CreditSupportAgreementLegacyElections[*];
    securityInterestForObligations: csa::SecurityInterestForObligations[*];
}

Association cdm_assoc::CreditSupportAgreementLegacyElections_SinglePostingParty_singlePostingParty
{
    creditSupportAgreementLegacyElections: csa::CreditSupportAgreementLegacyElections[*];
    singlePostingParty: csa::SinglePostingParty[*];
}

Association cdm_assoc::CreditSupportAgreementLegacyElections_CreditSupportObligationsLegacy_creditSupportObligations
{
    creditSupportAgreementLegacyElections: csa::CreditSupportAgreementLegacyElections[*];
    creditSupportObligations: csa::CreditSupportObligationsLegacy[*];
}

Association cdm_assoc::CreditSupportAgreementLegacyElections_CalculationAndTimingLegacy_calculationAndTiming
{
    creditSupportAgreementLegacyElections: csa::CreditSupportAgreementLegacyElections[*];
    calculationAndTiming: csa::CalculationAndTimingLegacy[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_BaseAndEligibleCurrency_baseAndEligibleCurrency
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    baseAndEligibleCurrency: csa::BaseAndEligibleCurrency[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_ConditionsPrecedent_conditionsPrecedent
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    conditionsPrecedent: csa::ConditionsPrecedent[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_Substitution_substitution
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    substitution: csa::Substitution[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_DisputeResolution_disputeResolution
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    disputeResolution: csa::DisputeResolution[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_HoldingAndUsingPostedCollateral_holdingAndUsingPostedCollateral
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    holdingAndUsingPostedCollateral: csa::HoldingAndUsingPostedCollateral[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_DistributionAndInterestPayment_distributionAndInterestPayment
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    distributionAndInterestPayment: collateral::DistributionAndInterestPayment[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_OtherEligibleAndPostedSupport_otherEligibleAndPostedSupport
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    otherEligibleAndPostedSupport: csa::OtherEligibleAndPostedSupport[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_DemandsAndNotices_demandsAndNotices
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    demandsAndNotices: csa::DemandsAndNotices[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_AdditionalRepresentations_additionalRepresentations
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    additionalRepresentations: csa::AdditionalRepresentations[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_MasterAgreementDatedAsOfDate_masterAgreementDatedAsOfDate
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    masterAgreementDatedAsOfDate: csa::MasterAgreementDatedAsOfDate[*];
}

Association cdm_assoc::CreditSupportAgreementElectionsBase_FinalReturns_finalReturns
{
    creditSupportAgreementElectionsBase: csa::CreditSupportAgreementElectionsBase[*];
    finalReturns: csa::FinalReturns[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_Regime_regime
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    regime: csa::Regime[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_OneWayProvisions_oneWayProvisions
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    oneWayProvisions: csa::OneWayProvisions[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_GeneralSimmElections_generalSimmElections
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    generalSimmElections: csa::GeneralSimmElections[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_SensitivityMethodologies_sensitivityMethodologies
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    sensitivityMethodologies: csa::SensitivityMethodologies[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_FxHaircutCurrency_fxHaircutCurrency
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    fxHaircutCurrency: csa::FxHaircutCurrency[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_PostingObligations_postingObligations
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    postingObligations: csa::PostingObligations[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_SubstitutedRegime_substitutedRegime
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    substitutedRegime: csa::SubstitutedRegime[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_BaseAndEligibleCurrency_baseAndEligibleCurrency
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    baseAndEligibleCurrency: csa::BaseAndEligibleCurrency[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_CreditSupportObligationsCollateralTransferAgreement_creditSupportObligations
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    creditSupportObligations: csa::CreditSupportObligationsCollateralTransferAgreement[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_CalculationAndTimingCollateralTransferAgreement_calculationAndTiming
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    calculationAndTiming: csa::CalculationAndTimingCollateralTransferAgreement[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_ConditionsPrecedent_conditionsPrecedent
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    conditionsPrecedent: csa::ConditionsPrecedent[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_Substitution_substitution
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    substitution: csa::Substitution[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_DisputeResolution_disputeResolution
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    disputeResolution: csa::DisputeResolution[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_RightsEvents_rightsEvents
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    rightsEvents: csa::RightsEvents[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_CustodyArrangements_custodyArrangements
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    custodyArrangements: csa::CustodyArrangements[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_AdditionalRepresentations_additionalRepresentations
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    additionalRepresentations: csa::AdditionalRepresentations[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_DemandsAndNotices_demandsAndNotices
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    demandsAndNotices: csa::DemandsAndNotices[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_AddressesForTransfer_addressesForTransfer
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    addressesForTransfer: csa::AddressesForTransfer[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_OtherAgreements_otherAgreements
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    otherAgreements: csa::OtherAgreements[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_TerminationCurrencyAmendment_terminationCurrencyAmendment
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    terminationCurrencyAmendment: csa::TerminationCurrencyAmendment[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_MinimumTransferAmountAmendment_minimumTransferAmountAmendment
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    minimumTransferAmountAmendment: csa::MinimumTransferAmountAmendment[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_ProcessAgent_processAgent
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    processAgent: csa::ProcessAgent[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_JurisdictionRelatedTerms_jurisdictionRelatedTerms
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    jurisdictionRelatedTerms: csa::JurisdictionRelatedTerms[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_PledgeeRepresentativeRider_pledgeeRepresentativeRider
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    pledgeeRepresentativeRider: csa::PledgeeRepresentativeRider[*];
}

Association cdm_assoc::CollateralTransferAgreementElections_FinalReturns_finalReturns
{
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
    finalReturns: csa::FinalReturns[*];
}

Association cdm_assoc::SecurityAgreementElections_Account_pledgedAccount
{
    securityAgreementElections: csa::SecurityAgreementElections[*];
    pledgedAccount: party::Account[*];
}

Association cdm_assoc::SecurityAgreementElections_EnforcementEvent_enforcementEvent
{
    securityAgreementElections: csa::SecurityAgreementElections[*];
    enforcementEvent: csa::EnforcementEvent[*];
}

Association cdm_assoc::SecurityAgreementElections_AppropriatedCollateralValuation_appropriatedCollateralValuation
{
    securityAgreementElections: csa::SecurityAgreementElections[*];
    appropriatedCollateralValuation: csa::AppropriatedCollateralValuation[*];
}

Association cdm_assoc::SecurityAgreementElections_ProcessAgent_processAgent
{
    securityAgreementElections: csa::SecurityAgreementElections[*];
    processAgent: csa::ProcessAgent[*];
}

Association cdm_assoc::SecurityAgreementElections_JurisdictionRelatedTerms_jurisdictionRelatedTerms
{
    securityAgreementElections: csa::SecurityAgreementElections[*];
    jurisdictionRelatedTerms: csa::JurisdictionRelatedTerms[*];
}

Association cdm_assoc::SecurityAgreementElections_ExecutionTerms_executionTerms
{
    securityAgreementElections: csa::SecurityAgreementElections[*];
    executionTerms: csa::ExecutionTerms[*];
}

Association cdm_assoc::AdditionalRepresentation_AdditionalRepresentationElection_partyElection
{
    additionalRepresentation: csa::AdditionalRepresentation[*];
    partyElection: csa::AdditionalRepresentationElection[*];
}

Association cdm_assoc::AdditionalRepresentations_AdditionalRepresentation_additionalRepresentation
{
    additionalRepresentations: csa::AdditionalRepresentations[*];
    additionalRepresentation: csa::AdditionalRepresentation[*];
}

Association cdm_assoc::ApplicableRegime_RegimeTerms_regimeTerms
{
    applicableRegime: csa::ApplicableRegime[*];
    regimeTerms: csa::RegimeTerms[*];
}

Association cdm_assoc::CalculationAndTimingLegacy_CSAValuationDate_valuationDate
{
    calculationAndTimingLegacy: csa::CalculationAndTimingLegacy[*];
    valuationDate: csa::CSAValuationDate[*];
}

Association cdm_assoc::CalculationAndTimingLegacy_ValuationTime_valuationTime
{
    calculationAndTimingLegacy: csa::CalculationAndTimingLegacy[*];
    valuationTime: csa::ValuationTime[*];
}

Association cdm_assoc::CalculationAndTimingLegacy_ValuationAgent_valuationAgent
{
    calculationAndTimingLegacy: csa::CalculationAndTimingLegacy[*];
    valuationAgent: csa::ValuationAgent[*];
}

Association cdm_assoc::CalculationAndTimingVariationMargin_CSAValuationDate_valuationDate
{
    calculationAndTimingVariationMargin: csa::CalculationAndTimingVariationMargin[*];
    valuationDate: csa::CSAValuationDate[*];
}

Association cdm_assoc::CalculationAndTimingVariationMargin_ValuationTime_valuationTime
{
    calculationAndTimingVariationMargin: csa::CalculationAndTimingVariationMargin[*];
    valuationTime: csa::ValuationTime[*];
}

Association cdm_assoc::CalculationAndTimingVariationMargin_ValuationAgent_valuationAgent
{
    calculationAndTimingVariationMargin: csa::CalculationAndTimingVariationMargin[*];
    valuationAgent: csa::ValuationAgent[*];
}

Association cdm_assoc::CalculationAndTimingVariationMargin_ValuationCalculationDateLocation_valuationDateLocation
{
    calculationAndTimingVariationMargin: csa::CalculationAndTimingVariationMargin[*];
    valuationDateLocation: csa::ValuationCalculationDateLocation[*];
}

Association cdm_assoc::CalculationAndTimingInitialMargin_CalculationAgentTerms_calculationAgentTerms
{
    calculationAndTimingInitialMargin: csa::CalculationAndTimingInitialMargin[*];
    calculationAgentTerms: csa::CalculationAgentTerms[*];
}

Association cdm_assoc::CalculationAndTimingInitialMargin_BespokeCalculationDate_bespokeCalculationDate
{
    calculationAndTimingInitialMargin: csa::CalculationAndTimingInitialMargin[*];
    bespokeCalculationDate: csa::BespokeCalculationDate[*];
}

Association cdm_assoc::CalculationAndTimingInitialMargin_BespokeCalculationTime_bespokeCalculationTime
{
    calculationAndTimingInitialMargin: csa::CalculationAndTimingInitialMargin[*];
    bespokeCalculationTime: csa::BespokeCalculationTime[*];
}

Association cdm_assoc::CalculationAndTimingInitialMargin_ValuationCalculationDateLocation_calculationDateLocation
{
    calculationAndTimingInitialMargin: csa::CalculationAndTimingInitialMargin[*];
    calculationDateLocation: csa::ValuationCalculationDateLocation[*];
}

Association cdm_assoc::CalculationAndTimingCollateralTransferAgreement_CalculationAgentTerms_calculationAgentTerms
{
    calculationAndTimingCollateralTransferAgreement: csa::CalculationAndTimingCollateralTransferAgreement[*];
    calculationAgentTerms: csa::CalculationAgentTerms[*];
}

Association cdm_assoc::CalculationAndTimingCollateralTransferAgreement_BespokeCalculationDate_bespokeCalculationDate
{
    calculationAndTimingCollateralTransferAgreement: csa::CalculationAndTimingCollateralTransferAgreement[*];
    bespokeCalculationDate: csa::BespokeCalculationDate[*];
}

Association cdm_assoc::CalculationAndTimingCollateralTransferAgreement_BespokeCalculationTime_bespokeCalculationTime
{
    calculationAndTimingCollateralTransferAgreement: csa::CalculationAndTimingCollateralTransferAgreement[*];
    bespokeCalculationTime: csa::BespokeCalculationTime[*];
}

Association cdm_assoc::CalculationAndTimingCollateralTransferAgreement_ValuationCalculationDateLocation_calculationDateLocation
{
    calculationAndTimingCollateralTransferAgreement: csa::CalculationAndTimingCollateralTransferAgreement[*];
    calculationDateLocation: csa::ValuationCalculationDateLocation[*];
}

Association cdm_assoc::CalculationAndTimingBase_NotificationTime_notificationTime
{
    calculationAndTimingBase: csa::CalculationAndTimingBase[*];
    notificationTime: csa::NotificationTime[*];
}

Association cdm_assoc::ValuationCalculationDateLocation_ValuationCalculationDateLocationElection_partyElection
{
    valuationCalculationDateLocation: csa::ValuationCalculationDateLocation[*];
    partyElection: csa::ValuationCalculationDateLocationElection[*];
}

Association cdm_assoc::CollateralManagementAgreement_CollateralManagementAgreementElection_partyElection
{
    collateralManagementAgreement: csa::CollateralManagementAgreement[*];
    partyElection: csa::CollateralManagementAgreementElection[*];
}

Association cdm_assoc::ConditionsPrecedent_SpecifiedConditionOrAccessCondition_specifiedConditionOrAccessCondition
{
    conditionsPrecedent: csa::ConditionsPrecedent[*];
    specifiedConditionOrAccessCondition: csa::SpecifiedConditionOrAccessCondition[*];
}

Association cdm_assoc::ControlAgreement_ControlAgreementElections_partyElection
{
    controlAgreement: csa::ControlAgreement[*];
    partyElection: csa::ControlAgreementElections[*];
}

Association cdm_assoc::ControlAgreementNecEvent_ControlAgreementNecEventElection_controlAgreementNecEventElection
{
    controlAgreementNecEvent: csa::ControlAgreementNecEvent[*];
    controlAgreementNecEventElection: csa::ControlAgreementNecEventElection[*];
}

Association cdm_assoc::Custodian_CustodianElection_partyElection
{
    custodian: csa::Custodian[*];
    partyElection: csa::CustodianElection[*];
}

Association cdm_assoc::CustodianElection_LegalEntity_custodian
{
    custodianElection: csa::CustodianElection[*];
    custodian: party::LegalEntity[*];
}

Association cdm_assoc::CustodianElection_Account_segregatedCashAccount
{
    custodianElection: csa::CustodianElection[*];
    segregatedCashAccount: party::Account[*];
}

Association cdm_assoc::CustodianElection_Account_segregatedSecurityAccount
{
    custodianElection: csa::CustodianElection[*];
    segregatedSecurityAccount: party::Account[*];
}

Association cdm_assoc::CustodianElection_LegalEntity_legacyNamedEntity
{
    custodianElection: csa::CustodianElection[*];
    legacyNamedEntity: party::LegalEntity[*];
}

Association cdm_assoc::CustodianEvent_CustodianEventEndDate_endDate
{
    custodianEvent: csa::CustodianEvent[*];
    endDate: csa::CustodianEventEndDate[*];
}

Association cdm_assoc::CustodianEventEndDate_CustomisableOffset_daysAfterCustodianEvent
{
    custodianEventEndDate: csa::CustodianEventEndDate[*];
    daysAfterCustodianEvent: datetime::CustomisableOffset[*];
}

Association cdm_assoc::CustodianEventEndDate_CustomisableOffset_releaseDate
{
    custodianEventEndDate: csa::CustodianEventEndDate[*];
    releaseDate: datetime::CustomisableOffset[*];
}

Association cdm_assoc::CustodianEventEndDate_CustomisableOffset_safekeepingPeriodExpiry
{
    custodianEventEndDate: csa::CustodianEventEndDate[*];
    safekeepingPeriodExpiry: datetime::CustomisableOffset[*];
}

Association cdm_assoc::CustodianEventEndDate_CustomisableOffset_dateOfTimelyStatement
{
    custodianEventEndDate: csa::CustodianEventEndDate[*];
    dateOfTimelyStatement: datetime::CustomisableOffset[*];
}

Association cdm_assoc::CustodianRisk_CustodianRiskElection_partyElection
{
    custodianRisk: csa::CustodianRisk[*];
    partyElection: csa::CustodianRiskElection[*];
}

Association cdm_assoc::CustodianTerms_CreditNotation_minimumRating
{
    custodianTerms: csa::CustodianTerms[*];
    minimumRating: observable::CreditNotation[*];
}

Association cdm_assoc::CustodianTerms_LegalEntity_initialDesignation
{
    custodianTerms: csa::CustodianTerms[*];
    initialDesignation: party::LegalEntity[*];
}

Association cdm_assoc::CustodyArrangements_CollateralAccessBreach_collateralAccessBreach
{
    custodyArrangements: csa::CustodyArrangements[*];
    collateralAccessBreach: csa::CollateralAccessBreach[*];
}

Association cdm_assoc::CustodyArrangements_CustodianRisk_custodianRisk
{
    custodyArrangements: csa::CustodyArrangements[*];
    custodianRisk: csa::CustodianRisk[*];
}

Association cdm_assoc::CustodyArrangements_ControlAgreement_controlAgreement
{
    custodyArrangements: csa::CustodyArrangements[*];
    controlAgreement: csa::ControlAgreement[*];
}

Association cdm_assoc::CustodyArrangements_CustodianEvent_custodianEvent
{
    custodyArrangements: csa::CustodyArrangements[*];
    custodianEvent: csa::CustodianEvent[*];
}

Association cdm_assoc::CustodyArrangements_Custodian_custodian
{
    custodyArrangements: csa::CustodyArrangements[*];
    custodian: csa::Custodian[*];
}

Association cdm_assoc::CustodyArrangements_CollateralManagementAgreement_collateralManagementAgreement
{
    custodyArrangements: csa::CustodyArrangements[*];
    collateralManagementAgreement: csa::CollateralManagementAgreement[*];
}

Association cdm_assoc::DisputeResolution_BusinessCenterTime_resolutionTime
{
    disputeResolution: csa::DisputeResolution[*];
    resolutionTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::DisputeResolution_RecalculationOfValue_recalculationOfValue
{
    disputeResolution: csa::DisputeResolution[*];
    recalculationOfValue: csa::RecalculationOfValue[*];
}

Association cdm_assoc::DisputeResolution_LegacyResolutionAlternative_legacyAlternative
{
    disputeResolution: csa::DisputeResolution[*];
    legacyAlternative: csa::LegacyResolutionAlternative[*];
}

Association cdm_assoc::DisputeResolution_ResolutionValue_value
{
    disputeResolution: csa::DisputeResolution[*];
    value: csa::ResolutionValue[*];
}

Association cdm_assoc::ExecutionTerms_ExecutionLanguage_executionLanguage
{
    executionTerms: csa::ExecutionTerms[*];
    executionLanguage: csa::ExecutionLanguage[*];
}

Association cdm_assoc::ExecutionTerms_ExecutionLocation_executionLocation
{
    executionTerms: csa::ExecutionTerms[*];
    executionLocation: csa::ExecutionLocation[*];
}

Association cdm_assoc::FrenchLawAddendum_FrenchLawAddendumElection_partyElection
{
    frenchLawAddendum: csa::FrenchLawAddendum[*];
    partyElection: csa::FrenchLawAddendumElection[*];
}

Association cdm_assoc::GeneralSimmElections_SimmVersion_simmVersion
{
    generalSimmElections: csa::GeneralSimmElections[*];
    simmVersion: csa::SimmVersion[*];
}

Association cdm_assoc::GeneralSimmElections_SimmCalculationCurrency_simmCalculationCurrency
{
    generalSimmElections: csa::GeneralSimmElections[*];
    simmCalculationCurrency: csa::SimmCalculationCurrency[*];
}

Association cdm_assoc::HoldingAndUsingPostedCollateral_HoldingAndUsingPostedCollateralElection_partyElection
{
    holdingAndUsingPostedCollateral: csa::HoldingAndUsingPostedCollateral[*];
    partyElection: csa::HoldingAndUsingPostedCollateralElection[*];
}

Association cdm_assoc::HoldingAndUsingPostedCollateralElection_EligibilityToHoldCollateral_eligibilityToHoldCollateral
{
    holdingAndUsingPostedCollateralElection: csa::HoldingAndUsingPostedCollateralElection[*];
    eligibilityToHoldCollateral: csa::EligibilityToHoldCollateral[*];
}

Association cdm_assoc::InterestAdjustment_InterestAdjustmentPeriodicity_periodicity
{
    interestAdjustment: csa::InterestAdjustment[*];
    periodicity: csa::InterestAdjustmentPeriodicity[*];
}

Association cdm_assoc::InterestAmount_ReturnAmount_returnAmount
{
    interestAmount: csa::InterestAmount[*];
    returnAmount: collateral::ReturnAmount[*];
}

Association cdm_assoc::InterestAmount_DeliveryAmount_deliveryAmount
{
    interestAmount: csa::InterestAmount[*];
    deliveryAmount: collateral::DeliveryAmount[*];
}

Association cdm_assoc::JurisdictionRelatedTerms_JapaneseSecuritiesProvisions_japaneseSecuritiesProvisions
{
    jurisdictionRelatedTerms: csa::JurisdictionRelatedTerms[*];
    japaneseSecuritiesProvisions: csa::JapaneseSecuritiesProvisions[*];
}

Association cdm_assoc::JurisdictionRelatedTerms_FrenchLawAddendum_frenchLawAddendum
{
    jurisdictionRelatedTerms: csa::JurisdictionRelatedTerms[*];
    frenchLawAddendum: csa::FrenchLawAddendum[*];
}

Association cdm_assoc::MinimumTransferAmountAmendment_AmendmentEffectiveDate_effectiveDate
{
    minimumTransferAmountAmendment: csa::MinimumTransferAmountAmendment[*];
    effectiveDate: csa::AmendmentEffectiveDate[*];
}

Association cdm_assoc::MinimumTransferAmountAmendment_ElectiveAmountElection_partyElections
{
    minimumTransferAmountAmendment: csa::MinimumTransferAmountAmendment[*];
    partyElections: csa::ElectiveAmountElection[*];
}

Association cdm_assoc::NotificationTime_NotificationTimeElection_partyElections
{
    notificationTime: csa::NotificationTime[*];
    partyElections: csa::NotificationTimeElection[*];
}

Association cdm_assoc::NotificationTimeElection_BusinessCenterTime_notificationTime
{
    notificationTimeElection: csa::NotificationTimeElection[*];
    notificationTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::OtherAgreements_OtherAgreementTerms_otherCSA
{
    otherAgreements: csa::OtherAgreements[*];
    otherCSA: legaldoc::OtherAgreementTerms[*];
}

Association cdm_assoc::OtherAgreements_OtherAgreementTerms_japaneseLawCsa
{
    otherAgreements: csa::OtherAgreements[*];
    japaneseLawCsa: legaldoc::OtherAgreementTerms[*];
}

Association cdm_assoc::OtherEligibleAndPostedSupport_CollateralValueMethod_value
{
    otherEligibleAndPostedSupport: csa::OtherEligibleAndPostedSupport[*];
    value: csa::CollateralValueMethod[*];
}

Association cdm_assoc::PartyAgreementIdentifier_Party_partyReference
{
    partyAgreementIdentifier: csa::PartyAgreementIdentifier[*];
    partyReference: party::Party[*];
}

Association cdm_assoc::PartyAgreementIdentifier_Identifier_documentIdentifier
{
    partyAgreementIdentifier: csa::PartyAgreementIdentifier[*];
    documentIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::PostingObligations_PostingObligationsElection_partyElection
{
    postingObligations: csa::PostingObligations[*];
    partyElection: csa::PostingObligationsElection[*];
}

Association cdm_assoc::PostingObligationsElection_EligibleCollateralCriteria_eligibleCollateral
{
    postingObligationsElection: csa::PostingObligationsElection[*];
    eligibleCollateral: collateral::EligibleCollateralCriteria[*];
}

Association cdm_assoc::ProcessAgent_ProcessAgentElection_partyElection
{
    processAgent: csa::ProcessAgent[*];
    partyElection: csa::ProcessAgentElection[*];
}

Association cdm_assoc::ProcessAgentElection_LegalEntity_entity
{
    processAgentElection: csa::ProcessAgentElection[*];
    entity: party::LegalEntity[*];
}

Association cdm_assoc::RecalculationOfValue_RecalculationOfValueElection_partyElection
{
    recalculationOfValue: csa::RecalculationOfValue[*];
    partyElection: csa::RecalculationOfValueElection[*];
}

Association cdm_assoc::Regime_ApplicableRegime_applicableRegime
{
    regime: csa::Regime[*];
    applicableRegime: csa::ApplicableRegime[*];
}

Association cdm_assoc::RegimeTerms_SimmException_simmException
{
    regimeTerms: csa::RegimeTerms[*];
    simmException: csa::SimmException[*];
}

Association cdm_assoc::RegimeTerms_RetrospectiveEffect_retrospectiveEffect
{
    regimeTerms: csa::RegimeTerms[*];
    retrospectiveEffect: csa::RetrospectiveEffect[*];
}

Association cdm_assoc::PledgeeRepresentativeRider_CustomisableOffset_representativeEndDate
{
    pledgeeRepresentativeRider: csa::PledgeeRepresentativeRider[*];
    representativeEndDate: datetime::CustomisableOffset[*];
}

Association cdm_assoc::RightsEvents_SecuredPartyRightsEvent_securityTakerRightsEvent
{
    rightsEvents: csa::RightsEvents[*];
    securityTakerRightsEvent: csa::SecuredPartyRightsEvent[*];
}

Association cdm_assoc::RightsEvents_ControlAgreementNecEvent_controlAgreementNecEvent
{
    rightsEvents: csa::RightsEvents[*];
    controlAgreementNecEvent: csa::ControlAgreementNecEvent[*];
}

Association cdm_assoc::RightsEvents_SecurityProviderRightsEvent_securityProviderRightsEvent
{
    rightsEvents: csa::RightsEvents[*];
    securityProviderRightsEvent: csa::SecurityProviderRightsEvent[*];
}

Association cdm_assoc::RightsEvents_AdditionalRightsEvent_additionalRightsEvent
{
    rightsEvents: csa::RightsEvents[*];
    additionalRightsEvent: csa::AdditionalRightsEvent[*];
}

Association cdm_assoc::SecuredPartyRightsEvent_SecuredPartyRightsEventElection_securedPartyRightsEventElection
{
    securedPartyRightsEvent: csa::SecuredPartyRightsEvent[*];
    securedPartyRightsEventElection: csa::SecuredPartyRightsEventElection[*];
}

Association cdm_assoc::SecurityProviderRightsEvent_SecurityProviderRightsEventElection_partyElection
{
    securityProviderRightsEvent: csa::SecurityProviderRightsEvent[*];
    partyElection: csa::SecurityProviderRightsEventElection[*];
}

Association cdm_assoc::SensitivityMethodologies_SensitivityMethodologiesPartyElection_partyElection
{
    sensitivityMethodologies: csa::SensitivityMethodologies[*];
    partyElection: csa::SensitivityMethodologiesPartyElection[*];
}

Association cdm_assoc::SensitivityMethodologiesPartyElection_SensitivityToEquity_sensitivityToEquity
{
    sensitivityMethodologiesPartyElection: csa::SensitivityMethodologiesPartyElection[*];
    sensitivityToEquity: csa::SensitivityToEquity[*];
}

Association cdm_assoc::SensitivityMethodologiesPartyElection_SensitivityMethodology_sensitivityToCommodity
{
    sensitivityMethodologiesPartyElection: csa::SensitivityMethodologiesPartyElection[*];
    sensitivityToCommodity: csa::SensitivityMethodology[*];
}

Association cdm_assoc::SensitivityToEquity_SensitivityMethodology_sensitivityToIndices
{
    sensitivityToEquity: csa::SensitivityToEquity[*];
    sensitivityToIndices: csa::SensitivityMethodology[*];
}

Association cdm_assoc::SensitivityToEquity_SensitivityMethodology_sensitivityToFunds
{
    sensitivityToEquity: csa::SensitivityToEquity[*];
    sensitivityToFunds: csa::SensitivityMethodology[*];
}

Association cdm_assoc::SensitivityToEquity_SensitivityMethodology_sensitivityToETFs
{
    sensitivityToEquity: csa::SensitivityToEquity[*];
    sensitivityToETFs: csa::SensitivityMethodology[*];
}

Association cdm_assoc::SimmCalculationCurrency_CalculationCurrencyElection_partyElection
{
    simmCalculationCurrency: csa::SimmCalculationCurrency[*];
    partyElection: csa::CalculationCurrencyElection[*];
}

Association cdm_assoc::SubstitutedRegime_SubstitutedRegimeTerms_regimeTerms
{
    substitutedRegime: csa::SubstitutedRegime[*];
    regimeTerms: csa::SubstitutedRegimeTerms[*];
}

Association cdm_assoc::Substitution_SubstitutionPartyElection_partyElection
{
    substitution: csa::Substitution[*];
    partyElection: csa::SubstitutionPartyElection[*];
}

Association cdm_assoc::TerminationCurrencyAmendment_AmendmentEffectiveDate_effectiveDate
{
    terminationCurrencyAmendment: csa::TerminationCurrencyAmendment[*];
    effectiveDate: csa::AmendmentEffectiveDate[*];
}

Association cdm_assoc::TerminationCurrencyAmendment_TerminationCurrencyElection_partyElection
{
    terminationCurrencyAmendment: csa::TerminationCurrencyAmendment[*];
    partyElection: csa::TerminationCurrencyElection[*];
}

Association cdm_assoc::CoveredTransactions_ProductTaxonomy_coveredTransactions
{
    coveredTransactions: csa::CoveredTransactions[*];
    coveredTransactions: asset::ProductTaxonomy[*];
}

Association cdm_assoc::CoveredTransactions_AdditionalObligations_additionalObligations
{
    coveredTransactions: csa::CoveredTransactions[*];
    additionalObligations: csa::AdditionalObligations[*];
}

Association cdm_assoc::CoveredTransactions_ExposureScope_exposure
{
    coveredTransactions: csa::CoveredTransactions[*];
    exposure: csa::ExposureScope[*];
}

Association cdm_assoc::CreditSupportObligationsBase_CSADeliveryAmount_deliveryAmount
{
    creditSupportObligationsBase: csa::CreditSupportObligationsBase[*];
    deliveryAmount: csa::CSADeliveryAmount[*];
}

Association cdm_assoc::CreditSupportObligationsBase_CSAReturnAmount_returnAmount
{
    creditSupportObligationsBase: csa::CreditSupportObligationsBase[*];
    returnAmount: csa::CSAReturnAmount[*];
}

Association cdm_assoc::CreditSupportObligationsBase_MinimumTransferAmount_minimumTransferAmount
{
    creditSupportObligationsBase: csa::CreditSupportObligationsBase[*];
    minimumTransferAmount: csa::MinimumTransferAmount[*];
}

Association cdm_assoc::CreditSupportObligationsBase_CollateralTransferTiming_collateralTransferTiming
{
    creditSupportObligationsBase: csa::CreditSupportObligationsBase[*];
    collateralTransferTiming: csa::CollateralTransferTiming[*];
}

Association cdm_assoc::CreditSupportObligationsBase_BespokeTransferTiming_bespokeTransferTiming
{
    creditSupportObligationsBase: csa::CreditSupportObligationsBase[*];
    bespokeTransferTiming: csa::BespokeTransferTiming[*];
}

Association cdm_assoc::CreditSupportObligationsLegacy_Threshold_threshold
{
    creditSupportObligationsLegacy: csa::CreditSupportObligationsLegacy[*];
    threshold: csa::Threshold[*];
}

Association cdm_assoc::CreditSupportObligationsLegacy_CollateralRounding_rounding
{
    creditSupportObligationsLegacy: csa::CreditSupportObligationsLegacy[*];
    rounding: csa::CollateralRounding[*];
}

Association cdm_assoc::CreditSupportObligationsLegacy_LegacyIndependentAmount_independentAmount
{
    creditSupportObligationsLegacy: csa::CreditSupportObligationsLegacy[*];
    independentAmount: csa::LegacyIndependentAmount[*];
}

Association cdm_assoc::CreditSupportObligationsLegacy_CreditSupportAmount_creditSupportAmount
{
    creditSupportObligationsLegacy: csa::CreditSupportObligationsLegacy[*];
    creditSupportAmount: csa::CreditSupportAmount[*];
}

Association cdm_assoc::CreditSupportObligationsLegacy_EligibleCreditSupport_eligibleCreditSupport
{
    creditSupportObligationsLegacy: csa::CreditSupportObligationsLegacy[*];
    eligibleCreditSupport: csa::EligibleCreditSupport[*];
}

Association cdm_assoc::CreditSupportObligationsInitialMargin_MarginApproach_marginApproach
{
    creditSupportObligationsInitialMargin: csa::CreditSupportObligationsInitialMargin[*];
    marginApproach: csa::MarginApproach[*];
}

Association cdm_assoc::CreditSupportObligationsInitialMargin_CollateralRounding_rounding
{
    creditSupportObligationsInitialMargin: csa::CreditSupportObligationsInitialMargin[*];
    rounding: csa::CollateralRounding[*];
}

Association cdm_assoc::CreditSupportObligationsInitialMargin_Threshold_threshold
{
    creditSupportObligationsInitialMargin: csa::CreditSupportObligationsInitialMargin[*];
    threshold: csa::Threshold[*];
}

Association cdm_assoc::CreditSupportObligationsInitialMargin_CreditSupportAmount_creditSupportAmount
{
    creditSupportObligationsInitialMargin: csa::CreditSupportObligationsInitialMargin[*];
    creditSupportAmount: csa::CreditSupportAmount[*];
}

Association cdm_assoc::CreditSupportObligationsCollateralTransferAgreement_MarginApproach_marginApproach
{
    creditSupportObligationsCollateralTransferAgreement: csa::CreditSupportObligationsCollateralTransferAgreement[*];
    marginApproach: csa::MarginApproach[*];
}

Association cdm_assoc::CreditSupportObligationsCollateralTransferAgreement_Threshold_threshold
{
    creditSupportObligationsCollateralTransferAgreement: csa::CreditSupportObligationsCollateralTransferAgreement[*];
    threshold: csa::Threshold[*];
}

Association cdm_assoc::CreditSupportObligationsCollateralTransferAgreement_CreditSupportAmount_creditSupportAmount
{
    creditSupportObligationsCollateralTransferAgreement: csa::CreditSupportObligationsCollateralTransferAgreement[*];
    creditSupportAmount: csa::CreditSupportAmount[*];
}

Association cdm_assoc::CreditSupportObligationsCollateralTransferAgreement_CollateralRounding_rounding
{
    creditSupportObligationsCollateralTransferAgreement: csa::CreditSupportObligationsCollateralTransferAgreement[*];
    rounding: csa::CollateralRounding[*];
}

Association cdm_assoc::CreditSupportObligationsVariationMargin_IneligibleCreditSupport_ineligibleCreditSupport
{
    creditSupportObligationsVariationMargin: csa::CreditSupportObligationsVariationMargin[*];
    ineligibleCreditSupport: csa::IneligibleCreditSupport[*];
}

Association cdm_assoc::CreditSupportObligationsVariationMargin_CollateralRounding_rounding
{
    creditSupportObligationsVariationMargin: csa::CreditSupportObligationsVariationMargin[*];
    rounding: csa::CollateralRounding[*];
}

Association cdm_assoc::CreditSupportObligationsVariationMargin_EligibleCreditSupport_eligibleCreditSupport
{
    creditSupportObligationsVariationMargin: csa::CreditSupportObligationsVariationMargin[*];
    eligibleCreditSupport: csa::EligibleCreditSupport[*];
}

Association cdm_assoc::EligibleCreditSupport_EligibleCollateralElection_partyElection
{
    eligibleCreditSupport: csa::EligibleCreditSupport[*];
    partyElection: csa::EligibleCollateralElection[*];
}

Association cdm_assoc::Threshold_ThresholdElection_partyElection
{
    threshold: csa::Threshold[*];
    partyElection: csa::ThresholdElection[*];
}

Association cdm_assoc::ThresholdElection_ThresholdMinimumTransferAmountFixedAmount_fixedAmount
{
    thresholdElection: csa::ThresholdElection[*];
    fixedAmount: csa::ThresholdMinimumTransferAmountFixedAmount[*];
}

Association cdm_assoc::ThresholdElection_ThresholdRatingsBased_ratingsBased
{
    thresholdElection: csa::ThresholdElection[*];
    ratingsBased: csa::ThresholdRatingsBased[*];
}

Association cdm_assoc::ThresholdRatingsBased_CSAThresholdVariableSet_variableSet
{
    thresholdRatingsBased: csa::ThresholdRatingsBased[*];
    variableSet: csa::CSAThresholdVariableSet[*];
}

Association cdm_assoc::MinimumTransferAmount_MinimumTransferAmountElection_partyElection
{
    minimumTransferAmount: csa::MinimumTransferAmount[*];
    partyElection: csa::MinimumTransferAmountElection[*];
}

Association cdm_assoc::MinimumTransferAmountElection_ThresholdMinimumTransferAmountFixedAmount_fixedAmount
{
    minimumTransferAmountElection: csa::MinimumTransferAmountElection[*];
    fixedAmount: csa::ThresholdMinimumTransferAmountFixedAmount[*];
}

Association cdm_assoc::MinimumTransferAmountElection_MinimumTransferAmountRatingsBased_ratingsBased
{
    minimumTransferAmountElection: csa::MinimumTransferAmountElection[*];
    ratingsBased: csa::MinimumTransferAmountRatingsBased[*];
}

Association cdm_assoc::MinimumTransferAmountRatingsBased_CSAMinimumTransferAmountVariableSet_variableSet
{
    minimumTransferAmountRatingsBased: csa::MinimumTransferAmountRatingsBased[*];
    variableSet: csa::CSAMinimumTransferAmountVariableSet[*];
}

Association cdm_assoc::ExposureScope_LegacyExposureScopeElection_partyElection
{
    exposureScope: csa::ExposureScope[*];
    partyElection: csa::LegacyExposureScopeElection[*];
}

Association cdm_assoc::LegacyExposureScopeElection_ExcludedProducts_excludedProducts
{
    legacyExposureScopeElection: csa::LegacyExposureScopeElection[*];
    excludedProducts: csa::ExcludedProducts[*];
}

Association cdm_assoc::CollateralTransferTiming_TransferSettlementTiming_transferSettlementTiming
{
    collateralTransferTiming: csa::CollateralTransferTiming[*];
    transferSettlementTiming: csa::TransferSettlementTiming[*];
}

Association cdm_assoc::CollateralTransferTiming_CollateralTransferTimingDefinition_collateralTransferTimingDefinition
{
    collateralTransferTiming: csa::CollateralTransferTiming[*];
    collateralTransferTimingDefinition: csa::CollateralTransferTimingDefinition[*];
}

Association cdm_assoc::CreditSupportDocument_CreditSupportDocumentElection_creditSupportDocumentElection
{
    creditSupportDocument: csa::CreditSupportDocument[*];
    creditSupportDocumentElection: csa::CreditSupportDocumentElection[*];
}

Association cdm_assoc::CreditSupportDocumentElection_Party_party
{
    creditSupportDocumentElection: csa::CreditSupportDocumentElection[*];
    party: party::Party[*];
}

Association cdm_assoc::CreditSupportDocumentElection_LegalAgreementIdentification_creditSupportDocumentTypes
{
    creditSupportDocumentElection: csa::CreditSupportDocumentElection[*];
    creditSupportDocumentTypes: legaldoc::LegalAgreementIdentification[*];
}

Association cdm_assoc::CreditSupportDocumentElection_LegalAgreement_creditSupportDocument
{
    creditSupportDocumentElection: csa::CreditSupportDocumentElection[*];
    creditSupportDocument: legaldoc::LegalAgreement[*];
}

Association cdm_assoc::CreditSupportProvider_CreditSupportProviderElection_creditSupportProviderElection
{
    creditSupportProvider: csa::CreditSupportProvider[*];
    creditSupportProviderElection: csa::CreditSupportProviderElection[*];
}

Association cdm_assoc::CreditSupportProviderElection_Party_party
{
    creditSupportProviderElection: csa::CreditSupportProviderElection[*];
    party: party::Party[*];
}

Association cdm_assoc::CreditSupportProviderElection_LegalEntity_creditSupportProvider
{
    creditSupportProviderElection: csa::CreditSupportProviderElection[*];
    creditSupportProvider: party::LegalEntity[*];
}

Association cdm_assoc::SpecifiedConditionOrAccessCondition_SpecifiedOrAccessConditionPartyElection_partyElection
{
    specifiedConditionOrAccessCondition: csa::SpecifiedConditionOrAccessCondition[*];
    partyElection: csa::SpecifiedOrAccessConditionPartyElection[*];
}

Association cdm_assoc::LegacyIndependentAmount_LegacyIndependentAmountParty_partyElection
{
    legacyIndependentAmount: csa::LegacyIndependentAmount[*];
    partyElection: csa::LegacyIndependentAmountParty[*];
}

Association cdm_assoc::LegacyIndependentAmountParty_LegacyIndependentAmountRatingsBased_ratingsBased
{
    legacyIndependentAmountParty: csa::LegacyIndependentAmountParty[*];
    ratingsBased: csa::LegacyIndependentAmountRatingsBased[*];
}

Association cdm_assoc::LegacyIndependentAmountParty_LegacyIndependentAmountRatingsXExposure_ratingsXExposure
{
    legacyIndependentAmountParty: csa::LegacyIndependentAmountParty[*];
    ratingsXExposure: csa::LegacyIndependentAmountRatingsXExposure[*];
}

Association cdm_assoc::IndependentAmountRatings_LegalEntity_namedAffiliate
{
    independentAmountRatings: csa::IndependentAmountRatings[*];
    namedAffiliate: party::LegalEntity[*];
}

Association cdm_assoc::IndependentAmountRatings_LegalEntity_namedEntity
{
    independentAmountRatings: csa::IndependentAmountRatings[*];
    namedEntity: party::LegalEntity[*];
}

Association cdm_assoc::LegacyIndependentAmountRatingsBased_RatingAgencyAmount_variableSet
{
    legacyIndependentAmountRatingsBased: csa::LegacyIndependentAmountRatingsBased[*];
    variableSet: csa::RatingAgencyAmount[*];
}

Association cdm_assoc::RatingAgencyAmount_CreditNotation_ratingVariableSet
{
    ratingAgencyAmount: csa::RatingAgencyAmount[*];
    ratingVariableSet: observable::CreditNotation[*];
}

Association cdm_assoc::LegacyIndependentAmountRatingsXExposure_RatingMultiplier_highestLowestVariableSet
{
    legacyIndependentAmountRatingsXExposure: csa::LegacyIndependentAmountRatingsXExposure[*];
    highestLowestVariableSet: csa::RatingMultiplier[*];
}

Association cdm_assoc::LegacyIndependentAmountRatingsXExposure_DirectionRatingMultiplier_compareVariableSet
{
    legacyIndependentAmountRatingsXExposure: csa::LegacyIndependentAmountRatingsXExposure[*];
    compareVariableSet: csa::DirectionRatingMultiplier[*];
}

Association cdm_assoc::RatingMultiplier_CreditNotation_ratingVariableSet
{
    ratingMultiplier: csa::RatingMultiplier[*];
    ratingVariableSet: observable::CreditNotation[*];
}

Association cdm_assoc::EligibilityToHoldCollateral_LegalEntity_initialCustodian
{
    eligibilityToHoldCollateral: csa::EligibilityToHoldCollateral[*];
    initialCustodian: party::LegalEntity[*];
}

Association cdm_assoc::DemandsAndNotices_NoticeInformationElection_partyElection
{
    demandsAndNotices: csa::DemandsAndNotices[*];
    partyElection: legaldoc::NoticeInformationElection[*];
}

Association cdm_assoc::AdjustableDate_BusinessDayAdjustments_dateAdjustments
{
    adjustableDate: datetime::AdjustableDate[*];
    dateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::AdjustableDate_BusinessDayAdjustments_dateAdjustmentsReference
{
    adjustableDate: datetime::AdjustableDate[*];
    dateAdjustmentsReference: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::AdjustableDates_BusinessDayAdjustments_dateAdjustments
{
    adjustableDates: datetime::AdjustableDates[*];
    dateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::AdjustableOrAdjustedDate_BusinessDayAdjustments_dateAdjustments
{
    adjustableOrAdjustedDate: datetime::AdjustableOrAdjustedDate[*];
    dateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::AdjustableOrAdjustedOrRelativeDate_BusinessDayAdjustments_dateAdjustments
{
    adjustableOrAdjustedOrRelativeDate: datetime::AdjustableOrAdjustedOrRelativeDate[*];
    dateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::AdjustableOrAdjustedOrRelativeDate_RelativeDateOffset_relativeDate
{
    adjustableOrAdjustedOrRelativeDate: datetime::AdjustableOrAdjustedOrRelativeDate[*];
    relativeDate: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::AdjustableOrRelativeDate_AdjustableDate_adjustableDate
{
    adjustableOrRelativeDate: datetime::AdjustableOrRelativeDate[*];
    adjustableDate: datetime::AdjustableDate[*];
}

Association cdm_assoc::AdjustableOrRelativeDate_AdjustedRelativeDateOffset_relativeDate
{
    adjustableOrRelativeDate: datetime::AdjustableOrRelativeDate[*];
    relativeDate: datetime::AdjustedRelativeDateOffset[*];
}

Association cdm_assoc::AdjustableOrRelativeDates_AdjustableDates_adjustableDates
{
    adjustableOrRelativeDates: datetime::AdjustableOrRelativeDates[*];
    adjustableDates: datetime::AdjustableDates[*];
}

Association cdm_assoc::AdjustableOrRelativeDates_RelativeDates_relativeDates
{
    adjustableOrRelativeDates: datetime::AdjustableOrRelativeDates[*];
    relativeDates: datetime::RelativeDates[*];
}

Association cdm_assoc::AdjustedRelativeDateOffset_BusinessDayAdjustments_relativeDateAdjustments
{
    adjustedRelativeDateOffset: datetime::AdjustedRelativeDateOffset[*];
    relativeDateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::BusinessDateRange_BusinessCenters_businessCenters
{
    businessDateRange: datetime::BusinessDateRange[*];
    businessCenters: datetime::BusinessCenters[*];
}

Association cdm_assoc::BusinessDayAdjustments_BusinessCenters_businessCenters
{
    businessDayAdjustments: datetime::BusinessDayAdjustments[*];
    businessCenters: datetime::BusinessCenters[*];
}

Association cdm_assoc::CustomisableOffset_Offset_offset
{
    customisableOffset: datetime::CustomisableOffset[*];
    offset: datetime::Offset[*];
}

Association cdm_assoc::RelativeDates_DateRange_scheduleBounds
{
    relativeDates: datetime::RelativeDates[*];
    scheduleBounds: datetime::DateRange[*];
}

Association cdm_assoc::RelativeDateOffset_BusinessCenters_businessCenters
{
    relativeDateOffset: datetime::RelativeDateOffset[*];
    businessCenters: datetime::BusinessCenters[*];
}

Association cdm_assoc::PeriodRange_PeriodBound_lowerBound
{
    periodRange: datetime::PeriodRange[*];
    lowerBound: datetime::PeriodBound[*];
}

Association cdm_assoc::PeriodRange_PeriodBound_upperBound
{
    periodRange: datetime::PeriodRange[*];
    upperBound: datetime::PeriodBound[*];
}

Association cdm_assoc::PeriodBound_Period_period
{
    periodBound: datetime::PeriodBound[*];
    period: datetime::Period[*];
}

Association cdm_assoc::AveragingSchedule_CalculationPeriodFrequency_averagingPeriodFrequency
{
    averagingSchedule: datetime::AveragingSchedule[*];
    averagingPeriodFrequency: datetime::CalculationPeriodFrequency[*];
}

Association cdm_assoc::AdjustableRelativeOrPeriodicDates_AdjustableDates_adjustableDates
{
    adjustableRelativeOrPeriodicDates: datetime::AdjustableRelativeOrPeriodicDates[*];
    adjustableDates: datetime::AdjustableDates[*];
}

Association cdm_assoc::AdjustableRelativeOrPeriodicDates_RelativeDates_relativeDates
{
    adjustableRelativeOrPeriodicDates: datetime::AdjustableRelativeOrPeriodicDates[*];
    relativeDates: datetime::RelativeDates[*];
}

Association cdm_assoc::AdjustableRelativeOrPeriodicDates_PeriodicDates_periodicDates
{
    adjustableRelativeOrPeriodicDates: datetime::AdjustableRelativeOrPeriodicDates[*];
    periodicDates: datetime::PeriodicDates[*];
}

Association cdm_assoc::PeriodicDates_AdjustableOrRelativeDate_startDate
{
    periodicDates: datetime::PeriodicDates[*];
    startDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::PeriodicDates_AdjustableOrRelativeDate_endDate
{
    periodicDates: datetime::PeriodicDates[*];
    endDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::PeriodicDates_CalculationPeriodFrequency_periodFrequency
{
    periodicDates: datetime::PeriodicDates[*];
    periodFrequency: datetime::CalculationPeriodFrequency[*];
}

Association cdm_assoc::PeriodicDates_BusinessDayAdjustments_periodDatesAdjustments
{
    periodicDates: datetime::PeriodicDates[*];
    periodDatesAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::CalculationFrequency_Period_period
{
    calculationFrequency: datetime::CalculationFrequency[*];
    period: datetime::Period[*];
}

Association cdm_assoc::CalculationFrequency_BusinessCenterTime_dateLocation
{
    calculationFrequency: datetime::CalculationFrequency[*];
    dateLocation: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::ContractFormationInstruction_LegalAgreement_legalAgreement
{
    contractFormationInstruction: event::ContractFormationInstruction[*];
    legalAgreement: legaldoc::LegalAgreement[*];
}

Association cdm_assoc::Instruction_PrimitiveInstruction_primitiveInstruction
{
    instruction: event::Instruction[*];
    primitiveInstruction: event::PrimitiveInstruction[*];
}

Association cdm_assoc::Instruction_TradeState_before
{
    instruction: event::Instruction[*];
    before: event::TradeState[*];
}

Association cdm_assoc::PrimitiveInstruction_ContractFormationInstruction_contractFormation
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    contractFormation: event::ContractFormationInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_ExecutionInstruction_execution
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    execution: event::ExecutionInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_ExerciseInstruction_exercise
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    exercise: event::ExerciseInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_PartyChangeInstruction_partyChange
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    partyChange: event::PartyChangeInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_QuantityChangeInstruction_quantityChange
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    quantityChange: event::QuantityChangeInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_ResetInstruction_reset
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    reset: event::ResetInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_SplitInstruction_split
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    split: event::SplitInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_TermsChangeInstruction_termsChange
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    termsChange: event::TermsChangeInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_TransferInstruction_transfer
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    transfer: event::TransferInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_IndexTransitionInstruction_indexTransition
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    indexTransition: event::IndexTransitionInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_StockSplitInstruction_stockSplit
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    stockSplit: event::StockSplitInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_ObservationInstruction_observation
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    observation: event::ObservationInstruction[*];
}

Association cdm_assoc::PrimitiveInstruction_ValuationInstruction_valuation
{
    primitiveInstruction: event::PrimitiveInstruction[*];
    valuation: event::ValuationInstruction[*];
}

Association cdm_assoc::BusinessEvent_TradeState_after
{
    businessEvent: event::BusinessEvent[*];
    after: event::TradeState[*];
}

Association cdm_assoc::CounterpartyPositionBusinessEvent_IdentifiedList_packageInformation
{
    counterpartyPositionBusinessEvent: event::CounterpartyPositionBusinessEvent[*];
    packageInformation: identifier::IdentifiedList[*];
}

Association cdm_assoc::CounterpartyPositionBusinessEvent_CounterpartyPositionState_after
{
    counterpartyPositionBusinessEvent: event::CounterpartyPositionBusinessEvent[*];
    after: event::CounterpartyPositionState[*];
}

Association cdm_assoc::ObservationInstruction_ObservationEvent_observationEvent
{
    observationInstruction: event::ObservationInstruction[*];
    observationEvent: event::ObservationEvent[*];
}

Association cdm_assoc::ValuationInstruction_Valuation_valuation
{
    valuationInstruction: event::ValuationInstruction[*];
    valuation: event::Valuation[*];
}

Association cdm_assoc::ExecutionInstruction_NonTransferableProduct_product
{
    executionInstruction: event::ExecutionInstruction[*];
    product: template::NonTransferableProduct[*];
}

Association cdm_assoc::ExecutionInstruction_PriceQuantity_priceQuantity
{
    executionInstruction: event::ExecutionInstruction[*];
    priceQuantity: observable::PriceQuantity[*];
}

Association cdm_assoc::ExecutionInstruction_Counterparty_counterparty
{
    executionInstruction: event::ExecutionInstruction[*];
    counterparty: party::Counterparty[*];
}

Association cdm_assoc::ExecutionInstruction_AncillaryParty_ancillaryParty
{
    executionInstruction: event::ExecutionInstruction[*];
    ancillaryParty: party::AncillaryParty[*];
}

Association cdm_assoc::ExecutionInstruction_Party_parties
{
    executionInstruction: event::ExecutionInstruction[*];
    parties: party::Party[*];
}

Association cdm_assoc::ExecutionInstruction_PartyRole_partyRoles
{
    executionInstruction: event::ExecutionInstruction[*];
    partyRoles: party::PartyRole[*];
}

Association cdm_assoc::ExecutionInstruction_ExecutionDetails_executionDetails
{
    executionInstruction: event::ExecutionInstruction[*];
    executionDetails: event::ExecutionDetails[*];
}

Association cdm_assoc::ExecutionInstruction_TimeZone_tradeTime
{
    executionInstruction: event::ExecutionInstruction[*];
    tradeTime: datetime::TimeZone[*];
}

Association cdm_assoc::ExecutionInstruction_TradeIdentifier_tradeIdentifier
{
    executionInstruction: event::ExecutionInstruction[*];
    tradeIdentifier: event::TradeIdentifier[*];
}

Association cdm_assoc::ExecutionInstruction_Collateral_collateral
{
    executionInstruction: event::ExecutionInstruction[*];
    collateral: collateral::Collateral[*];
}

Association cdm_assoc::ExecutionInstruction_Identifier_lotIdentifier
{
    executionInstruction: event::ExecutionInstruction[*];
    lotIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::ExerciseInstruction_PrimitiveInstruction_exerciseQuantity
{
    exerciseInstruction: event::ExerciseInstruction[*];
    exerciseQuantity: event::PrimitiveInstruction[*];
}

Association cdm_assoc::ExerciseInstruction_OptionPayout_exerciseOption
{
    exerciseInstruction: event::ExerciseInstruction[*];
    exerciseOption: template::OptionPayout[*];
}

Association cdm_assoc::ExerciseInstruction_AdjustableOrAdjustedDate_exerciseDate
{
    exerciseInstruction: event::ExerciseInstruction[*];
    exerciseDate: datetime::AdjustableOrAdjustedDate[*];
}

Association cdm_assoc::ExerciseInstruction_BusinessCenterTime_exerciseTime
{
    exerciseInstruction: event::ExerciseInstruction[*];
    exerciseTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::ExerciseInstruction_TradeIdentifier_replacementTradeIdentifier
{
    exerciseInstruction: event::ExerciseInstruction[*];
    replacementTradeIdentifier: event::TradeIdentifier[*];
}

Association cdm_assoc::CalculateTransferInstruction_TradeState_tradeState
{
    calculateTransferInstruction: event::CalculateTransferInstruction[*];
    tradeState: event::TradeState[*];
}

Association cdm_assoc::CalculateTransferInstruction_Reset_resets
{
    calculateTransferInstruction: event::CalculateTransferInstruction[*];
    resets: event::Reset[*];
}

Association cdm_assoc::TransferInstruction_TransferState_transferState
{
    transferInstruction: event::TransferInstruction[*];
    transferState: event::TransferState[*];
}

Association cdm_assoc::QuantityChangeInstruction_PriceQuantity_change
{
    quantityChangeInstruction: event::QuantityChangeInstruction[*];
    change: observable::PriceQuantity[*];
}

Association cdm_assoc::QuantityChangeInstruction_Identifier_lotIdentifier
{
    quantityChangeInstruction: event::QuantityChangeInstruction[*];
    lotIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::IndexTransitionInstruction_PriceQuantity_priceQuantity
{
    indexTransitionInstruction: event::IndexTransitionInstruction[*];
    priceQuantity: observable::PriceQuantity[*];
}

Association cdm_assoc::IndexTransitionInstruction_Transfer_cashTransfer
{
    indexTransitionInstruction: event::IndexTransitionInstruction[*];
    cashTransfer: event::Transfer[*];
}

Association cdm_assoc::TermsChangeInstruction_NonTransferableProduct_product
{
    termsChangeInstruction: event::TermsChangeInstruction[*];
    product: template::NonTransferableProduct[*];
}

Association cdm_assoc::TermsChangeInstruction_AncillaryParty_ancillaryParty
{
    termsChangeInstruction: event::TermsChangeInstruction[*];
    ancillaryParty: party::AncillaryParty[*];
}

Association cdm_assoc::SplitInstruction_PrimitiveInstruction_breakdown
{
    splitInstruction: event::SplitInstruction[*];
    breakdown: event::PrimitiveInstruction[*];
}

Association cdm_assoc::PartyChangeInstruction_Counterparty_counterparty
{
    partyChangeInstruction: event::PartyChangeInstruction[*];
    counterparty: party::Counterparty[*];
}

Association cdm_assoc::PartyChangeInstruction_AncillaryParty_ancillaryParty
{
    partyChangeInstruction: event::PartyChangeInstruction[*];
    ancillaryParty: party::AncillaryParty[*];
}

Association cdm_assoc::PartyChangeInstruction_PartyRole_partyRole
{
    partyChangeInstruction: event::PartyChangeInstruction[*];
    partyRole: party::PartyRole[*];
}

Association cdm_assoc::PartyChangeInstruction_TradeIdentifier_tradeId
{
    partyChangeInstruction: event::PartyChangeInstruction[*];
    tradeId: event::TradeIdentifier[*];
}

Association cdm_assoc::TradeState_Trade_trade
{
    tradeState: event::TradeState[*];
    trade: event::Trade[*];
}

Association cdm_assoc::TradeState_State_state
{
    tradeState: event::TradeState[*];
    state: event::State[*];
}

Association cdm_assoc::TradeState_Reset_resetHistory
{
    tradeState: event::TradeState[*];
    resetHistory: event::Reset[*];
}

Association cdm_assoc::TradeState_TransferState_transferHistory
{
    tradeState: event::TradeState[*];
    transferHistory: event::TransferState[*];
}

Association cdm_assoc::TradeState_ObservationEvent_observationHistory
{
    tradeState: event::TradeState[*];
    observationHistory: event::ObservationEvent[*];
}

Association cdm_assoc::TradeState_Valuation_valuationHistory
{
    tradeState: event::TradeState[*];
    valuationHistory: event::Valuation[*];
}

Association cdm_assoc::CounterpartyPositionState_CounterpartyPosition_counterpartyPosition
{
    counterpartyPositionState: event::CounterpartyPositionState[*];
    counterpartyPosition: position::CounterpartyPosition[*];
}

Association cdm_assoc::CounterpartyPositionState_State_state
{
    counterpartyPositionState: event::CounterpartyPositionState[*];
    state: event::State[*];
}

Association cdm_assoc::CounterpartyPositionState_ObservationEvent_observationHistory
{
    counterpartyPositionState: event::CounterpartyPositionState[*];
    observationHistory: event::ObservationEvent[*];
}

Association cdm_assoc::CounterpartyPositionState_Valuation_valuationHistory
{
    counterpartyPositionState: event::CounterpartyPositionState[*];
    valuationHistory: event::Valuation[*];
}

Association cdm_assoc::ObservationEvent_CreditEvent_creditEvent
{
    observationEvent: event::ObservationEvent[*];
    creditEvent: event::CreditEvent[*];
}

Association cdm_assoc::ObservationEvent_CorporateAction_corporateAction
{
    observationEvent: event::ObservationEvent[*];
    corporateAction: event::CorporateAction[*];
}

Association cdm_assoc::Reset_Observation_observations
{
    reset: event::Reset[*];
    observations: observable::Observation[*];
}

Association cdm_assoc::Reset_AveragingCalculation_averagingMethodology
{
    reset: event::Reset[*];
    averagingMethodology: template::AveragingCalculation[*];
}

Association cdm_assoc::State_ClosedState_closedState
{
    state: event::State[*];
    closedState: event::ClosedState[*];
}

Association cdm_assoc::TransferState_Transfer_transfer
{
    transferState: event::TransferState[*];
    transfer: event::Transfer[*];
}

Association cdm_assoc::Transfer_Identifier_identifier
{
    transfer: event::Transfer[*];
    identifier: identifier::Identifier[*];
}

Association cdm_assoc::Transfer_PartyReferencePayerReceiver_payerReceiver
{
    transfer: event::Transfer[*];
    payerReceiver: party::PartyReferencePayerReceiver[*];
}

Association cdm_assoc::Transfer_Reset_resetOrigin
{
    transfer: event::Transfer[*];
    resetOrigin: event::Reset[*];
}

Association cdm_assoc::Transfer_TransferExpression_transferExpression
{
    transfer: event::Transfer[*];
    transferExpression: event::TransferExpression[*];
}

Association cdm_assoc::TransferExpression_ScheduledTransfer_scheduledTransfer
{
    transferExpression: event::TransferExpression[*];
    scheduledTransfer: event::ScheduledTransfer[*];
}

Association cdm_assoc::TransferExpression_UnscheduledTransfer_unscheduledTransfer
{
    transferExpression: event::TransferExpression[*];
    unscheduledTransfer: event::UnscheduledTransfer[*];
}

Association cdm_assoc::Trade_TradeIdentifier_tradeIdentifier
{
    trade: event::Trade[*];
    tradeIdentifier: event::TradeIdentifier[*];
}

Association cdm_assoc::Trade_TimeZone_tradeTime
{
    trade: event::Trade[*];
    tradeTime: datetime::TimeZone[*];
}

Association cdm_assoc::Trade_Party_party
{
    trade: event::Trade[*];
    party: party::Party[*];
}

Association cdm_assoc::Trade_PartyRole_partyRole
{
    trade: event::Trade[*];
    partyRole: party::PartyRole[*];
}

Association cdm_assoc::Trade_ExecutionDetails_executionDetails
{
    trade: event::Trade[*];
    executionDetails: event::ExecutionDetails[*];
}

Association cdm_assoc::Trade_ContractDetails_contractDetails
{
    trade: event::Trade[*];
    contractDetails: event::ContractDetails[*];
}

Association cdm_assoc::Trade_Collateral_collateral
{
    trade: event::Trade[*];
    collateral: collateral::Collateral[*];
}

Association cdm_assoc::Trade_Account_account
{
    trade: event::Trade[*];
    account: party::Account[*];
}

Association cdm_assoc::ExecutionDetails_LegalEntity_executionVenue
{
    executionDetails: event::ExecutionDetails[*];
    executionVenue: party::LegalEntity[*];
}

Association cdm_assoc::ExecutionDetails_IdentifiedList_packageReference
{
    executionDetails: event::ExecutionDetails[*];
    packageReference: identifier::IdentifiedList[*];
}

Association cdm_assoc::ContractDetails_LegalAgreement_documentation
{
    contractDetails: event::ContractDetails[*];
    documentation: legaldoc::LegalAgreement[*];
}

Association cdm_assoc::Lineage_Trade_tradeReference
{
    lineage: event::Lineage[*];
    tradeReference: event::Trade[*];
}

Association cdm_assoc::Lineage_WorkflowStep_eventReference
{
    lineage: event::Lineage[*];
    eventReference: workflow::WorkflowStep[*];
}

Association cdm_assoc::Lineage_PortfolioState_portfolioStateReference
{
    lineage: event::Lineage[*];
    portfolioStateReference: position::PortfolioState[*];
}

Association cdm_assoc::CreditEvent_Resource_publiclyAvailableInformation
{
    creditEvent: event::CreditEvent[*];
    publiclyAvailableInformation: legaldoc::Resource[*];
}

Association cdm_assoc::CreditEvent_ReferenceInformation_referenceInformation
{
    creditEvent: event::CreditEvent[*];
    referenceInformation: product::ReferenceInformation[*];
}

Association cdm_assoc::CorporateAction_AdjustmentFactor_adjustmentFactor
{
    corporateAction: event::CorporateAction[*];
    adjustmentFactor: event::AdjustmentFactor[*];
}

Association cdm_assoc::CorporateAction_InformationSource_informationSource
{
    corporateAction: event::CorporateAction[*];
    informationSource: observable::InformationSource[*];
}

Association cdm_assoc::CorporateAction_PriceSchedule_dividendObservation
{
    corporateAction: event::CorporateAction[*];
    dividendObservation: observable::PriceSchedule[*];
}

Association cdm_assoc::AdjustmentFactor_AdjustmentFactorCalculationTerms_calculationTerms
{
    adjustmentFactor: event::AdjustmentFactor[*];
    calculationTerms: event::AdjustmentFactorCalculationTerms[*];
}

Association cdm_assoc::AdjustmentFactorCalculationTerms_SpinOff_spinOff
{
    adjustmentFactorCalculationTerms: event::AdjustmentFactorCalculationTerms[*];
    spinOff: event::SpinOff[*];
}

Association cdm_assoc::AdjustmentFactorCalculationTerms_Merger_merger
{
    adjustmentFactorCalculationTerms: event::AdjustmentFactorCalculationTerms[*];
    merger: event::Merger[*];
}

Association cdm_assoc::AdjustmentFactorCalculationTerms_AccrualFactor_accrualFactor
{
    adjustmentFactorCalculationTerms: event::AdjustmentFactorCalculationTerms[*];
    accrualFactor: event::AccrualFactor[*];
}

Association cdm_assoc::AdjustmentFactorCalculationTerms_PriceSchedule_dividendObservation
{
    adjustmentFactorCalculationTerms: event::AdjustmentFactorCalculationTerms[*];
    dividendObservation: observable::PriceSchedule[*];
}

Association cdm_assoc::AccrualFactor_PriceSchedule_value
{
    accrualFactor: event::AccrualFactor[*];
    value: observable::PriceSchedule[*];
}

Association cdm_assoc::AccrualFactor_AccrualFactorCalculationTerms_calculationTerms
{
    accrualFactor: event::AccrualFactor[*];
    calculationTerms: event::AccrualFactorCalculationTerms[*];
}

Association cdm_assoc::AccrualFactorCalculationTerms_StubValue_interpolationTerms
{
    accrualFactorCalculationTerms: event::AccrualFactorCalculationTerms[*];
    interpolationTerms: product::StubValue[*];
}

Association cdm_assoc::SpinOff_Security_parentSecurity
{
    spinOff: event::SpinOff[*];
    parentSecurity: asset::Security[*];
}

Association cdm_assoc::SpinOff_Security_childSecurity
{
    spinOff: event::SpinOff[*];
    childSecurity: asset::Security[*];
}

Association cdm_assoc::Merger_Security_purchaserSecurity
{
    merger: event::Merger[*];
    purchaserSecurity: asset::Security[*];
}

Association cdm_assoc::Merger_Security_acquiredSecurity
{
    merger: event::Merger[*];
    acquiredSecurity: asset::Security[*];
}

Association cdm_assoc::ClearingInstruction_TradeState_alphaContract
{
    clearingInstruction: event::ClearingInstruction[*];
    alphaContract: event::TradeState[*];
}

Association cdm_assoc::ClearingInstruction_Party_clearingParty
{
    clearingInstruction: event::ClearingInstruction[*];
    clearingParty: party::Party[*];
}

Association cdm_assoc::ClearingInstruction_Party_party1
{
    clearingInstruction: event::ClearingInstruction[*];
    party1: party::Party[*];
}

Association cdm_assoc::ClearingInstruction_Party_party2
{
    clearingInstruction: event::ClearingInstruction[*];
    party2: party::Party[*];
}

Association cdm_assoc::ClearingInstruction_Party_clearerParty1
{
    clearingInstruction: event::ClearingInstruction[*];
    clearerParty1: party::Party[*];
}

Association cdm_assoc::ClearingInstruction_Party_clearerParty2
{
    clearingInstruction: event::ClearingInstruction[*];
    clearerParty2: party::Party[*];
}

Association cdm_assoc::SecurityLendingInvoice_Party_sendingParty
{
    securityLendingInvoice: event::SecurityLendingInvoice[*];
    sendingParty: party::Party[*];
}

Association cdm_assoc::SecurityLendingInvoice_Party_receivingParty
{
    securityLendingInvoice: event::SecurityLendingInvoice[*];
    receivingParty: party::Party[*];
}

Association cdm_assoc::SecurityLendingInvoice_BillingRecord_billingRecord
{
    securityLendingInvoice: event::SecurityLendingInvoice[*];
    billingRecord: event::BillingRecord[*];
}

Association cdm_assoc::SecurityLendingInvoice_BillingSummary_billingSummary
{
    securityLendingInvoice: event::SecurityLendingInvoice[*];
    billingSummary: event::BillingSummary[*];
}

Association cdm_assoc::BillingInstruction_Party_sendingParty
{
    billingInstruction: event::BillingInstruction[*];
    sendingParty: party::Party[*];
}

Association cdm_assoc::BillingInstruction_Party_receivingParty
{
    billingInstruction: event::BillingInstruction[*];
    receivingParty: party::Party[*];
}

Association cdm_assoc::BillingInstruction_BillingRecordInstruction_billingRecordInstruction
{
    billingInstruction: event::BillingInstruction[*];
    billingRecordInstruction: event::BillingRecordInstruction[*];
}

Association cdm_assoc::BillingInstruction_BillingSummaryInstruction_billingSummary
{
    billingInstruction: event::BillingInstruction[*];
    billingSummary: event::BillingSummaryInstruction[*];
}

Association cdm_assoc::BillingRecordInstruction_TradeState_tradeState
{
    billingRecordInstruction: event::BillingRecordInstruction[*];
    tradeState: event::TradeState[*];
}

Association cdm_assoc::BillingRecordInstruction_Observation_observation
{
    billingRecordInstruction: event::BillingRecordInstruction[*];
    observation: observable::Observation[*];
}

Association cdm_assoc::BillingRecord_TradeState_tradeState
{
    billingRecord: event::BillingRecord[*];
    tradeState: event::TradeState[*];
}

Association cdm_assoc::BillingRecord_Transfer_recordTransfer
{
    billingRecord: event::BillingRecord[*];
    recordTransfer: event::Transfer[*];
}

Association cdm_assoc::BillingSummary_Transfer_summaryTransfer
{
    billingSummary: event::BillingSummary[*];
    summaryTransfer: event::Transfer[*];
}

Association cdm_assoc::TradePricingReport_Trade_trade
{
    tradePricingReport: event::TradePricingReport[*];
    trade: event::Trade[*];
}

Association cdm_assoc::TradePricingReport_TimeZone_pricingTime
{
    tradePricingReport: event::TradePricingReport[*];
    pricingTime: datetime::TimeZone[*];
}

Association cdm_assoc::MarginCallBase_MarginCallInstructionType_instructionType
{
    marginCallBase: event::MarginCallBase[*];
    instructionType: event::MarginCallInstructionType[*];
}

Association cdm_assoc::MarginCallBase_Party_party
{
    marginCallBase: event::MarginCallBase[*];
    party: party::Party[*];
}

Association cdm_assoc::MarginCallBase_PartyRole_partyRole
{
    marginCallBase: event::MarginCallBase[*];
    partyRole: party::PartyRole[*];
}

Association cdm_assoc::MarginCallBase_Party_clearingBroker
{
    marginCallBase: event::MarginCallBase[*];
    clearingBroker: party::Party[*];
}

Association cdm_assoc::MarginCallBase_Identifier_callIdentifier
{
    marginCallBase: event::MarginCallBase[*];
    callIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::MarginCallBase_AgreementName_callAgreementType
{
    marginCallBase: event::MarginCallBase[*];
    callAgreementType: legaldoc::AgreementName[*];
}

Association cdm_assoc::MarginCallBase_MarginCallExposure_baseCurrencyExposure
{
    marginCallBase: event::MarginCallBase[*];
    baseCurrencyExposure: event::MarginCallExposure[*];
}

Association cdm_assoc::MarginCallBase_CollateralPortfolio_collateralPortfolio
{
    marginCallBase: event::MarginCallBase[*];
    collateralPortfolio: event::CollateralPortfolio[*];
}

Association cdm_assoc::MarginCallBase_CollateralBalance_independentAmountBalance
{
    marginCallBase: event::MarginCallBase[*];
    independentAmountBalance: event::CollateralBalance[*];
}

Association cdm_assoc::Exposure_PortfolioState_tradePortfolio
{
    exposure: event::Exposure[*];
    tradePortfolio: position::PortfolioState[*];
}

Association cdm_assoc::MarginCallExposure_Exposure_overallExposure
{
    marginCallExposure: event::MarginCallExposure[*];
    overallExposure: event::Exposure[*];
}

Association cdm_assoc::MarginCallExposure_Exposure_simmIMExposure
{
    marginCallExposure: event::MarginCallExposure[*];
    simmIMExposure: event::Exposure[*];
}

Association cdm_assoc::MarginCallExposure_Exposure_scheduleGridIMExposure
{
    marginCallExposure: event::MarginCallExposure[*];
    scheduleGridIMExposure: event::Exposure[*];
}

Association cdm_assoc::CollateralBalance_PartyReferencePayerReceiver_payerReceiver
{
    collateralBalance: event::CollateralBalance[*];
    payerReceiver: party::PartyReferencePayerReceiver[*];
}

Association cdm_assoc::CollateralPortfolio_Identifier_portfolioIdentifier
{
    collateralPortfolio: event::CollateralPortfolio[*];
    portfolioIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::CollateralPortfolio_CollateralPosition_collateralPosition
{
    collateralPortfolio: event::CollateralPortfolio[*];
    collateralPosition: event::CollateralPosition[*];
}

Association cdm_assoc::CollateralPortfolio_CollateralBalance_collateralBalance
{
    collateralPortfolio: event::CollateralPortfolio[*];
    collateralBalance: event::CollateralBalance[*];
}

Association cdm_assoc::CollateralPortfolio_LegalAgreement_legalAgreement
{
    collateralPortfolio: event::CollateralPortfolio[*];
    legalAgreement: legaldoc::LegalAgreement[*];
}

Association cdm_assoc::CollateralPosition_CollateralTreatment_treatment
{
    collateralPosition: event::CollateralPosition[*];
    treatment: collateral::CollateralTreatment[*];
}

Association cdm_assoc::MarginCallIssuance_EligibleCollateralCriteria_recallNonCashCollateralDescription
{
    marginCallIssuance: event::MarginCallIssuance[*];
    recallNonCashCollateralDescription: collateral::EligibleCollateralCriteria[*];
}

Association cdm_assoc::MarginCallResponseAction_CollateralPosition_collateralPositionComponent
{
    marginCallResponseAction: event::MarginCallResponseAction[*];
    collateralPositionComponent: event::CollateralPosition[*];
}

Association cdm_assoc::MarginCallResponse_MarginCallResponseAction_marginCallResponseAction
{
    marginCallResponse: event::MarginCallResponse[*];
    marginCallResponseAction: event::MarginCallResponseAction[*];
}

Association cdm_assoc::Identifier_Party_issuerReference
{
    identifier: identifier::Identifier[*];
    issuerReference: party::Party[*];
}

Association cdm_assoc::Identifier_AssignedIdentifier_assignedIdentifier
{
    identifier: identifier::Identifier[*];
    assignedIdentifier: identifier::AssignedIdentifier[*];
}

Association cdm_assoc::IdentifiedList_Identifier_listId
{
    identifiedList: identifier::IdentifiedList[*];
    listId: identifier::Identifier[*];
}

Association cdm_assoc::IdentifiedList_Identifier_componentId
{
    identifiedList: identifier::IdentifiedList[*];
    componentId: identifier::Identifier[*];
}

Association cdm_assoc::Resource_ResourceLength_length
{
    resource: legaldoc::Resource[*];
    length: legaldoc::ResourceLength[*];
}

Association cdm_assoc::AgreementTerms_Agreement_agreement
{
    agreementTerms: legaldoc::AgreementTerms[*];
    agreement: legaldoc::Agreement[*];
}

Association cdm_assoc::AgreementTerms_Counterparty_counterparty
{
    agreementTerms: legaldoc::AgreementTerms[*];
    counterparty: party::Counterparty[*];
}

Association cdm_assoc::LegalAgreement_AgreementTerms_agreementTerms
{
    legalAgreement: legaldoc::LegalAgreement[*];
    agreementTerms: legaldoc::AgreementTerms[*];
}

Association cdm_assoc::LegalAgreement_UmbrellaAgreement_umbrellaAgreement
{
    legalAgreement: legaldoc::LegalAgreement[*];
    umbrellaAgreement: legaldoc::UmbrellaAgreement[*];
}

Association cdm_assoc::LegalAgreementBase_Identifier_identifier
{
    legalAgreementBase: legaldoc::LegalAgreementBase[*];
    identifier: identifier::Identifier[*];
}

Association cdm_assoc::LegalAgreementBase_LegalAgreementIdentification_legalAgreementIdentification
{
    legalAgreementBase: legaldoc::LegalAgreementBase[*];
    legalAgreementIdentification: legaldoc::LegalAgreementIdentification[*];
}

Association cdm_assoc::LegalAgreementBase_Party_contractualParty
{
    legalAgreementBase: legaldoc::LegalAgreementBase[*];
    contractualParty: party::Party[*];
}

Association cdm_assoc::LegalAgreementBase_PartyRole_otherParty
{
    legalAgreementBase: legaldoc::LegalAgreementBase[*];
    otherParty: party::PartyRole[*];
}

Association cdm_assoc::LegalAgreementBase_Resource_attachment
{
    legalAgreementBase: legaldoc::LegalAgreementBase[*];
    attachment: legaldoc::Resource[*];
}

Association cdm_assoc::LegalAgreementIdentification_AgreementName_agreementName
{
    legalAgreementIdentification: legaldoc::LegalAgreementIdentification[*];
    agreementName: legaldoc::AgreementName[*];
}

Association cdm_assoc::AgreementName_ContractualTermsSupplement_contractualTermsSupplement
{
    agreementName: legaldoc::AgreementName[*];
    contractualTermsSupplement: legaldoc::ContractualTermsSupplement[*];
}

Association cdm_assoc::AgreementName_ContractualMatrix_contractualMatrix
{
    agreementName: legaldoc::AgreementName[*];
    contractualMatrix: legaldoc::ContractualMatrix[*];
}

Association cdm_assoc::UmbrellaAgreement_UmbrellaAgreementSet_agreementSet
{
    umbrellaAgreement: legaldoc::UmbrellaAgreement[*];
    agreementSet: legaldoc::UmbrellaAgreementSet[*];
}

Association cdm_assoc::UmbrellaAgreementParty_Party_party
{
    umbrellaAgreementParty: legaldoc::UmbrellaAgreementParty[*];
    party: party::Party[*];
}

Association cdm_assoc::UmbrellaAgreementParty_NonLegalEntity_nonLegalEntity
{
    umbrellaAgreementParty: legaldoc::UmbrellaAgreementParty[*];
    nonLegalEntity: legaldoc::NonLegalEntity[*];
}

Association cdm_assoc::UmbrellaAgreementParty_Party_parentParty
{
    umbrellaAgreementParty: legaldoc::UmbrellaAgreementParty[*];
    parentParty: party::Party[*];
}

Association cdm_assoc::UmbrellaAgreementSet_Agreement_agreement
{
    umbrellaAgreementSet: legaldoc::UmbrellaAgreementSet[*];
    agreement: legaldoc::Agreement[*];
}

Association cdm_assoc::UmbrellaAgreementSet_UmbrellaAgreementParty_party
{
    umbrellaAgreementSet: legaldoc::UmbrellaAgreementSet[*];
    party: legaldoc::UmbrellaAgreementParty[*];
}

Association cdm_assoc::ContactInformationElection_ContactInformation_primaryContactInformation
{
    contactInformationElection: legaldoc::ContactInformationElection[*];
    primaryContactInformation: party::ContactInformation[*];
}

Association cdm_assoc::NoticeInformationElection_NoticeContactInformation_additionalContactInformation
{
    noticeInformationElection: legaldoc::NoticeInformationElection[*];
    additionalContactInformation: legaldoc::NoticeContactInformation[*];
}

Association cdm_assoc::NoticeContactInformation_NaturalPerson_naturalPerson
{
    noticeContactInformation: legaldoc::NoticeContactInformation[*];
    naturalPerson: party::NaturalPerson[*];
}

Association cdm_assoc::TransferContactInformation_Account_account
{
    transferContactInformation: legaldoc::TransferContactInformation[*];
    account: party::Account[*];
}

Association cdm_assoc::Agreement_CollateralTransferAgreementElections_collateralTransferAgreementElections
{
    agreement: legaldoc::Agreement[*];
    collateralTransferAgreementElections: csa::CollateralTransferAgreementElections[*];
}

Association cdm_assoc::Agreement_SecurityAgreementElections_securityAgreementElections
{
    agreement: legaldoc::Agreement[*];
    securityAgreementElections: csa::SecurityAgreementElections[*];
}

Association cdm_assoc::Agreement_MasterAgreementSchedule_masterAgreementSchedule
{
    agreement: legaldoc::Agreement[*];
    masterAgreementSchedule: legaldoc::MasterAgreementSchedule[*];
}

Association cdm_assoc::Agreement_TransactionAdditionalTerms_transactionAdditionalTerms
{
    agreement: legaldoc::Agreement[*];
    transactionAdditionalTerms: legaldoc::TransactionAdditionalTerms[*];
}

Association cdm_assoc::MasterAgreement_AutomaticEarlyTermination_automaticEarlyTermination
{
    masterAgreement: legaldoc::MasterAgreement[*];
    automaticEarlyTermination: legaldoc::AutomaticEarlyTermination[*];
}

Association cdm_assoc::MasterAgreement_TerminationCurrency_terminationCurrency
{
    masterAgreement: legaldoc::MasterAgreement[*];
    terminationCurrency: legaldoc::TerminationCurrency[*];
}

Association cdm_assoc::MasterAgreement_DemandsAndNotices_addressForNotices
{
    masterAgreement: legaldoc::MasterAgreement[*];
    addressForNotices: csa::DemandsAndNotices[*];
}

Association cdm_assoc::MasterAgreement_CreditSupportDocument_creditSupportDocument
{
    masterAgreement: legaldoc::MasterAgreement[*];
    creditSupportDocument: csa::CreditSupportDocument[*];
}

Association cdm_assoc::MasterAgreement_CreditSupportProvider_creditSupportProvider
{
    masterAgreement: legaldoc::MasterAgreement[*];
    creditSupportProvider: csa::CreditSupportProvider[*];
}

Association cdm_assoc::MasterAgreement_SpecifiedEntities_specifiedEntities
{
    masterAgreement: legaldoc::MasterAgreement[*];
    specifiedEntities: legaldoc::SpecifiedEntities[*];
}

Association cdm_assoc::AutomaticEarlyTermination_AutomaticEarlyTerminationElection_partyElection
{
    automaticEarlyTermination: legaldoc::AutomaticEarlyTermination[*];
    partyElection: legaldoc::AutomaticEarlyTerminationElection[*];
}

Association cdm_assoc::AutomaticEarlyTerminationElection_Party_party
{
    automaticEarlyTerminationElection: legaldoc::AutomaticEarlyTerminationElection[*];
    party: party::Party[*];
}

Association cdm_assoc::TerminationCurrency_TerminationCurrencySelection_statedTerminationCurrency
{
    terminationCurrency: legaldoc::TerminationCurrency[*];
    statedTerminationCurrency: legaldoc::TerminationCurrencySelection[*];
}

Association cdm_assoc::TerminationCurrency_PartyOptionTerminationCurrency_partyOptionTerminationCurrency
{
    terminationCurrency: legaldoc::TerminationCurrency[*];
    partyOptionTerminationCurrency: legaldoc::PartyOptionTerminationCurrency[*];
}

Association cdm_assoc::TerminationCurrencySelection_PartyTerminationCurrencySelection_partyElection
{
    terminationCurrencySelection: legaldoc::TerminationCurrencySelection[*];
    partyElection: legaldoc::PartyTerminationCurrencySelection[*];
}

Association cdm_assoc::PartyTerminationCurrencySelection_Party_party
{
    partyTerminationCurrencySelection: legaldoc::PartyTerminationCurrencySelection[*];
    party: party::Party[*];
}

Association cdm_assoc::SpecifiedEntities_SpecifiedEntity_specifiedEntity
{
    specifiedEntities: legaldoc::SpecifiedEntities[*];
    specifiedEntity: legaldoc::SpecifiedEntity[*];
}

Association cdm_assoc::SpecifiedEntity_Party_party
{
    specifiedEntity: legaldoc::SpecifiedEntity[*];
    party: party::Party[*];
}

Association cdm_assoc::SpecifiedEntity_LegalEntity_specifiedEntity
{
    specifiedEntity: legaldoc::SpecifiedEntity[*];
    specifiedEntity: party::LegalEntity[*];
}

Association cdm_assoc::MasterAgreementSchedule_MasterAgreementClause_clause
{
    masterAgreementSchedule: legaldoc::MasterAgreementSchedule[*];
    clause: legaldoc::MasterAgreementClause[*];
}

Association cdm_assoc::MasterAgreementClause_MasterAgreementClauseVariant_variant
{
    masterAgreementClause: legaldoc::MasterAgreementClause[*];
    variant: legaldoc::MasterAgreementClauseVariant[*];
}

Association cdm_assoc::MasterAgreementClauseVariant_MasterAgreementVariableSet_variableSet
{
    masterAgreementClauseVariant: legaldoc::MasterAgreementClauseVariant[*];
    variableSet: legaldoc::MasterAgreementVariableSet[*];
}

Association cdm_assoc::FxAdditionalTerms_FxDisruptionEvents_disruptionEvents
{
    fxAdditionalTerms: legaldoc::FxAdditionalTerms[*];
    disruptionEvents: legaldoc::FxDisruptionEvents[*];
}

Association cdm_assoc::Representations_Clause_additionalBespokeTerms
{
    representations: legaldoc::Representations[*];
    additionalBespokeTerms: legaldoc::Clause[*];
}

Association cdm_assoc::DeterminationRolesAndTerms_Clause_fallbackLanguageBespokeTerms
{
    determinationRolesAndTerms: legaldoc::DeterminationRolesAndTerms[*];
    fallbackLanguageBespokeTerms: legaldoc::Clause[*];
}

Association cdm_assoc::FxDisruptionEvents_EventCurrency_eventCurrency
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    eventCurrency: legaldoc::EventCurrency[*];
}

Association cdm_assoc::FxDisruptionEvents_FxPriceSourceDisruption_priceSourceDisruption
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    priceSourceDisruption: legaldoc::FxPriceSourceDisruption[*];
}

Association cdm_assoc::FxDisruptionEvents_FxBenchmarkObligationDefault_benchmarkObligationDefault
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    benchmarkObligationDefault: legaldoc::FxBenchmarkObligationDefault[*];
}

Association cdm_assoc::FxDisruptionEvents_FxDualExchangeRate_dualExchangeRate
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    dualExchangeRate: legaldoc::FxDualExchangeRate[*];
}

Association cdm_assoc::FxDisruptionEvents_FxInconvertibilityOrNonTransferability_inconvertibilityOrNonTransferability
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    inconvertibilityOrNonTransferability: legaldoc::FxInconvertibilityOrNonTransferability[*];
}

Association cdm_assoc::FxDisruptionEvents_GovernmentalAuthorityDefault_governmentalAuthorityDefault
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    governmentalAuthorityDefault: legaldoc::GovernmentalAuthorityDefault[*];
}

Association cdm_assoc::FxDisruptionEvents_Illiquidity_illiquidity
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    illiquidity: legaldoc::Illiquidity[*];
}

Association cdm_assoc::FxDisruptionEvents_MaterialChangeInCircumstance_materialChangeInCircumstance
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    materialChangeInCircumstance: legaldoc::MaterialChangeInCircumstance[*];
}

Association cdm_assoc::FxDisruptionEvents_Nationalization_nationalization
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    nationalization: legaldoc::Nationalization[*];
}

Association cdm_assoc::FxDisruptionEvents_PriceMateriality_priceMateriality
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    priceMateriality: legaldoc::PriceMateriality[*];
}

Association cdm_assoc::FxDisruptionEvents_Clause_fallbackLanguageBespokeTerms
{
    fxDisruptionEvents: legaldoc::FxDisruptionEvents[*];
    fallbackLanguageBespokeTerms: legaldoc::Clause[*];
}

Association cdm_assoc::GovernmentalAuthorityDefault_ValuationPostponement_maximumDaysOfDisruption
{
    governmentalAuthorityDefault: legaldoc::GovernmentalAuthorityDefault[*];
    maximumDaysOfDisruption: observable::ValuationPostponement[*];
}

Association cdm_assoc::Illiquidity_EscrowArrangement_escrowArrangement
{
    illiquidity: legaldoc::Illiquidity[*];
    escrowArrangement: legaldoc::EscrowArrangement[*];
}

Association cdm_assoc::Illiquidity_SettlementRateOption_fallbackReferencePrice
{
    illiquidity: legaldoc::Illiquidity[*];
    fallbackReferencePrice: observable::SettlementRateOption[*];
}

Association cdm_assoc::Illiquidity_AdjustedRelativeDateOffset_illiquidityValuationDate
{
    illiquidity: legaldoc::Illiquidity[*];
    illiquidityValuationDate: datetime::AdjustedRelativeDateOffset[*];
}

Association cdm_assoc::MaterialChangeInCircumstance_ValuationPostponement_maximumDaysOfDisruption
{
    materialChangeInCircumstance: legaldoc::MaterialChangeInCircumstance[*];
    maximumDaysOfDisruption: observable::ValuationPostponement[*];
}

Association cdm_assoc::Nationalization_EscrowArrangement_escrowArrangement
{
    nationalization: legaldoc::Nationalization[*];
    escrowArrangement: legaldoc::EscrowArrangement[*];
}

Association cdm_assoc::Nationalization_ValuationPostponement_maximumDaysOfDisruption
{
    nationalization: legaldoc::Nationalization[*];
    maximumDaysOfDisruption: observable::ValuationPostponement[*];
}

Association cdm_assoc::PriceMateriality_SettlementRateOption_fallbackReferencePrice
{
    priceMateriality: legaldoc::PriceMateriality[*];
    fallbackReferencePrice: observable::SettlementRateOption[*];
}

Association cdm_assoc::FxPriceSourceDisruption_EscrowArrangement_escrowArrangement
{
    fxPriceSourceDisruption: legaldoc::FxPriceSourceDisruption[*];
    escrowArrangement: legaldoc::EscrowArrangement[*];
}

Association cdm_assoc::FxBenchmarkObligationDefault_EscrowArrangement_escrowArrangement
{
    fxBenchmarkObligationDefault: legaldoc::FxBenchmarkObligationDefault[*];
    escrowArrangement: legaldoc::EscrowArrangement[*];
}

Association cdm_assoc::FxDualExchangeRate_EscrowArrangement_escrowArrangement
{
    fxDualExchangeRate: legaldoc::FxDualExchangeRate[*];
    escrowArrangement: legaldoc::EscrowArrangement[*];
}

Association cdm_assoc::FxInconvertibilityOrNonTransferability_GeneralInconvertibility_generalInconvertibility
{
    fxInconvertibilityOrNonTransferability: legaldoc::FxInconvertibilityOrNonTransferability[*];
    generalInconvertibility: legaldoc::GeneralInconvertibility[*];
}

Association cdm_assoc::FxInconvertibilityOrNonTransferability_GeneralNonTransferability_generalNonTransferability
{
    fxInconvertibilityOrNonTransferability: legaldoc::FxInconvertibilityOrNonTransferability[*];
    generalNonTransferability: legaldoc::GeneralNonTransferability[*];
}

Association cdm_assoc::FxInconvertibilityOrNonTransferability_SpecificInconvertibility_specificInconvertibility
{
    fxInconvertibilityOrNonTransferability: legaldoc::FxInconvertibilityOrNonTransferability[*];
    specificInconvertibility: legaldoc::SpecificInconvertibility[*];
}

Association cdm_assoc::FxInconvertibilityOrNonTransferability_SpecificNonTransferability_specificNonTransferability
{
    fxInconvertibilityOrNonTransferability: legaldoc::FxInconvertibilityOrNonTransferability[*];
    specificNonTransferability: legaldoc::SpecificNonTransferability[*];
}

Association cdm_assoc::GeneralInconvertibility_ValuationPostponement_maximumDaysOfDisruption
{
    generalInconvertibility: legaldoc::GeneralInconvertibility[*];
    maximumDaysOfDisruption: observable::ValuationPostponement[*];
}

Association cdm_assoc::GeneralInconvertibility_NonDeliverableSubstitute_nonDeliverableSubstitute
{
    generalInconvertibility: legaldoc::GeneralInconvertibility[*];
    nonDeliverableSubstitute: legaldoc::NonDeliverableSubstitute[*];
}

Association cdm_assoc::GeneralNonTransferability_ValuationPostponement_maximumDaysOfDisruption
{
    generalNonTransferability: legaldoc::GeneralNonTransferability[*];
    maximumDaysOfDisruption: observable::ValuationPostponement[*];
}

Association cdm_assoc::GeneralNonTransferability_NonDeliverableSubstitute_nonDeliverableSubstitute
{
    generalNonTransferability: legaldoc::GeneralNonTransferability[*];
    nonDeliverableSubstitute: legaldoc::NonDeliverableSubstitute[*];
}

Association cdm_assoc::SpecificInconvertibility_ValuationPostponement_maximumDaysOfDisruption
{
    specificInconvertibility: legaldoc::SpecificInconvertibility[*];
    maximumDaysOfDisruption: observable::ValuationPostponement[*];
}

Association cdm_assoc::SpecificInconvertibility_NonDeliverableSubstitute_nonDeliverableSubstitute
{
    specificInconvertibility: legaldoc::SpecificInconvertibility[*];
    nonDeliverableSubstitute: legaldoc::NonDeliverableSubstitute[*];
}

Association cdm_assoc::SpecificNonTransferability_ValuationPostponement_maximumDaysOfDisruption
{
    specificNonTransferability: legaldoc::SpecificNonTransferability[*];
    maximumDaysOfDisruption: observable::ValuationPostponement[*];
}

Association cdm_assoc::SpecificNonTransferability_EscrowArrangement_escrowArrangement
{
    specificNonTransferability: legaldoc::SpecificNonTransferability[*];
    escrowArrangement: legaldoc::EscrowArrangement[*];
}

Association cdm_assoc::EscrowArrangement_Clause_bespokeEscrowArrangements
{
    escrowArrangement: legaldoc::EscrowArrangement[*];
    bespokeEscrowArrangements: legaldoc::Clause[*];
}

Association cdm_assoc::EventCurrency_BuyerSeller_eventCurrencyBuyerSeller
{
    eventCurrency: legaldoc::EventCurrency[*];
    eventCurrencyBuyerSeller: party::BuyerSeller[*];
}

Association cdm_assoc::NonDeliverableSubstitute_AdjustedRelativeDateOffset_settlementDate
{
    nonDeliverableSubstitute: legaldoc::NonDeliverableSubstitute[*];
    settlementDate: datetime::AdjustedRelativeDateOffset[*];
}

Association cdm_assoc::TransactionAdditionalTerms_EquityAdditionalTerms_equityAdditionalTerms
{
    transactionAdditionalTerms: legaldoc::TransactionAdditionalTerms[*];
    equityAdditionalTerms: legaldoc::EquityAdditionalTerms[*];
}

Association cdm_assoc::EquityAdditionalTerms_ExtraordinaryEvents_extraordinaryEvents
{
    equityAdditionalTerms: legaldoc::EquityAdditionalTerms[*];
    extraordinaryEvents: legaldoc::ExtraordinaryEvents[*];
}

Association cdm_assoc::EquityAdditionalTerms_UnderlierSubstitutionProvision_substitutionProvision
{
    equityAdditionalTerms: legaldoc::EquityAdditionalTerms[*];
    substitutionProvision: legaldoc::UnderlierSubstitutionProvision[*];
}

Association cdm_assoc::UnderlierSubstitutionProvision_Clause_substitutionBeSpokeTerms
{
    underlierSubstitutionProvision: legaldoc::UnderlierSubstitutionProvision[*];
    substitutionBeSpokeTerms: legaldoc::Clause[*];
}

Association cdm_assoc::UnderlierSubstitutionProvision_ExtraordinaryEvents_substitutionTriggerEvents
{
    underlierSubstitutionProvision: legaldoc::UnderlierSubstitutionProvision[*];
    substitutionTriggerEvents: legaldoc::ExtraordinaryEvents[*];
}

Association cdm_assoc::ExtraordinaryEvents_Clause_additionalBespokeTerms
{
    extraordinaryEvents: legaldoc::ExtraordinaryEvents[*];
    additionalBespokeTerms: legaldoc::Clause[*];
}

Association cdm_assoc::ExtraordinaryEvents_EquityCorporateEvents_mergerEvents
{
    extraordinaryEvents: legaldoc::ExtraordinaryEvents[*];
    mergerEvents: legaldoc::EquityCorporateEvents[*];
}

Association cdm_assoc::ExtraordinaryEvents_AdditionalDisruptionEvents_additionalDisruptionEvents
{
    extraordinaryEvents: legaldoc::ExtraordinaryEvents[*];
    additionalDisruptionEvents: legaldoc::AdditionalDisruptionEvents[*];
}

Association cdm_assoc::ExtraordinaryEvents_Representations_representations
{
    extraordinaryEvents: legaldoc::ExtraordinaryEvents[*];
    representations: legaldoc::Representations[*];
}

Association cdm_assoc::AdditionalDisruptionEvents_Clause_additionalBespokeTerms
{
    additionalDisruptionEvents: legaldoc::AdditionalDisruptionEvents[*];
    additionalBespokeTerms: legaldoc::Clause[*];
}

Association cdm_assoc::EquitySwapMasterConfirmation2018_PriceReturnTerms_pricingMethodElection
{
    equitySwapMasterConfirmation2018: legaldoc::EquitySwapMasterConfirmation2018[*];
    pricingMethodElection: product::PriceReturnTerms[*];
}

Association cdm_assoc::EquitySwapMasterConfirmation2018_SettlementTerms_settlementTerms
{
    equitySwapMasterConfirmation2018: legaldoc::EquitySwapMasterConfirmation2018[*];
    settlementTerms: settlement::SettlementTerms[*];
}

Association cdm_assoc::EquitySwapMasterConfirmation2018_ValuationDates_valuationDates
{
    equitySwapMasterConfirmation2018: legaldoc::EquitySwapMasterConfirmation2018[*];
    valuationDates: observable::ValuationDates[*];
}

Association cdm_assoc::EquitySwapMasterConfirmation2018_PaymentDates_equityCashSettlementDates
{
    equitySwapMasterConfirmation2018: legaldoc::EquitySwapMasterConfirmation2018[*];
    equityCashSettlementDates: schedule::PaymentDates[*];
}

Association cdm_assoc::StandardizedScheduleInitialMargin_StandardizedScheduleTradeInfo_tradeInfo
{
    standardizedScheduleInitialMargin: margin::StandardizedScheduleInitialMargin[*];
    tradeInfo: margin::StandardizedScheduleTradeInfo[*];
}

Association cdm_assoc::MeasureBase_UnitType_unit
{
    measureBase: math::MeasureBase[*];
    unit: math::UnitType[*];
}

Association cdm_assoc::MeasureSchedule_DatedValue_datedValue
{
    measureSchedule: math::MeasureSchedule[*];
    datedValue: math::DatedValue[*];
}

Association cdm_assoc::QuantitySchedule_Frequency_frequency
{
    quantitySchedule: math::QuantitySchedule[*];
    frequency: datetime::Frequency[*];
}

Association cdm_assoc::Schedule_DatedValue_datedValue
{
    schedule: math::Schedule[*];
    datedValue: math::DatedValue[*];
}

Association cdm_assoc::NumberRange_NumberBound_lowerBound
{
    numberRange: math::NumberRange[*];
    lowerBound: math::NumberBound[*];
}

Association cdm_assoc::NumberRange_NumberBound_upperBound
{
    numberRange: math::NumberRange[*];
    upperBound: math::NumberBound[*];
}

Association cdm_assoc::MoneyRange_MoneyBound_lowerBound
{
    moneyRange: math::MoneyRange[*];
    lowerBound: math::MoneyBound[*];
}

Association cdm_assoc::MoneyRange_MoneyBound_upperBound
{
    moneyRange: math::MoneyRange[*];
    upperBound: math::MoneyBound[*];
}

Association cdm_assoc::FloatingRateCalculationParameters_ObservationShiftCalculation_observationShiftCalculation
{
    floatingRateCalculationParameters: observable::FloatingRateCalculationParameters[*];
    observationShiftCalculation: observable::ObservationShiftCalculation[*];
}

Association cdm_assoc::FloatingRateCalculationParameters_OffsetCalculation_lookbackCalculation
{
    floatingRateCalculationParameters: observable::FloatingRateCalculationParameters[*];
    lookbackCalculation: observable::OffsetCalculation[*];
}

Association cdm_assoc::FloatingRateCalculationParameters_OffsetCalculation_lockoutCalculation
{
    floatingRateCalculationParameters: observable::FloatingRateCalculationParameters[*];
    lockoutCalculation: observable::OffsetCalculation[*];
}

Association cdm_assoc::FloatingRateCalculationParameters_BusinessCenters_applicableBusinessDays
{
    floatingRateCalculationParameters: observable::FloatingRateCalculationParameters[*];
    applicableBusinessDays: datetime::BusinessCenters[*];
}

Association cdm_assoc::FloatingRateCalculationParameters_ObservationParameters_observationParameters
{
    floatingRateCalculationParameters: observable::FloatingRateCalculationParameters[*];
    observationParameters: observable::ObservationParameters[*];
}

Association cdm_assoc::FallbackRateParameters_FloatingRateCalculationParameters_calculationParameters
{
    fallbackRateParameters: observable::FallbackRateParameters[*];
    calculationParameters: observable::FloatingRateCalculationParameters[*];
}

Association cdm_assoc::ObservationShiftCalculation_BusinessCenters_additionalBusinessDays
{
    observationShiftCalculation: observable::ObservationShiftCalculation[*];
    additionalBusinessDays: datetime::BusinessCenters[*];
}

Association cdm_assoc::CalculatedRateDetails_CalculatedRateObservations_observations
{
    calculatedRateDetails: observable::CalculatedRateDetails[*];
    observations: observable::CalculatedRateObservations[*];
}

Association cdm_assoc::FloatingRateIndexDefinition_FloatingRateIndexIdentification_fro
{
    floatingRateIndexDefinition: observable::FloatingRateIndexDefinition[*];
    fro: observable::FloatingRateIndexIdentification[*];
}

Association cdm_assoc::FloatingRateIndexDefinition_FloatingRateIndexCalculationDefaults_calculationDefaults
{
    floatingRateIndexDefinition: observable::FloatingRateIndexDefinition[*];
    calculationDefaults: observable::FloatingRateIndexCalculationDefaults[*];
}

Association cdm_assoc::FloatingRateIndexDefinition_ContractualDefinition_supportedDefinition
{
    floatingRateIndexDefinition: observable::FloatingRateIndexDefinition[*];
    supportedDefinition: observable::ContractualDefinition[*];
}

Association cdm_assoc::FloatingRateIndexDefinition_FloatingRateIndexExternalMappings_externalMappings
{
    floatingRateIndexDefinition: observable::FloatingRateIndexDefinition[*];
    externalMappings: observable::FloatingRateIndexExternalMappings[*];
}

Association cdm_assoc::FloatingRateIndexDefinition_FroHistory_history
{
    floatingRateIndexDefinition: observable::FloatingRateIndexDefinition[*];
    history: observable::FroHistory[*];
}

Association cdm_assoc::FloatingRateIndexCalculationDefaults_FloatingRateIndexFixingDetails_fixing
{
    floatingRateIndexCalculationDefaults: observable::FloatingRateIndexCalculationDefaults[*];
    fixing: observable::FloatingRateIndexFixingDetails[*];
}

Association cdm_assoc::FloatingRateIndexCalculationDefaults_BusinessCenters_applicableBusinessDays
{
    floatingRateIndexCalculationDefaults: observable::FloatingRateIndexCalculationDefaults[*];
    applicableBusinessDays: datetime::BusinessCenters[*];
}

Association cdm_assoc::ContractualDefinition_Identifier_identifier
{
    contractualDefinition: observable::ContractualDefinition[*];
    identifier: identifier::Identifier[*];
}

Association cdm_assoc::ContractualDefinition_ContractualDefinitionIdentifier_contractualDefinitionIdentifier
{
    contractualDefinition: observable::ContractualDefinition[*];
    contractualDefinitionIdentifier: observable::ContractualDefinitionIdentifier[*];
}

Association cdm_assoc::FloatingRateIndexMap_ContractualDefinitionIdentifier_contractualDefinitionIdentifier
{
    floatingRateIndexMap: observable::FloatingRateIndexMap[*];
    contractualDefinitionIdentifier: observable::ContractualDefinitionIdentifier[*];
}

Association cdm_assoc::FloatingRateIndexMap_Identifier_identifier
{
    floatingRateIndexMap: observable::FloatingRateIndexMap[*];
    identifier: identifier::Identifier[*];
}

Association cdm_assoc::FloatingRateIndexMappings_FloatingRateIndexMap_mapsTo
{
    floatingRateIndexMappings: observable::FloatingRateIndexMappings[*];
    mapsTo: observable::FloatingRateIndexMap[*];
}

Association cdm_assoc::FloatingRateIndexMappings_FloatingRateIndexMap_mapsFrom
{
    floatingRateIndexMappings: observable::FloatingRateIndexMappings[*];
    mapsFrom: observable::FloatingRateIndexMap[*];
}

Association cdm_assoc::FloatingRateIndexExternalMappings_FloatingRateIndexExternalMap_isoCode
{
    floatingRateIndexExternalMappings: observable::FloatingRateIndexExternalMappings[*];
    isoCode: observable::FloatingRateIndexExternalMap[*];
}

Association cdm_assoc::FroHistory_ContractualDefinition_firstDefinedIn
{
    froHistory: observable::FroHistory[*];
    firstDefinedIn: observable::ContractualDefinition[*];
}

Association cdm_assoc::FroHistory_ContractualDefinition_lastUpdatedIn
{
    froHistory: observable::FroHistory[*];
    lastUpdatedIn: observable::ContractualDefinition[*];
}

Association cdm_assoc::FloatingRateIndexFixingDetails_FloatingRateIndexFixingTime_fixingTime
{
    floatingRateIndexFixingDetails: observable::FloatingRateIndexFixingDetails[*];
    fixingTime: observable::FloatingRateIndexFixingTime[*];
}

Association cdm_assoc::FloatingRateIndexFixingDetails_BusinessDayOffset_fixingOffset
{
    floatingRateIndexFixingDetails: observable::FloatingRateIndexFixingDetails[*];
    fixingOffset: observable::BusinessDayOffset[*];
}

Association cdm_assoc::BusinessDayOffset_BusinessCenters_businessCenters
{
    businessDayOffset: observable::BusinessDayOffset[*];
    businessCenters: datetime::BusinessCenters[*];
}

Association cdm_assoc::IndexBase_LegalEntity_provider
{
    indexBase: observable::IndexBase[*];
    provider: party::LegalEntity[*];
}

Association cdm_assoc::FloatingRateIndex_Period_indexTenor
{
    floatingRateIndex: observable::FloatingRateIndex[*];
    indexTenor: datetime::Period[*];
}

Association cdm_assoc::ForeignExchangeRateIndex_QuotedCurrencyPair_quotedCurrencyPair
{
    foreignExchangeRateIndex: observable::ForeignExchangeRateIndex[*];
    quotedCurrencyPair: observable::QuotedCurrencyPair[*];
}

Association cdm_assoc::ForeignExchangeRateIndex_InformationSource_primaryFxSpotRateSource
{
    foreignExchangeRateIndex: observable::ForeignExchangeRateIndex[*];
    primaryFxSpotRateSource: observable::InformationSource[*];
}

Association cdm_assoc::ForeignExchangeRateIndex_InformationSource_secondaryFxSpotRateSource
{
    foreignExchangeRateIndex: observable::ForeignExchangeRateIndex[*];
    secondaryFxSpotRateSource: observable::InformationSource[*];
}

Association cdm_assoc::InflationIndex_Period_indexTenor
{
    inflationIndex: observable::InflationIndex[*];
    indexTenor: datetime::Period[*];
}

Association cdm_assoc::CreditIndex_ReferenceInformation_excludedReferenceEntity
{
    creditIndex: observable::CreditIndex[*];
    excludedReferenceEntity: product::ReferenceInformation[*];
}

Association cdm_assoc::CreditIndex_Tranche_tranche
{
    creditIndex: observable::CreditIndex[*];
    tranche: product::Tranche[*];
}

Association cdm_assoc::CreditIndex_SettledEntityMatrix_settledEntityMatrix
{
    creditIndex: observable::CreditIndex[*];
    settledEntityMatrix: product::SettledEntityMatrix[*];
}

Association cdm_assoc::PriceQuantity_PriceSchedule_price
{
    priceQuantity: observable::PriceQuantity[*];
    price: observable::PriceSchedule[*];
}

Association cdm_assoc::PriceQuantity_AdjustableOrRelativeDate_effectiveDate
{
    priceQuantity: observable::PriceQuantity[*];
    effectiveDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::CashPrice_PremiumExpression_premiumExpression
{
    cashPrice: observable::CashPrice[*];
    premiumExpression: observable::PremiumExpression[*];
}

Association cdm_assoc::PriceSchedule_UnitType_perUnitOf
{
    priceSchedule: observable::PriceSchedule[*];
    perUnitOf: math::UnitType[*];
}

Association cdm_assoc::PriceSchedule_PriceComposite_composite
{
    priceSchedule: observable::PriceSchedule[*];
    composite: observable::PriceComposite[*];
}

Association cdm_assoc::Basket_BasketConstituent_basketConstituent
{
    basket: observable::Basket[*];
    basketConstituent: observable::BasketConstituent[*];
}

Association cdm_assoc::BasketConstituent_PriceSchedule_initialValuationPrice
{
    basketConstituent: observable::BasketConstituent[*];
    initialValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::BasketConstituent_PriceSchedule_interimValuationPrice
{
    basketConstituent: observable::BasketConstituent[*];
    interimValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::BasketConstituent_PriceSchedule_finalValuationPrice
{
    basketConstituent: observable::BasketConstituent[*];
    finalValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::Curve_InterestRateCurve_interestRateCurve
{
    curve: observable::Curve[*];
    interestRateCurve: observable::InterestRateCurve[*];
}

Association cdm_assoc::InterestRateCurve_Period_tenor
{
    interestRateCurve: observable::InterestRateCurve[*];
    tenor: datetime::Period[*];
}

Association cdm_assoc::ReferenceSwapCurve_SwapCurveValuation_swapUnwindValue
{
    referenceSwapCurve: observable::ReferenceSwapCurve[*];
    swapUnwindValue: observable::SwapCurveValuation[*];
}

Association cdm_assoc::ValuationDates_PerformanceValuationDates_initialValuationDate
{
    valuationDates: observable::ValuationDates[*];
    initialValuationDate: observable::PerformanceValuationDates[*];
}

Association cdm_assoc::ValuationDates_PerformanceValuationDates_interimValuationDate
{
    valuationDates: observable::ValuationDates[*];
    interimValuationDate: observable::PerformanceValuationDates[*];
}

Association cdm_assoc::ValuationDates_PerformanceValuationDates_finalValuationDate
{
    valuationDates: observable::ValuationDates[*];
    finalValuationDate: observable::PerformanceValuationDates[*];
}

Association cdm_assoc::PerformanceValuationDates_AdjustableRelativeOrPeriodicDates_valuationDates
{
    performanceValuationDates: observable::PerformanceValuationDates[*];
    valuationDates: datetime::AdjustableRelativeOrPeriodicDates[*];
}

Association cdm_assoc::PerformanceValuationDates_AdjustableOrRelativeDate_valuationDate
{
    performanceValuationDates: observable::PerformanceValuationDates[*];
    valuationDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::PerformanceValuationDates_BusinessCenterTime_valuationTime
{
    performanceValuationDates: observable::PerformanceValuationDates[*];
    valuationTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::FxRateSourceFixing_FxSettlementRateSource_settlementRateSource
{
    fxRateSourceFixing: observable::FxRateSourceFixing[*];
    settlementRateSource: observable::FxSettlementRateSource[*];
}

Association cdm_assoc::FxInformationSource_BusinessCenterTime_fixingTime
{
    fxInformationSource: observable::FxInformationSource[*];
    fixingTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::FallbackReferencePrice_ValuationPostponement_valuationPostponement
{
    fallbackReferencePrice: observable::FallbackReferencePrice[*];
    valuationPostponement: observable::ValuationPostponement[*];
}

Association cdm_assoc::FallbackReferencePrice_CalculationAgent_calculationAgentDetermination
{
    fallbackReferencePrice: observable::FallbackReferencePrice[*];
    calculationAgentDetermination: observable::CalculationAgent[*];
}

Association cdm_assoc::FxRate_QuotedCurrencyPair_quotedCurrencyPair
{
    fxRate: observable::FxRate[*];
    quotedCurrencyPair: observable::QuotedCurrencyPair[*];
}

Association cdm_assoc::FxSpotRateSource_InformationSource_primarySource
{
    fxSpotRateSource: observable::FxSpotRateSource[*];
    primarySource: observable::InformationSource[*];
}

Association cdm_assoc::FxSpotRateSource_InformationSource_secondarySource
{
    fxSpotRateSource: observable::FxSpotRateSource[*];
    secondarySource: observable::InformationSource[*];
}

Association cdm_assoc::CreditNotation_CreditRatingDebt_debt
{
    creditNotation: observable::CreditNotation[*];
    debt: observable::CreditRatingDebt[*];
}

Association cdm_assoc::CreditNotations_CreditNotation_creditNotation
{
    creditNotations: observable::CreditNotations[*];
    creditNotation: observable::CreditNotation[*];
}

Association cdm_assoc::CreditNotations_MultipleCreditNotations_creditNotations
{
    creditNotations: observable::CreditNotations[*];
    creditNotations: observable::MultipleCreditNotations[*];
}

Association cdm_assoc::CreditRatingDebt_MultipleDebtTypes_debtTypes
{
    creditRatingDebt: observable::CreditRatingDebt[*];
    debtTypes: observable::MultipleDebtTypes[*];
}

Association cdm_assoc::MultipleCreditNotations_CreditNotation_creditNotation
{
    multipleCreditNotations: observable::MultipleCreditNotations[*];
    creditNotation: observable::CreditNotation[*];
}

Association cdm_assoc::FxSettlementRateSource_FxInformationSource_nonstandardSettlementRate
{
    fxSettlementRateSource: observable::FxSettlementRateSource[*];
    nonstandardSettlementRate: observable::FxInformationSource[*];
}

Association cdm_assoc::SettlementRateOption_PriceSourceDisruption_priceSourceDisruption
{
    settlementRateOption: observable::SettlementRateOption[*];
    priceSourceDisruption: observable::PriceSourceDisruption[*];
}

Association cdm_assoc::ValuationSource_QuotedCurrencyPair_quotedCurrencyPair
{
    valuationSource: observable::ValuationSource[*];
    quotedCurrencyPair: observable::QuotedCurrencyPair[*];
}

Association cdm_assoc::ValuationSource_FxSpotRateSource_informationSource
{
    valuationSource: observable::ValuationSource[*];
    informationSource: observable::FxSpotRateSource[*];
}

Association cdm_assoc::ValuationSource_SettlementRateOption_settlementRateOption
{
    valuationSource: observable::ValuationSource[*];
    settlementRateOption: observable::SettlementRateOption[*];
}

Association cdm_assoc::ValuationSource_ReferenceBanks_referenceBanks
{
    valuationSource: observable::ValuationSource[*];
    referenceBanks: party::ReferenceBanks[*];
}

Association cdm_assoc::ValuationSource_AncillaryEntity_dealerOrCCP
{
    valuationSource: observable::ValuationSource[*];
    dealerOrCCP: party::AncillaryEntity[*];
}

Association cdm_assoc::PriceSourceDisruption_FallbackReferencePrice_fallbackReferencePrice
{
    priceSourceDisruption: observable::PriceSourceDisruption[*];
    fallbackReferencePrice: observable::FallbackReferencePrice[*];
}

Association cdm_assoc::ValuationMethod_ValuationSource_valuationSource
{
    valuationMethod: observable::ValuationMethod[*];
    valuationSource: observable::ValuationSource[*];
}

Association cdm_assoc::ValuationMethod_CashCollateralValuationMethod_cashCollateralValuationMethod
{
    valuationMethod: observable::ValuationMethod[*];
    cashCollateralValuationMethod: observable::CashCollateralValuationMethod[*];
}

Association cdm_assoc::Trigger_PriceSchedule_level
{
    trigger: observable::Trigger[*];
    level: observable::PriceSchedule[*];
}

Association cdm_assoc::Trigger_CreditEvents_creditEvents
{
    trigger: observable::Trigger[*];
    creditEvents: observable::CreditEvents[*];
}

Association cdm_assoc::TriggerEvent_AveragingSchedule_schedule
{
    triggerEvent: observable::TriggerEvent[*];
    schedule: datetime::AveragingSchedule[*];
}

Association cdm_assoc::TriggerEvent_DateList_triggerDates
{
    triggerEvent: observable::TriggerEvent[*];
    triggerDates: datetime::DateList[*];
}

Association cdm_assoc::TriggerEvent_Trigger_trigger
{
    triggerEvent: observable::TriggerEvent[*];
    trigger: observable::Trigger[*];
}

Association cdm_assoc::TriggerEvent_FeaturePayment_featurePayment
{
    triggerEvent: observable::TriggerEvent[*];
    featurePayment: observable::FeaturePayment[*];
}

Association cdm_assoc::CreditEvents_FailureToPay_failureToPay
{
    creditEvents: observable::CreditEvents[*];
    failureToPay: observable::FailureToPay[*];
}

Association cdm_assoc::CreditEvents_Restructuring_restructuring
{
    creditEvents: observable::CreditEvents[*];
    restructuring: observable::Restructuring[*];
}

Association cdm_assoc::CreditEvents_CreditEventNotice_creditEventNotice
{
    creditEvents: observable::CreditEvents[*];
    creditEventNotice: observable::CreditEventNotice[*];
}

Association cdm_assoc::CreditEventNotice_PubliclyAvailableInformation_publiclyAvailableInformation
{
    creditEventNotice: observable::CreditEventNotice[*];
    publiclyAvailableInformation: observable::PubliclyAvailableInformation[*];
}

Association cdm_assoc::FailureToPay_GracePeriodExtension_gracePeriodExtension
{
    failureToPay: observable::FailureToPay[*];
    gracePeriodExtension: observable::GracePeriodExtension[*];
}

Association cdm_assoc::GracePeriodExtension_Offset_gracePeriod
{
    gracePeriodExtension: observable::GracePeriodExtension[*];
    gracePeriod: datetime::Offset[*];
}

Association cdm_assoc::FeaturePayment_PartyReferencePayerReceiver_payerReceiver
{
    featurePayment: observable::FeaturePayment[*];
    payerReceiver: party::PartyReferencePayerReceiver[*];
}

Association cdm_assoc::FeaturePayment_AdjustableOrRelativeDate_paymentDate
{
    featurePayment: observable::FeaturePayment[*];
    paymentDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::Observation_ObservationIdentifier_observationIdentifier
{
    observation: observable::Observation[*];
    observationIdentifier: observable::ObservationIdentifier[*];
}

Association cdm_assoc::ObservationIdentifier_TimeZone_observationTime
{
    observationIdentifier: observable::ObservationIdentifier[*];
    observationTime: datetime::TimeZone[*];
}

Association cdm_assoc::ObservationIdentifier_InformationSource_informationSource
{
    observationIdentifier: observable::ObservationIdentifier[*];
    informationSource: observable::InformationSource[*];
}

Association cdm_assoc::ObservationIdentifier_DeterminationMethodology_determinationMethodology
{
    observationIdentifier: observable::ObservationIdentifier[*];
    determinationMethodology: observable::DeterminationMethodology[*];
}

Association cdm_assoc::Counterparty_Party_partyReference
{
    counterparty: party::Counterparty[*];
    partyReference: party::Party[*];
}

Association cdm_assoc::AncillaryParty_Party_partyReference
{
    ancillaryParty: party::AncillaryParty[*];
    partyReference: party::Party[*];
}

Association cdm_assoc::PartyReferencePayerReceiver_Party_payerPartyReference
{
    partyReferencePayerReceiver: party::PartyReferencePayerReceiver[*];
    payerPartyReference: party::Party[*];
}

Association cdm_assoc::PartyReferencePayerReceiver_Account_payerAccountReference
{
    partyReferencePayerReceiver: party::PartyReferencePayerReceiver[*];
    payerAccountReference: party::Account[*];
}

Association cdm_assoc::PartyReferencePayerReceiver_Party_receiverPartyReference
{
    partyReferencePayerReceiver: party::PartyReferencePayerReceiver[*];
    receiverPartyReference: party::Party[*];
}

Association cdm_assoc::PartyReferencePayerReceiver_Account_receiverAccountReference
{
    partyReferencePayerReceiver: party::PartyReferencePayerReceiver[*];
    receiverAccountReference: party::Account[*];
}

Association cdm_assoc::ReferenceBanks_ReferenceBank_referenceBank
{
    referenceBanks: party::ReferenceBanks[*];
    referenceBank: party::ReferenceBank[*];
}

Association cdm_assoc::RelatedParty_Party_partyReference
{
    relatedParty: party::RelatedParty[*];
    partyReference: party::Party[*];
}

Association cdm_assoc::RelatedParty_Account_accountReference
{
    relatedParty: party::RelatedParty[*];
    accountReference: party::Account[*];
}

Association cdm_assoc::Account_Party_partyReference
{
    account: party::Account[*];
    partyReference: party::Party[*];
}

Association cdm_assoc::Account_Party_accountBeneficiary
{
    account: party::Account[*];
    accountBeneficiary: party::Party[*];
}

Association cdm_assoc::Account_Party_servicingParty
{
    account: party::Account[*];
    servicingParty: party::Party[*];
}

Association cdm_assoc::BusinessUnit_Identifier_identifier
{
    businessUnit: party::BusinessUnit[*];
    identifier: identifier::Identifier[*];
}

Association cdm_assoc::BusinessUnit_ContactInformation_contactInformation
{
    businessUnit: party::BusinessUnit[*];
    contactInformation: party::ContactInformation[*];
}

Association cdm_assoc::ContactInformation_TelephoneNumber_telephone
{
    contactInformation: party::ContactInformation[*];
    telephone: party::TelephoneNumber[*];
}

Association cdm_assoc::ContactInformation_Address_address
{
    contactInformation: party::ContactInformation[*];
    address: party::Address[*];
}

Association cdm_assoc::LegalEntity_EntityIdentifier_entityIdentifier
{
    legalEntity: party::LegalEntity[*];
    entityIdentifier: party::EntityIdentifier[*];
}

Association cdm_assoc::NaturalPerson_PersonIdentifier_personId
{
    naturalPerson: party::NaturalPerson[*];
    personId: party::PersonIdentifier[*];
}

Association cdm_assoc::NaturalPerson_ContactInformation_contactInformation
{
    naturalPerson: party::NaturalPerson[*];
    contactInformation: party::ContactInformation[*];
}

Association cdm_assoc::NaturalPersonRole_NaturalPerson_personReference
{
    naturalPersonRole: party::NaturalPersonRole[*];
    personReference: party::NaturalPerson[*];
}

Association cdm_assoc::Party_PartyIdentifier_partyId
{
    party: party::Party[*];
    partyId: party::PartyIdentifier[*];
}

Association cdm_assoc::Party_BusinessUnit_businessUnit
{
    party: party::Party[*];
    businessUnit: party::BusinessUnit[*];
}

Association cdm_assoc::Party_NaturalPerson_person
{
    party: party::Party[*];
    person: party::NaturalPerson[*];
}

Association cdm_assoc::Party_NaturalPersonRole_personRole
{
    party: party::Party[*];
    personRole: party::NaturalPersonRole[*];
}

Association cdm_assoc::Party_Account_account
{
    party: party::Party[*];
    account: party::Account[*];
}

Association cdm_assoc::Party_ContactInformation_contactInformation
{
    party: party::Party[*];
    contactInformation: party::ContactInformation[*];
}

Association cdm_assoc::PartyRole_Party_partyReference
{
    partyRole: party::PartyRole[*];
    partyReference: party::Party[*];
}

Association cdm_assoc::PartyRole_Party_ownershipPartyReference
{
    partyRole: party::PartyRole[*];
    ownershipPartyReference: party::Party[*];
}

Association cdm_assoc::AncillaryEntity_LegalEntity_legalEntity
{
    ancillaryEntity: party::AncillaryEntity[*];
    legalEntity: party::LegalEntity[*];
}

Association cdm_assoc::ContractBase_ContractDetails_contractDetails
{
    contractBase: position::ContractBase[*];
    contractDetails: event::ContractDetails[*];
}

Association cdm_assoc::ContractBase_ExecutionDetails_executionDetails
{
    contractBase: position::ContractBase[*];
    executionDetails: event::ExecutionDetails[*];
}

Association cdm_assoc::ContractBase_Collateral_collateral
{
    contractBase: position::ContractBase[*];
    collateral: collateral::Collateral[*];
}

Association cdm_assoc::CounterpartyPosition_PositionIdentifier_positionIdentifier
{
    counterpartyPosition: position::CounterpartyPosition[*];
    positionIdentifier: event::PositionIdentifier[*];
}

Association cdm_assoc::CounterpartyPosition_TradeState_tradeReference
{
    counterpartyPosition: position::CounterpartyPosition[*];
    tradeReference: event::TradeState[*];
}

Association cdm_assoc::CounterpartyPosition_Party_party
{
    counterpartyPosition: position::CounterpartyPosition[*];
    party: party::Party[*];
}

Association cdm_assoc::CounterpartyPosition_PartyRole_partyRole
{
    counterpartyPosition: position::CounterpartyPosition[*];
    partyRole: party::PartyRole[*];
}

Association cdm_assoc::CounterpartyPosition_TradableProduct_positionBase
{
    counterpartyPosition: position::CounterpartyPosition[*];
    positionBase: template::TradableProduct[*];
}

Association cdm_assoc::PositionBase_PriceQuantity_priceQuantity
{
    positionBase: position::PositionBase[*];
    priceQuantity: observable::PriceQuantity[*];
}

Association cdm_assoc::PositionBase_TradeState_tradeReference
{
    positionBase: position::PositionBase[*];
    tradeReference: event::TradeState[*];
}

Association cdm_assoc::PortfolioState_Lineage_lineage
{
    portfolioState: position::PortfolioState[*];
    lineage: event::Lineage[*];
}

Association cdm_assoc::AggregationParameters_Party_party
{
    aggregationParameters: position::AggregationParameters[*];
    party: party::Party[*];
}

Association cdm_assoc::AggregationParameters_NonTransferableProduct_product
{
    aggregationParameters: position::AggregationParameters[*];
    product: template::NonTransferableProduct[*];
}

Association cdm_assoc::AggregationParameters_Trade_tradeReference
{
    aggregationParameters: position::AggregationParameters[*];
    tradeReference: event::Trade[*];
}

Association cdm_assoc::Portfolio_AggregationParameters_aggregationParameters
{
    portfolio: position::Portfolio[*];
    aggregationParameters: position::AggregationParameters[*];
}

Association cdm_assoc::Portfolio_PortfolioState_portfolioState
{
    portfolio: position::Portfolio[*];
    portfolioState: position::PortfolioState[*];
}

Association cdm_assoc::Inventory_InventoryRecord_inventoryRecord
{
    inventory: position::Inventory[*];
    inventoryRecord: position::InventoryRecord[*];
}

Association cdm_assoc::InventoryRecord_AssignedIdentifier_identifer
{
    inventoryRecord: position::InventoryRecord[*];
    identifer: identifier::AssignedIdentifier[*];
}

Association cdm_assoc::InventoryRecord_Security_security
{
    inventoryRecord: position::InventoryRecord[*];
    security: asset::Security[*];
}

Association cdm_assoc::AvailableInventory_MessageInformation_messageInformation
{
    availableInventory: position::AvailableInventory[*];
    messageInformation: workflow::MessageInformation[*];
}

Association cdm_assoc::AvailableInventory_Party_party
{
    availableInventory: position::AvailableInventory[*];
    party: party::Party[*];
}

Association cdm_assoc::AvailableInventory_PartyRole_partyRole
{
    availableInventory: position::AvailableInventory[*];
    partyRole: party::PartyRole[*];
}

Association cdm_assoc::AvailableInventory_AvailableInventoryRecord_availableInventoryRecord
{
    availableInventory: position::AvailableInventory[*];
    availableInventoryRecord: position::AvailableInventoryRecord[*];
}

Association cdm_assoc::AvailableInventoryRecord_CollateralProvisions_collateral
{
    availableInventoryRecord: position::AvailableInventoryRecord[*];
    collateral: collateral::CollateralProvisions[*];
}

Association cdm_assoc::AvailableInventoryRecord_PartyRole_partyRole
{
    availableInventoryRecord: position::AvailableInventoryRecord[*];
    partyRole: party::PartyRole[*];
}

Association cdm_assoc::FloatingAmountCalculationDetails_CalculationPeriodBase_calculationPeriod
{
    floatingAmountCalculationDetails: product::FloatingAmountCalculationDetails[*];
    calculationPeriod: schedule::CalculationPeriodBase[*];
}

Association cdm_assoc::FloatingAmountCalculationDetails_FloatingRateSettingDetails_floatingRate
{
    floatingAmountCalculationDetails: product::FloatingAmountCalculationDetails[*];
    floatingRate: product::FloatingRateSettingDetails[*];
}

Association cdm_assoc::FloatingAmountCalculationDetails_FloatingRateProcessingDetails_processingDetails
{
    floatingAmountCalculationDetails: product::FloatingAmountCalculationDetails[*];
    processingDetails: product::FloatingRateProcessingDetails[*];
}

Association cdm_assoc::FloatingRateSettingDetails_CalculatedRateDetails_calculationDetails
{
    floatingRateSettingDetails: product::FloatingRateSettingDetails[*];
    calculationDetails: observable::CalculatedRateDetails[*];
}

Association cdm_assoc::FloatingRateProcessingDetails_FloatingRateProcessingParameters_processingParameters
{
    floatingRateProcessingDetails: product::FloatingRateProcessingDetails[*];
    processingParameters: product::FloatingRateProcessingParameters[*];
}

Association cdm_assoc::FloatingRateProcessingParameters_Rounding_rounding
{
    floatingRateProcessingParameters: product::FloatingRateProcessingParameters[*];
    rounding: math::Rounding[*];
}

Association cdm_assoc::CommodityPayout_AveragingCalculation_averagingFeature
{
    commodityPayout: product::CommodityPayout[*];
    averagingFeature: template::AveragingCalculation[*];
}

Association cdm_assoc::CommodityPayout_CommodityPriceReturnTerms_commodityPriceReturnTerms
{
    commodityPayout: product::CommodityPayout[*];
    commodityPriceReturnTerms: settlement::CommodityPriceReturnTerms[*];
}

Association cdm_assoc::CommodityPayout_PricingDates_pricingDates
{
    commodityPayout: product::CommodityPayout[*];
    pricingDates: settlement::PricingDates[*];
}

Association cdm_assoc::CommodityPayout_CalculationSchedule_schedule
{
    commodityPayout: product::CommodityPayout[*];
    schedule: template::CalculationSchedule[*];
}

Association cdm_assoc::CommodityPayout_CalculationPeriodDates_calculationPeriodDates
{
    commodityPayout: product::CommodityPayout[*];
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
}

Association cdm_assoc::CommodityPayout_PaymentDates_paymentDates
{
    commodityPayout: product::CommodityPayout[*];
    paymentDates: schedule::PaymentDates[*];
}

Association cdm_assoc::CommodityPayout_FxFeature_fxFeature
{
    commodityPayout: product::CommodityPayout[*];
    fxFeature: template::FxFeature[*];
}

Association cdm_assoc::CommodityPayout_AssetDeliveryInformation_delivery
{
    commodityPayout: product::CommodityPayout[*];
    delivery: product::AssetDeliveryInformation[*];
}

Association cdm_assoc::AssetDeliveryInformation_AssetDeliveryPeriods_periods
{
    assetDeliveryInformation: product::AssetDeliveryInformation[*];
    periods: product::AssetDeliveryPeriods[*];
}

Association cdm_assoc::AssetDeliveryInformation_LocationIdentifier_location
{
    assetDeliveryInformation: product::AssetDeliveryInformation[*];
    location: identifier::LocationIdentifier[*];
}

Association cdm_assoc::AssetDeliveryPeriods_AssetDeliveryProfile_profile
{
    assetDeliveryPeriods: product::AssetDeliveryPeriods[*];
    profile: product::AssetDeliveryProfile[*];
}

Association cdm_assoc::AssetDeliveryProfile_AssetDeliveryProfileBlock_block
{
    assetDeliveryProfile: product::AssetDeliveryProfile[*];
    block: product::AssetDeliveryProfileBlock[*];
}

Association cdm_assoc::CreditDefaultPayout_GeneralTerms_generalTerms
{
    creditDefaultPayout: product::CreditDefaultPayout[*];
    generalTerms: product::GeneralTerms[*];
}

Association cdm_assoc::CreditDefaultPayout_ProtectionTerms_protectionTerms
{
    creditDefaultPayout: product::CreditDefaultPayout[*];
    protectionTerms: product::ProtectionTerms[*];
}

Association cdm_assoc::CreditDefaultPayout_TransactedPrice_transactedPrice
{
    creditDefaultPayout: product::CreditDefaultPayout[*];
    transactedPrice: observable::TransactedPrice[*];
}

Association cdm_assoc::GeneralTerms_ReferenceInformation_referenceInformation
{
    generalTerms: product::GeneralTerms[*];
    referenceInformation: product::ReferenceInformation[*];
}

Association cdm_assoc::GeneralTerms_CreditIndex_indexReferenceInformation
{
    generalTerms: product::GeneralTerms[*];
    indexReferenceInformation: observable::CreditIndex[*];
}

Association cdm_assoc::GeneralTerms_BasketReferenceInformation_basketReferenceInformation
{
    generalTerms: product::GeneralTerms[*];
    basketReferenceInformation: product::BasketReferenceInformation[*];
}

Association cdm_assoc::InterestRatePayout_CalculationPeriodDates_calculationPeriodDates
{
    interestRatePayout: product::InterestRatePayout[*];
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
}

Association cdm_assoc::InterestRatePayout_PaymentDates_paymentDates
{
    interestRatePayout: product::InterestRatePayout[*];
    paymentDates: schedule::PaymentDates[*];
}

Association cdm_assoc::InterestRatePayout_AdjustableDate_paymentDate
{
    interestRatePayout: product::InterestRatePayout[*];
    paymentDate: datetime::AdjustableDate[*];
}

Association cdm_assoc::InterestRatePayout_ResetDates_resetDates
{
    interestRatePayout: product::InterestRatePayout[*];
    resetDates: schedule::ResetDates[*];
}

Association cdm_assoc::InterestRatePayout_DiscountingMethod_discountingMethod
{
    interestRatePayout: product::InterestRatePayout[*];
    discountingMethod: product::DiscountingMethod[*];
}

Association cdm_assoc::InterestRatePayout_CashflowRepresentation_cashflowRepresentation
{
    interestRatePayout: product::InterestRatePayout[*];
    cashflowRepresentation: product::CashflowRepresentation[*];
}

Association cdm_assoc::InterestRatePayout_StubPeriod_stubPeriod
{
    interestRatePayout: product::InterestRatePayout[*];
    stubPeriod: schedule::StubPeriod[*];
}

Association cdm_assoc::InterestRatePayout_BondReference_bondReference
{
    interestRatePayout: product::InterestRatePayout[*];
    bondReference: product::BondReference[*];
}

Association cdm_assoc::DividendPayoutRatio_BasketConstituent_basketConstituent
{
    dividendPayoutRatio: product::DividendPayoutRatio[*];
    basketConstituent: observable::BasketConstituent[*];
}

Association cdm_assoc::BasketReferenceInformation_ReferencePool_referencePool
{
    basketReferenceInformation: product::BasketReferenceInformation[*];
    referencePool: product::ReferencePool[*];
}

Association cdm_assoc::BasketReferenceInformation_Tranche_tranche
{
    basketReferenceInformation: product::BasketReferenceInformation[*];
    tranche: product::Tranche[*];
}

Association cdm_assoc::FloatingAmountEvents_InterestShortFall_interestShortfall
{
    floatingAmountEvents: product::FloatingAmountEvents[*];
    interestShortfall: product::InterestShortFall[*];
}

Association cdm_assoc::FloatingAmountEvents_FloatingAmountProvisions_floatingAmountProvisions
{
    floatingAmountEvents: product::FloatingAmountEvents[*];
    floatingAmountProvisions: product::FloatingAmountProvisions[*];
}

Association cdm_assoc::FloatingAmountEvents_AdditionalFixedPayments_additionalFixedPayments
{
    floatingAmountEvents: product::FloatingAmountEvents[*];
    additionalFixedPayments: product::AdditionalFixedPayments[*];
}

Association cdm_assoc::ProtectionTerms_CreditEvents_creditEvents
{
    protectionTerms: product::ProtectionTerms[*];
    creditEvents: observable::CreditEvents[*];
}

Association cdm_assoc::ProtectionTerms_Obligations_obligations
{
    protectionTerms: product::ProtectionTerms[*];
    obligations: credit::Obligations[*];
}

Association cdm_assoc::ProtectionTerms_FloatingAmountEvents_floatingAmountEvents
{
    protectionTerms: product::ProtectionTerms[*];
    floatingAmountEvents: product::FloatingAmountEvents[*];
}

Association cdm_assoc::ReferenceInformation_LegalEntity_referenceEntity
{
    referenceInformation: product::ReferenceInformation[*];
    referenceEntity: party::LegalEntity[*];
}

Association cdm_assoc::ReferenceInformation_ReferenceObligation_referenceObligation
{
    referenceInformation: product::ReferenceInformation[*];
    referenceObligation: product::ReferenceObligation[*];
}

Association cdm_assoc::ReferenceObligation_Security_security
{
    referenceObligation: product::ReferenceObligation[*];
    security: asset::Security[*];
}

Association cdm_assoc::ReferenceObligation_Loan_loan
{
    referenceObligation: product::ReferenceObligation[*];
    loan: asset::Loan[*];
}

Association cdm_assoc::ReferenceObligation_LegalEntity_primaryObligor
{
    referenceObligation: product::ReferenceObligation[*];
    primaryObligor: party::LegalEntity[*];
}

Association cdm_assoc::ReferenceObligation_LegalEntity_primaryObligorReference
{
    referenceObligation: product::ReferenceObligation[*];
    primaryObligorReference: party::LegalEntity[*];
}

Association cdm_assoc::ReferenceObligation_LegalEntity_guarantor
{
    referenceObligation: product::ReferenceObligation[*];
    guarantor: party::LegalEntity[*];
}

Association cdm_assoc::ReferencePair_LegalEntity_referenceEntity
{
    referencePair: product::ReferencePair[*];
    referenceEntity: party::LegalEntity[*];
}

Association cdm_assoc::ReferencePair_ReferenceObligation_referenceObligation
{
    referencePair: product::ReferencePair[*];
    referenceObligation: product::ReferenceObligation[*];
}

Association cdm_assoc::ReferencePool_ReferencePoolItem_referencePoolItem
{
    referencePool: product::ReferencePool[*];
    referencePoolItem: product::ReferencePoolItem[*];
}

Association cdm_assoc::ReferencePoolItem_ConstituentWeight_constituentWeight
{
    referencePoolItem: product::ReferencePoolItem[*];
    constituentWeight: template::ConstituentWeight[*];
}

Association cdm_assoc::ReferencePoolItem_ReferencePair_referencePair
{
    referencePoolItem: product::ReferencePoolItem[*];
    referencePair: product::ReferencePair[*];
}

Association cdm_assoc::ReferencePoolItem_CashSettlementTerms_cashSettlementTermsReference
{
    referencePoolItem: product::ReferencePoolItem[*];
    cashSettlementTermsReference: settlement::CashSettlementTerms[*];
}

Association cdm_assoc::ReferencePoolItem_PhysicalSettlementTerms_physicalSettlementTermsReference
{
    referencePoolItem: product::ReferencePoolItem[*];
    physicalSettlementTermsReference: settlement::PhysicalSettlementTerms[*];
}

Association cdm_assoc::DividendDateReference_Offset_paymentDateOffset
{
    dividendDateReference: product::DividendDateReference[*];
    paymentDateOffset: datetime::Offset[*];
}

Association cdm_assoc::DividendPaymentDate_DividendDateReference_dividendDateReference
{
    dividendPaymentDate: product::DividendPaymentDate[*];
    dividendDateReference: product::DividendDateReference[*];
}

Association cdm_assoc::DividendReturnTerms_DividendPayoutRatio_dividendPayoutRatio
{
    dividendReturnTerms: product::DividendReturnTerms[*];
    dividendPayoutRatio: product::DividendPayoutRatio[*];
}

Association cdm_assoc::DividendReturnTerms_DividendCurrency_dividendCurrency
{
    dividendReturnTerms: product::DividendReturnTerms[*];
    dividendCurrency: product::DividendCurrency[*];
}

Association cdm_assoc::DividendReturnTerms_DividendPeriod_dividendPeriod
{
    dividendReturnTerms: product::DividendReturnTerms[*];
    dividendPeriod: product::DividendPeriod[*];
}

Association cdm_assoc::DividendPeriod_DividendPaymentDate_startDate
{
    dividendPeriod: product::DividendPeriod[*];
    startDate: product::DividendPaymentDate[*];
}

Association cdm_assoc::DividendPeriod_DividendPaymentDate_endDate
{
    dividendPeriod: product::DividendPeriod[*];
    endDate: product::DividendPaymentDate[*];
}

Association cdm_assoc::DividendPeriod_BusinessDayAdjustments_dateAdjustments
{
    dividendPeriod: product::DividendPeriod[*];
    dateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::DividendPeriod_BasketConstituent_basketConstituent
{
    dividendPeriod: product::DividendPeriod[*];
    basketConstituent: observable::BasketConstituent[*];
}

Association cdm_assoc::DividendPeriod_DividendPaymentDate_dividendPaymentDate
{
    dividendPeriod: product::DividendPeriod[*];
    dividendPaymentDate: product::DividendPaymentDate[*];
}

Association cdm_assoc::DividendPeriod_AdjustableOrRelativeDate_dividendValuationDate
{
    dividendPeriod: product::DividendPeriod[*];
    dividendValuationDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::ReturnTermsBase_ValuationTerms_valuationTerms
{
    returnTermsBase: product::ReturnTermsBase[*];
    valuationTerms: product::ValuationTerms[*];
}

Association cdm_assoc::ReturnTermsBase_DividendApplicability_dividendApplicability
{
    returnTermsBase: product::ReturnTermsBase[*];
    dividendApplicability: observable::DividendApplicability[*];
}

Association cdm_assoc::ReturnTermsBase_EquityUnderlierProvisions_equityUnderlierProvisions
{
    returnTermsBase: product::ReturnTermsBase[*];
    equityUnderlierProvisions: product::EquityUnderlierProvisions[*];
}

Association cdm_assoc::VarianceReturnTerms_VarianceCapFloor_varianceCapFloor
{
    varianceReturnTerms: product::VarianceReturnTerms[*];
    varianceCapFloor: product::VarianceCapFloor[*];
}

Association cdm_assoc::VarianceReturnTerms_VolatilityCapFloor_volatilityCapFloor
{
    varianceReturnTerms: product::VarianceReturnTerms[*];
    volatilityCapFloor: product::VolatilityCapFloor[*];
}

Association cdm_assoc::VolatilityReturnTerms_VolatilityCapFloor_volatilityCapFloor
{
    volatilityReturnTerms: product::VolatilityReturnTerms[*];
    volatilityCapFloor: product::VolatilityCapFloor[*];
}

Association cdm_assoc::VolatilityReturnTerms_ListedDerivative_exchangeTradedContractNearest
{
    volatilityReturnTerms: product::VolatilityReturnTerms[*];
    exchangeTradedContractNearest: asset::ListedDerivative[*];
}

Association cdm_assoc::CorrelationReturnTerms_NumberRange_boundedCorrelation
{
    correlationReturnTerms: product::CorrelationReturnTerms[*];
    boundedCorrelation: math::NumberRange[*];
}

Association cdm_assoc::ValuationTerms_AdjustableRelativeOrPeriodicDates_dividendValuationDates
{
    valuationTerms: product::ValuationTerms[*];
    dividendValuationDates: datetime::AdjustableRelativeOrPeriodicDates[*];
}

Association cdm_assoc::VarianceCapFloor_BoundedVariance_boundedVariance
{
    varianceCapFloor: product::VarianceCapFloor[*];
    boundedVariance: product::BoundedVariance[*];
}

Association cdm_assoc::ForeignExchange_Cashflow_exchangedCurrency1
{
    foreignExchange: product::ForeignExchange[*];
    exchangedCurrency1: settlement::Cashflow[*];
}

Association cdm_assoc::ForeignExchange_Cashflow_exchangedCurrency2
{
    foreignExchange: product::ForeignExchange[*];
    exchangedCurrency2: settlement::Cashflow[*];
}

Association cdm_assoc::ForeignExchange_Period_tenorPeriod
{
    foreignExchange: product::ForeignExchange[*];
    tenorPeriod: datetime::Period[*];
}

Association cdm_assoc::BondReference_Security_bond
{
    bondReference: product::BondReference[*];
    bond: asset::Security[*];
}

Association cdm_assoc::BondReference_FixedRateSpecification_couponRate
{
    bondReference: product::BondReference[*];
    couponRate: product::FixedRateSpecification[*];
}

Association cdm_assoc::CashflowRepresentation_PaymentCalculationPeriod_paymentCalculationPeriod
{
    cashflowRepresentation: product::CashflowRepresentation[*];
    paymentCalculationPeriod: schedule::PaymentCalculationPeriod[*];
}

Association cdm_assoc::FloatingRateDefinition_RateObservation_rateObservation
{
    floatingRateDefinition: product::FloatingRateDefinition[*];
    rateObservation: observable::RateObservation[*];
}

Association cdm_assoc::FloatingRateDefinition_Strike_capRate
{
    floatingRateDefinition: product::FloatingRateDefinition[*];
    capRate: template::Strike[*];
}

Association cdm_assoc::FloatingRateDefinition_Strike_floorRate
{
    floatingRateDefinition: product::FloatingRateDefinition[*];
    floorRate: template::Strike[*];
}

Association cdm_assoc::InflationRateSpecification_Offset_inflationLag
{
    inflationRateSpecification: product::InflationRateSpecification[*];
    inflationLag: datetime::Offset[*];
}

Association cdm_assoc::FloatingRateBase_SpreadSchedule_spreadSchedule
{
    floatingRateBase: product::FloatingRateBase[*];
    spreadSchedule: product::SpreadSchedule[*];
}

Association cdm_assoc::FloatingRateBase_StrikeSchedule_capRateSchedule
{
    floatingRateBase: product::FloatingRateBase[*];
    capRateSchedule: template::StrikeSchedule[*];
}

Association cdm_assoc::FloatingRateBase_StrikeSchedule_floorRateSchedule
{
    floatingRateBase: product::FloatingRateBase[*];
    floorRateSchedule: template::StrikeSchedule[*];
}

Association cdm_assoc::FloatingRate_RateSchedule_floatingRateMultiplierSchedule
{
    floatingRate: product::FloatingRate[*];
    floatingRateMultiplierSchedule: schedule::RateSchedule[*];
}

Association cdm_assoc::FloatingRate_FloatingRateCalculationParameters_calculationParameters
{
    floatingRate: product::FloatingRate[*];
    calculationParameters: observable::FloatingRateCalculationParameters[*];
}

Association cdm_assoc::FloatingRate_FallbackRateParameters_fallbackRate
{
    floatingRate: product::FloatingRate[*];
    fallbackRate: observable::FallbackRateParameters[*];
}

Association cdm_assoc::FloatingRateSpecification_Rounding_finalRateRounding
{
    floatingRateSpecification: product::FloatingRateSpecification[*];
    finalRateRounding: math::Rounding[*];
}

Association cdm_assoc::FixedRateSpecification_RateSchedule_rateSchedule
{
    fixedRateSpecification: product::FixedRateSpecification[*];
    rateSchedule: schedule::RateSchedule[*];
}

Association cdm_assoc::StubFloatingRate_Period_indexTenor
{
    stubFloatingRate: product::StubFloatingRate[*];
    indexTenor: datetime::Period[*];
}

Association cdm_assoc::StubFloatingRate_Schedule_floatingRateMultiplierSchedule
{
    stubFloatingRate: product::StubFloatingRate[*];
    floatingRateMultiplierSchedule: math::Schedule[*];
}

Association cdm_assoc::StubFloatingRate_SpreadSchedule_spreadSchedule
{
    stubFloatingRate: product::StubFloatingRate[*];
    spreadSchedule: product::SpreadSchedule[*];
}

Association cdm_assoc::StubFloatingRate_StrikeSchedule_capRateSchedule
{
    stubFloatingRate: product::StubFloatingRate[*];
    capRateSchedule: template::StrikeSchedule[*];
}

Association cdm_assoc::StubFloatingRate_StrikeSchedule_floorRateSchedule
{
    stubFloatingRate: product::StubFloatingRate[*];
    floorRateSchedule: template::StrikeSchedule[*];
}

Association cdm_assoc::StubValue_StubFloatingRate_floatingRate
{
    stubValue: product::StubValue[*];
    floatingRate: product::StubFloatingRate[*];
}

Association cdm_assoc::FixedAmountCalculationDetails_CalculationPeriodBase_calculationPeriod
{
    fixedAmountCalculationDetails: product::FixedAmountCalculationDetails[*];
    calculationPeriod: schedule::CalculationPeriodBase[*];
}

Association cdm_assoc::Document_FinInstrmRptgTxRpt_finInstrmRptgTxRpt
{
    document: regulation::Document[*];
    finInstrmRptgTxRpt: regulation::FinInstrmRptgTxRpt[*];
}

Association cdm_assoc::FinInstrmRptgTxRpt_Tx_tx
{
    finInstrmRptgTxRpt: regulation::FinInstrmRptgTxRpt[*];
    tx: regulation::Tx[*];
}

Association cdm_assoc::Tx_New_newTx
{
    tx: regulation::Tx[*];
    newTx: regulation::New[*];
}

Association cdm_assoc::Tx_Qty_qty
{
    tx: regulation::Tx[*];
    qty: regulation::Qty[*];
}

Association cdm_assoc::Tx_Pric_pric
{
    tx: regulation::Tx[*];
    pric: regulation::Pric[*];
}

Association cdm_assoc::New_Buyr_buyr
{
    new: regulation::New[*];
    buyr: regulation::Buyr[*];
}

Association cdm_assoc::New_Sellr_sellr
{
    new: regulation::New[*];
    sellr: regulation::Sellr[*];
}

Association cdm_assoc::New_OrdrTrnsmssn_ordrTrnsmssn
{
    new: regulation::New[*];
    ordrTrnsmssn: regulation::OrdrTrnsmssn[*];
}

Association cdm_assoc::New_Tx_tx
{
    new: regulation::New[*];
    tx: regulation::Tx[*];
}

Association cdm_assoc::New_FinInstrm_finInstrm
{
    new: regulation::New[*];
    finInstrm: regulation::FinInstrm[*];
}

Association cdm_assoc::New_InvstmtDcsnPrsn_invstmtDcsnPrsn
{
    new: regulation::New[*];
    invstmtDcsnPrsn: regulation::InvstmtDcsnPrsn[*];
}

Association cdm_assoc::New_ExctgPrsn_exctgPrsn
{
    new: regulation::New[*];
    exctgPrsn: regulation::ExctgPrsn[*];
}

Association cdm_assoc::New_AddtlAttrbts_addtlAttrbts
{
    new: regulation::New[*];
    addtlAttrbts: regulation::AddtlAttrbts[*];
}

Association cdm_assoc::Sellr_AcctOwnr_acctOwnr
{
    sellr: regulation::Sellr[*];
    acctOwnr: regulation::AcctOwnr[*];
}

Association cdm_assoc::Sngl_Indx_indx
{
    sngl: regulation::Sngl[*];
    indx: regulation::Indx[*];
}

Association cdm_assoc::DerivInstrmAttrbts_UndrlygInstrm_undrlygInstrm
{
    derivInstrmAttrbts: regulation::DerivInstrmAttrbts[*];
    undrlygInstrm: regulation::UndrlygInstrm[*];
}

Association cdm_assoc::UndrlygInstrm_Swp_swp
{
    undrlygInstrm: regulation::UndrlygInstrm[*];
    swp: regulation::Swp[*];
}

Association cdm_assoc::AcctOwnr_Id_id
{
    acctOwnr: regulation::AcctOwnr[*];
    id: regulation::Id[*];
}

Association cdm_assoc::InvstmtDcsnPrsn_Prsn_prsn
{
    invstmtDcsnPrsn: regulation::InvstmtDcsnPrsn[*];
    prsn: regulation::Prsn[*];
}

Association cdm_assoc::Buyr_AcctOwnr_acctOwnr
{
    buyr: regulation::Buyr[*];
    acctOwnr: regulation::AcctOwnr[*];
}

Association cdm_assoc::FinInstrm_Othr_othr
{
    finInstrm: regulation::FinInstrm[*];
    othr: regulation::Othr[*];
}

Association cdm_assoc::Prsn_Othr_othr
{
    prsn: regulation::Prsn[*];
    othr: regulation::Othr[*];
}

Association cdm_assoc::Nm_RefRate_refRate
{
    nm: regulation::Nm[*];
    refRate: regulation::RefRate[*];
}

Association cdm_assoc::Nm_Term_term
{
    nm: regulation::Nm[*];
    term: regulation::Term[*];
}

Association cdm_assoc::SwpOut_Sngl_sngl
{
    swpOut: regulation::SwpOut[*];
    sngl: regulation::Sngl[*];
}

Association cdm_assoc::Othr_FinInstrmGnlAttrbts_finInstrmGnlAttrbts
{
    othr: regulation::Othr[*];
    finInstrmGnlAttrbts: regulation::FinInstrmGnlAttrbts[*];
}

Association cdm_assoc::Othr_DerivInstrmAttrbts_derivInstrmAttrbts
{
    othr: regulation::Othr[*];
    derivInstrmAttrbts: regulation::DerivInstrmAttrbts[*];
}

Association cdm_assoc::Othr_SchmeNm_schmeNm
{
    othr: regulation::Othr[*];
    schmeNm: regulation::SchmeNm[*];
}

Association cdm_assoc::ExctgPrsn_Prsn_prsn
{
    exctgPrsn: regulation::ExctgPrsn[*];
    prsn: regulation::Prsn[*];
}

Association cdm_assoc::Swp_SwpIn_swpIn
{
    swp: regulation::Swp[*];
    swpIn: regulation::SwpIn[*];
}

Association cdm_assoc::Swp_SwpOut_swpOut
{
    swp: regulation::Swp[*];
    swpOut: regulation::SwpOut[*];
}

Association cdm_assoc::SwpIn_Sngl_sngl
{
    swpIn: regulation::SwpIn[*];
    sngl: regulation::Sngl[*];
}

Association cdm_assoc::Indx_Nm_nm
{
    indx: regulation::Indx[*];
    nm: regulation::Nm[*];
}

Association cdm_assoc::StubPeriod_CalculationPeriodDates_calculationPeriodDatesReference
{
    stubPeriod: schedule::StubPeriod[*];
    calculationPeriodDatesReference: schedule::CalculationPeriodDates[*];
}

Association cdm_assoc::StubPeriod_StubValue_initialStub
{
    stubPeriod: schedule::StubPeriod[*];
    initialStub: product::StubValue[*];
}

Association cdm_assoc::StubPeriod_StubValue_finalStub
{
    stubPeriod: schedule::StubPeriod[*];
    finalStub: product::StubValue[*];
}

Association cdm_assoc::CalculationPeriod_FxLinkedNotionalAmount_fxLinkedNotionalAmount
{
    calculationPeriod: schedule::CalculationPeriod[*];
    fxLinkedNotionalAmount: schedule::FxLinkedNotionalAmount[*];
}

Association cdm_assoc::CalculationPeriod_FloatingRateDefinition_floatingRateDefinition
{
    calculationPeriod: schedule::CalculationPeriod[*];
    floatingRateDefinition: product::FloatingRateDefinition[*];
}

Association cdm_assoc::CalculationPeriodDates_AdjustableOrRelativeDate_effectiveDate
{
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
    effectiveDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::CalculationPeriodDates_AdjustableOrRelativeDate_terminationDate
{
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
    terminationDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::CalculationPeriodDates_BusinessDayAdjustments_calculationPeriodDatesAdjustments
{
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
    calculationPeriodDatesAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::CalculationPeriodDates_AdjustableOrRelativeDate_firstPeriodStartDate
{
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
    firstPeriodStartDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::CalculationPeriodDates_CalculationPeriodFrequency_calculationPeriodFrequency
{
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
    calculationPeriodFrequency: datetime::CalculationPeriodFrequency[*];
}

Association cdm_assoc::DateRelativeToCalculationPeriodDates_CalculationPeriodDates_calculationPeriodDatesReference
{
    dateRelativeToCalculationPeriodDates: schedule::DateRelativeToCalculationPeriodDates[*];
    calculationPeriodDatesReference: schedule::CalculationPeriodDates[*];
}

Association cdm_assoc::DateRelativeToValuationDates_PerformanceValuationDates_valuationDatesReference
{
    dateRelativeToValuationDates: schedule::DateRelativeToValuationDates[*];
    valuationDatesReference: observable::PerformanceValuationDates[*];
}

Association cdm_assoc::DateRelativeToPaymentDates_PaymentDates_paymentDatesReference
{
    dateRelativeToPaymentDates: schedule::DateRelativeToPaymentDates[*];
    paymentDatesReference: schedule::PaymentDates[*];
}

Association cdm_assoc::FxLinkedNotionalSchedule_RelativeDateOffset_varyingNotionalFixingDates
{
    fxLinkedNotionalSchedule: schedule::FxLinkedNotionalSchedule[*];
    varyingNotionalFixingDates: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::FxLinkedNotionalSchedule_FxSpotRateSource_fxSpotRateSource
{
    fxLinkedNotionalSchedule: schedule::FxLinkedNotionalSchedule[*];
    fxSpotRateSource: observable::FxSpotRateSource[*];
}

Association cdm_assoc::FxLinkedNotionalSchedule_BusinessCenterTime_fixingTime
{
    fxLinkedNotionalSchedule: schedule::FxLinkedNotionalSchedule[*];
    fixingTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::FxLinkedNotionalSchedule_RelativeDateOffset_varyingNotionalInterimExchangePaymentDates
{
    fxLinkedNotionalSchedule: schedule::FxLinkedNotionalSchedule[*];
    varyingNotionalInterimExchangePaymentDates: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::PaymentCalculationPeriod_CalculationPeriod_calculationPeriod
{
    paymentCalculationPeriod: schedule::PaymentCalculationPeriod[*];
    calculationPeriod: schedule::CalculationPeriod[*];
}

Association cdm_assoc::RateSchedule_PriceSchedule_price
{
    rateSchedule: schedule::RateSchedule[*];
    price: observable::PriceSchedule[*];
}

Association cdm_assoc::ObservationDates_ObservationSchedule_observationSchedule
{
    observationDates: schedule::ObservationDates[*];
    observationSchedule: schedule::ObservationSchedule[*];
}

Association cdm_assoc::ObservationDates_PeriodicDates_periodicSchedule
{
    observationDates: schedule::ObservationDates[*];
    periodicSchedule: datetime::PeriodicDates[*];
}

Association cdm_assoc::ObservationDates_ParametricDates_parametricDates
{
    observationDates: schedule::ObservationDates[*];
    parametricDates: schedule::ParametricDates[*];
}

Association cdm_assoc::ObservationSchedule_ObservationDate_observationDate
{
    observationSchedule: schedule::ObservationSchedule[*];
    observationDate: schedule::ObservationDate[*];
}

Association cdm_assoc::ObservationSchedule_BusinessDayAdjustments_dateAdjustments
{
    observationSchedule: schedule::ObservationSchedule[*];
    dateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::ObservationTerms_BusinessCenterTime_observationTime
{
    observationTerms: schedule::ObservationTerms[*];
    observationTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::ObservationTerms_FxSpotRateSource_informationSource
{
    observationTerms: schedule::ObservationTerms[*];
    informationSource: observable::FxSpotRateSource[*];
}

Association cdm_assoc::ObservationTerms_Rounding_precision
{
    observationTerms: schedule::ObservationTerms[*];
    precision: math::Rounding[*];
}

Association cdm_assoc::ObservationTerms_CalculationPeriodDates_calculationPeriodDates
{
    observationTerms: schedule::ObservationTerms[*];
    calculationPeriodDates: schedule::CalculationPeriodDates[*];
}

Association cdm_assoc::ObservationTerms_ObservationDates_observationDates
{
    observationTerms: schedule::ObservationTerms[*];
    observationDates: schedule::ObservationDates[*];
}

Association cdm_assoc::ParametricDates_Lag_lag
{
    parametricDates: schedule::ParametricDates[*];
    lag: schedule::Lag[*];
}

Association cdm_assoc::ParametricDates_BusinessCenters_businessCenters
{
    parametricDates: schedule::ParametricDates[*];
    businessCenters: datetime::BusinessCenters[*];
}

Association cdm_assoc::Lag_Offset_lagDuration
{
    lag: schedule::Lag[*];
    lagDuration: datetime::Offset[*];
}

Association cdm_assoc::Lag_Offset_firstObservationDateOffset
{
    lag: schedule::Lag[*];
    firstObservationDateOffset: datetime::Offset[*];
}

Association cdm_assoc::ResetDates_CalculationPeriodDates_calculationPeriodDatesReference
{
    resetDates: schedule::ResetDates[*];
    calculationPeriodDatesReference: schedule::CalculationPeriodDates[*];
}

Association cdm_assoc::ResetDates_InitialFixingDate_initialFixingDate
{
    resetDates: schedule::ResetDates[*];
    initialFixingDate: schedule::InitialFixingDate[*];
}

Association cdm_assoc::ResetDates_RelativeDateOffset_fixingDates
{
    resetDates: schedule::ResetDates[*];
    fixingDates: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::ResetDates_AdjustableDate_finalFixingDate
{
    resetDates: schedule::ResetDates[*];
    finalFixingDate: datetime::AdjustableDate[*];
}

Association cdm_assoc::ResetDates_Offset_rateCutOffDaysOffset
{
    resetDates: schedule::ResetDates[*];
    rateCutOffDaysOffset: datetime::Offset[*];
}

Association cdm_assoc::ResetDates_ResetFrequency_resetFrequency
{
    resetDates: schedule::ResetDates[*];
    resetFrequency: schedule::ResetFrequency[*];
}

Association cdm_assoc::ResetDates_BusinessDayAdjustments_resetDatesAdjustments
{
    resetDates: schedule::ResetDates[*];
    resetDatesAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::StubCalculationPeriodAmount_CalculationPeriodDates_calculationPeriodDatesReference
{
    stubCalculationPeriodAmount: schedule::StubCalculationPeriodAmount[*];
    calculationPeriodDatesReference: schedule::CalculationPeriodDates[*];
}

Association cdm_assoc::StubCalculationPeriodAmount_StubValue_initialStub
{
    stubCalculationPeriodAmount: schedule::StubCalculationPeriodAmount[*];
    initialStub: product::StubValue[*];
}

Association cdm_assoc::StubCalculationPeriodAmount_StubValue_finalStub
{
    stubCalculationPeriodAmount: schedule::StubCalculationPeriodAmount[*];
    finalStub: product::StubValue[*];
}

Association cdm_assoc::AveragingObservationList_WeightedAveragingObservation_averagingObservation
{
    averagingObservationList: schedule::AveragingObservationList[*];
    averagingObservation: schedule::WeightedAveragingObservation[*];
}

Association cdm_assoc::AveragingPeriod_AveragingSchedule_schedule
{
    averagingPeriod: schedule::AveragingPeriod[*];
    schedule: datetime::AveragingSchedule[*];
}

Association cdm_assoc::AveragingPeriod_DateTimeList_averagingDateTimes
{
    averagingPeriod: schedule::AveragingPeriod[*];
    averagingDateTimes: datetime::DateTimeList[*];
}

Association cdm_assoc::AveragingPeriod_AveragingObservationList_averagingObservations
{
    averagingPeriod: schedule::AveragingPeriod[*];
    averagingObservations: schedule::AveragingObservationList[*];
}

Association cdm_assoc::InitialFixingDate_RelativeDateOffset_relativeDateOffset
{
    initialFixingDate: schedule::InitialFixingDate[*];
    relativeDateOffset: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::PaymentDates_Frequency_paymentFrequency
{
    paymentDates: schedule::PaymentDates[*];
    paymentFrequency: datetime::Frequency[*];
}

Association cdm_assoc::PaymentDates_PaymentDateSchedule_paymentDateSchedule
{
    paymentDates: schedule::PaymentDates[*];
    paymentDateSchedule: schedule::PaymentDateSchedule[*];
}

Association cdm_assoc::PaymentDates_Offset_paymentDaysOffset
{
    paymentDates: schedule::PaymentDates[*];
    paymentDaysOffset: datetime::Offset[*];
}

Association cdm_assoc::PaymentDates_BusinessDayAdjustments_paymentDatesAdjustments
{
    paymentDates: schedule::PaymentDates[*];
    paymentDatesAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::PaymentDateSchedule_AdjustableRelativeOrPeriodicDates_interimPaymentDates
{
    paymentDateSchedule: schedule::PaymentDateSchedule[*];
    interimPaymentDates: datetime::AdjustableRelativeOrPeriodicDates[*];
}

Association cdm_assoc::FinalCalculationPeriodDateAdjustment_AdjustableOrRelativeDates_relevantUnderlyingDateReference
{
    finalCalculationPeriodDateAdjustment: schedule::FinalCalculationPeriodDateAdjustment[*];
    relevantUnderlyingDateReference: datetime::AdjustableOrRelativeDates[*];
}

Association cdm_assoc::FinalCalculationPeriodDateAdjustment_InterestRatePayout_swapStreamReference
{
    finalCalculationPeriodDateAdjustment: schedule::FinalCalculationPeriodDateAdjustment[*];
    swapStreamReference: product::InterestRatePayout[*];
}

Association cdm_assoc::AssetFlowBase_AdjustableOrAdjustedOrRelativeDate_settlementDate
{
    assetFlowBase: settlement::AssetFlowBase[*];
    settlementDate: datetime::AdjustableOrAdjustedOrRelativeDate[*];
}

Association cdm_assoc::Cashflow_PayerReceiver_payerReceiver
{
    cashflow: settlement::Cashflow[*];
    payerReceiver: party::PayerReceiver[*];
}

Association cdm_assoc::Cashflow_CashflowType_cashflowType
{
    cashflow: settlement::Cashflow[*];
    cashflowType: settlement::CashflowType[*];
}

Association cdm_assoc::Cashflow_PaymentDiscounting_paymentDiscounting
{
    cashflow: settlement::Cashflow[*];
    paymentDiscounting: settlement::PaymentDiscounting[*];
}

Association cdm_assoc::CashflowType_CashPrice_cashPrice
{
    cashflowType: settlement::CashflowType[*];
    cashPrice: observable::CashPrice[*];
}

Association cdm_assoc::QuantityMultiplier_FxLinkedNotionalSchedule_fxLinkedNotionalSchedule
{
    quantityMultiplier: settlement::QuantityMultiplier[*];
    fxLinkedNotionalSchedule: schedule::FxLinkedNotionalSchedule[*];
}

Association cdm_assoc::ResolvablePriceQuantity_QuantityMultiplier_quantityMultiplier
{
    resolvablePriceQuantity: settlement::ResolvablePriceQuantity[*];
    quantityMultiplier: settlement::QuantityMultiplier[*];
}

Association cdm_assoc::ResolvablePriceQuantity_FutureValueAmount_futureValueNotional
{
    resolvablePriceQuantity: settlement::ResolvablePriceQuantity[*];
    futureValueNotional: product::FutureValueAmount[*];
}

Association cdm_assoc::ResolvablePriceQuantity_PriceSchedule_priceSchedule
{
    resolvablePriceQuantity: settlement::ResolvablePriceQuantity[*];
    priceSchedule: observable::PriceSchedule[*];
}

Association cdm_assoc::PayoutBase_PayerReceiver_payerReceiver
{
    payoutBase: settlement::PayoutBase[*];
    payerReceiver: party::PayerReceiver[*];
}

Association cdm_assoc::PayoutBase_ResolvablePriceQuantity_priceQuantity
{
    payoutBase: settlement::PayoutBase[*];
    priceQuantity: settlement::ResolvablePriceQuantity[*];
}

Association cdm_assoc::PayoutBase_PrincipalPayments_principalPayment
{
    payoutBase: settlement::PayoutBase[*];
    principalPayment: settlement::PrincipalPayments[*];
}

Association cdm_assoc::PayoutBase_SettlementTerms_settlementTerms
{
    payoutBase: settlement::PayoutBase[*];
    settlementTerms: settlement::SettlementTerms[*];
}

Association cdm_assoc::CommodityPriceReturnTerms_Rounding_rounding
{
    commodityPriceReturnTerms: settlement::CommodityPriceReturnTerms[*];
    rounding: math::Rounding[*];
}

Association cdm_assoc::CommodityPriceReturnTerms_SpreadSchedule_spread
{
    commodityPriceReturnTerms: settlement::CommodityPriceReturnTerms[*];
    spread: product::SpreadSchedule[*];
}

Association cdm_assoc::CommodityPriceReturnTerms_RollFeature_rollFeature
{
    commodityPriceReturnTerms: settlement::CommodityPriceReturnTerms[*];
    rollFeature: settlement::RollFeature[*];
}

Association cdm_assoc::RollFeature_Offset_deliveryDateRollConvention
{
    rollFeature: settlement::RollFeature[*];
    deliveryDateRollConvention: datetime::Offset[*];
}

Association cdm_assoc::PricingDates_AdjustableDates_specifiedDates
{
    pricingDates: settlement::PricingDates[*];
    specifiedDates: datetime::AdjustableDates[*];
}

Association cdm_assoc::PricingDates_ParametricDates_parametricDates
{
    pricingDates: settlement::PricingDates[*];
    parametricDates: schedule::ParametricDates[*];
}

Association cdm_assoc::ValuationDate_SingleValuationDate_singleValuationDate
{
    valuationDate: settlement::ValuationDate[*];
    singleValuationDate: observable::SingleValuationDate[*];
}

Association cdm_assoc::ValuationDate_MultipleValuationDates_multipleValuationDates
{
    valuationDate: settlement::ValuationDate[*];
    multipleValuationDates: observable::MultipleValuationDates[*];
}

Association cdm_assoc::ValuationDate_RelativeDateOffset_valuationDate
{
    valuationDate: settlement::ValuationDate[*];
    valuationDate: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::ValuationDate_FxFixingDate_fxFixingDate
{
    valuationDate: settlement::ValuationDate[*];
    fxFixingDate: settlement::FxFixingDate[*];
}

Association cdm_assoc::ValuationDate_AdjustableDates_fxFixingSchedule
{
    valuationDate: settlement::ValuationDate[*];
    fxFixingSchedule: datetime::AdjustableDates[*];
}

Association cdm_assoc::CashSettlementTerms_ValuationMethod_valuationMethod
{
    cashSettlementTerms: settlement::CashSettlementTerms[*];
    valuationMethod: observable::ValuationMethod[*];
}

Association cdm_assoc::CashSettlementTerms_ValuationDate_valuationDate
{
    cashSettlementTerms: settlement::CashSettlementTerms[*];
    valuationDate: settlement::ValuationDate[*];
}

Association cdm_assoc::CashSettlementTerms_BusinessCenterTime_valuationTime
{
    cashSettlementTerms: settlement::CashSettlementTerms[*];
    valuationTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::DeliverableObligations_SpecifiedCurrency_specifiedCurrency
{
    deliverableObligations: settlement::DeliverableObligations[*];
    specifiedCurrency: credit::SpecifiedCurrency[*];
}

Association cdm_assoc::DeliverableObligations_NotDomesticCurrency_notDomesticCurrency
{
    deliverableObligations: settlement::DeliverableObligations[*];
    notDomesticCurrency: credit::NotDomesticCurrency[*];
}

Association cdm_assoc::DeliverableObligations_PCDeliverableObligationCharac_assignableLoan
{
    deliverableObligations: settlement::DeliverableObligations[*];
    assignableLoan: settlement::PCDeliverableObligationCharac[*];
}

Association cdm_assoc::DeliverableObligations_PCDeliverableObligationCharac_consentRequiredLoan
{
    deliverableObligations: settlement::DeliverableObligations[*];
    consentRequiredLoan: settlement::PCDeliverableObligationCharac[*];
}

Association cdm_assoc::DeliverableObligations_LoanParticipation_directLoanParticipation
{
    deliverableObligations: settlement::DeliverableObligations[*];
    directLoanParticipation: settlement::LoanParticipation[*];
}

Association cdm_assoc::DeliverableObligations_Period_maximumMaturity
{
    deliverableObligations: settlement::DeliverableObligations[*];
    maximumMaturity: datetime::Period[*];
}

Association cdm_assoc::DeliverableObligations_LoanParticipation_indirectLoanParticipation
{
    deliverableObligations: settlement::DeliverableObligations[*];
    indirectLoanParticipation: settlement::LoanParticipation[*];
}

Association cdm_assoc::PhysicalSettlementTerms_PhysicalSettlementPeriod_physicalSettlementPeriod
{
    physicalSettlementTerms: settlement::PhysicalSettlementTerms[*];
    physicalSettlementPeriod: settlement::PhysicalSettlementPeriod[*];
}

Association cdm_assoc::PhysicalSettlementTerms_DeliverableObligations_deliverableObligations
{
    physicalSettlementTerms: settlement::PhysicalSettlementTerms[*];
    deliverableObligations: settlement::DeliverableObligations[*];
}

Association cdm_assoc::SettlementDate_AdjustableOrAdjustedOrRelativeDate_adjustableOrRelativeDate
{
    settlementDate: settlement::SettlementDate[*];
    adjustableOrRelativeDate: datetime::AdjustableOrAdjustedOrRelativeDate[*];
}

Association cdm_assoc::SettlementDate_AdjustableDates_adjustableDates
{
    settlementDate: settlement::SettlementDate[*];
    adjustableDates: datetime::AdjustableDates[*];
}

Association cdm_assoc::SettlementDate_BusinessDateRange_businessDateRange
{
    settlementDate: settlement::SettlementDate[*];
    businessDateRange: datetime::BusinessDateRange[*];
}

Association cdm_assoc::FxFixingDate_BusinessCenters_businessCenters
{
    fxFixingDate: settlement::FxFixingDate[*];
    businessCenters: datetime::BusinessCenters[*];
}

Association cdm_assoc::FxFixingDate_DateRelativeToPaymentDates_dateRelativeToPaymentDates
{
    fxFixingDate: settlement::FxFixingDate[*];
    dateRelativeToPaymentDates: schedule::DateRelativeToPaymentDates[*];
}

Association cdm_assoc::FxFixingDate_DateRelativeToCalculationPeriodDates_dateRelativeToCalculationPeriodDates
{
    fxFixingDate: settlement::FxFixingDate[*];
    dateRelativeToCalculationPeriodDates: schedule::DateRelativeToCalculationPeriodDates[*];
}

Association cdm_assoc::FxFixingDate_DateRelativeToValuationDates_dateRelativeToValuationDates
{
    fxFixingDate: settlement::FxFixingDate[*];
    dateRelativeToValuationDates: schedule::DateRelativeToValuationDates[*];
}

Association cdm_assoc::FxFixingDate_AdjustableOrRelativeDate_fxFixingDate
{
    fxFixingDate: settlement::FxFixingDate[*];
    fxFixingDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::SettlementTerms_CashSettlementTerms_cashSettlementTerms
{
    settlementTerms: settlement::SettlementTerms[*];
    cashSettlementTerms: settlement::CashSettlementTerms[*];
}

Association cdm_assoc::SettlementTerms_PhysicalSettlementTerms_physicalSettlementTerms
{
    settlementTerms: settlement::SettlementTerms[*];
    physicalSettlementTerms: settlement::PhysicalSettlementTerms[*];
}

Association cdm_assoc::FixedPrice_PriceSchedule_price
{
    fixedPrice: settlement::FixedPrice[*];
    price: observable::PriceSchedule[*];
}

Association cdm_assoc::PaymentDetail_AdjustableOrRelativeDate_paymentDate
{
    paymentDetail: settlement::PaymentDetail[*];
    paymentDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::PaymentRule_PercentageRule_percentageRule
{
    paymentRule: settlement::PaymentRule[*];
    percentageRule: settlement::PercentageRule[*];
}

Association cdm_assoc::PrincipalPayments_PrincipalPaymentSchedule_principalPaymentSchedule
{
    principalPayments: settlement::PrincipalPayments[*];
    principalPaymentSchedule: settlement::PrincipalPaymentSchedule[*];
}

Association cdm_assoc::PrincipalPaymentSchedule_PrincipalPayment_initialPrincipalPayment
{
    principalPaymentSchedule: settlement::PrincipalPaymentSchedule[*];
    initialPrincipalPayment: settlement::PrincipalPayment[*];
}

Association cdm_assoc::PrincipalPaymentSchedule_AdjustableRelativeOrPeriodicDates_intermediatePrincipalPayment
{
    principalPaymentSchedule: settlement::PrincipalPaymentSchedule[*];
    intermediatePrincipalPayment: datetime::AdjustableRelativeOrPeriodicDates[*];
}

Association cdm_assoc::PrincipalPaymentSchedule_PrincipalPayment_finalPrincipalPayment
{
    principalPaymentSchedule: settlement::PrincipalPaymentSchedule[*];
    finalPrincipalPayment: settlement::PrincipalPayment[*];
}

Association cdm_assoc::PrincipalPayment_AdjustableDate_principalPaymentDate
{
    principalPayment: settlement::PrincipalPayment[*];
    principalPaymentDate: datetime::AdjustableDate[*];
}

Association cdm_assoc::PrincipalPayment_PayerReceiver_payerReceiver
{
    principalPayment: settlement::PrincipalPayment[*];
    payerReceiver: party::PayerReceiver[*];
}

Association cdm_assoc::SettlementBase_SettlementDate_settlementDate
{
    settlementBase: settlement::SettlementBase[*];
    settlementDate: settlement::SettlementDate[*];
}

Association cdm_assoc::SettlementBase_SettlementProvision_settlementProvision
{
    settlementBase: settlement::SettlementBase[*];
    settlementProvision: settlement::SettlementProvision[*];
}

Association cdm_assoc::SettlementProvision_ShapingProvision_shapingProvisions
{
    settlementProvision: settlement::SettlementProvision[*];
    shapingProvisions: settlement::ShapingProvision[*];
}

Association cdm_assoc::TransferableProduct_EconomicTerms_economicTerms
{
    transferableProduct: template::TransferableProduct[*];
    economicTerms: template::EconomicTerms[*];
}

Association cdm_assoc::EconomicTerms_AdjustableOrRelativeDate_effectiveDate
{
    economicTerms: template::EconomicTerms[*];
    effectiveDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::EconomicTerms_AdjustableOrRelativeDate_terminationDate
{
    economicTerms: template::EconomicTerms[*];
    terminationDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::EconomicTerms_BusinessDayAdjustments_dateAdjustments
{
    economicTerms: template::EconomicTerms[*];
    dateAdjustments: datetime::BusinessDayAdjustments[*];
}

Association cdm_assoc::EconomicTerms_TerminationProvision_terminationProvision
{
    economicTerms: template::EconomicTerms[*];
    terminationProvision: template::TerminationProvision[*];
}

Association cdm_assoc::EconomicTerms_CalculationAgent_calculationAgent
{
    economicTerms: template::EconomicTerms[*];
    calculationAgent: observable::CalculationAgent[*];
}

Association cdm_assoc::EconomicTerms_Collateral_collateral
{
    economicTerms: template::EconomicTerms[*];
    collateral: collateral::Collateral[*];
}

Association cdm_assoc::OptionPayout_BuyerSeller_buyerSeller
{
    optionPayout: template::OptionPayout[*];
    buyerSeller: party::BuyerSeller[*];
}

Association cdm_assoc::OptionPayout_ObservationTerms_observationTerms
{
    optionPayout: template::OptionPayout[*];
    observationTerms: schedule::ObservationTerms[*];
}

Association cdm_assoc::OptionPayout_CalculationSchedule_schedule
{
    optionPayout: template::OptionPayout[*];
    schedule: template::CalculationSchedule[*];
}

Association cdm_assoc::OptionPayout_AssetDeliveryInformation_delivery
{
    optionPayout: template::OptionPayout[*];
    delivery: product::AssetDeliveryInformation[*];
}

Association cdm_assoc::OptionPayout_ExerciseTerms_exerciseTerms
{
    optionPayout: template::OptionPayout[*];
    exerciseTerms: template::ExerciseTerms[*];
}

Association cdm_assoc::OptionPayout_OptionStrike_strike
{
    optionPayout: template::OptionPayout[*];
    strike: template::OptionStrike[*];
}

Association cdm_assoc::ReturnTerms_PriceReturnTerms_priceReturnTerms
{
    returnTerms: template::ReturnTerms[*];
    priceReturnTerms: product::PriceReturnTerms[*];
}

Association cdm_assoc::ReturnTerms_DividendReturnTerms_dividendReturnTerms
{
    returnTerms: template::ReturnTerms[*];
    dividendReturnTerms: product::DividendReturnTerms[*];
}

Association cdm_assoc::ReturnTerms_VarianceReturnTerms_varianceReturnTerms
{
    returnTerms: template::ReturnTerms[*];
    varianceReturnTerms: product::VarianceReturnTerms[*];
}

Association cdm_assoc::ReturnTerms_VolatilityReturnTerms_volatilityReturnTerms
{
    returnTerms: template::ReturnTerms[*];
    volatilityReturnTerms: product::VolatilityReturnTerms[*];
}

Association cdm_assoc::ReturnTerms_CorrelationReturnTerms_correlationReturnTerms
{
    returnTerms: template::ReturnTerms[*];
    correlationReturnTerms: product::CorrelationReturnTerms[*];
}

Association cdm_assoc::PerformancePayout_ObservationTerms_observationTerms
{
    performancePayout: template::PerformancePayout[*];
    observationTerms: schedule::ObservationTerms[*];
}

Association cdm_assoc::PerformancePayout_ValuationDates_valuationDates
{
    performancePayout: template::PerformancePayout[*];
    valuationDates: observable::ValuationDates[*];
}

Association cdm_assoc::PerformancePayout_PaymentDates_paymentDates
{
    performancePayout: template::PerformancePayout[*];
    paymentDates: schedule::PaymentDates[*];
}

Association cdm_assoc::PerformancePayout_FxFeature_fxFeature
{
    performancePayout: template::PerformancePayout[*];
    fxFeature: template::FxFeature[*];
}

Association cdm_assoc::PerformancePayout_ReturnTerms_returnTerms
{
    performancePayout: template::PerformancePayout[*];
    returnTerms: template::ReturnTerms[*];
}

Association cdm_assoc::PerformancePayout_PortfolioReturnTerms_portfolioReturnTerms
{
    performancePayout: template::PerformancePayout[*];
    portfolioReturnTerms: template::PortfolioReturnTerms[*];
}

Association cdm_assoc::PerformancePayout_PriceSchedule_initialValuationPrice
{
    performancePayout: template::PerformancePayout[*];
    initialValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::PerformancePayout_PriceSchedule_interimValuationPrice
{
    performancePayout: template::PerformancePayout[*];
    interimValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::PerformancePayout_PriceSchedule_finalValuationPrice
{
    performancePayout: template::PerformancePayout[*];
    finalValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::PortfolioReturnTerms_PayerReceiver_payerReceiver
{
    portfolioReturnTerms: template::PortfolioReturnTerms[*];
    payerReceiver: party::PayerReceiver[*];
}

Association cdm_assoc::PortfolioReturnTerms_PriceSchedule_initialValuationPrice
{
    portfolioReturnTerms: template::PortfolioReturnTerms[*];
    initialValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::PortfolioReturnTerms_PriceSchedule_interimValuationPrice
{
    portfolioReturnTerms: template::PortfolioReturnTerms[*];
    interimValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::PortfolioReturnTerms_PriceSchedule_finalValuationPrice
{
    portfolioReturnTerms: template::PortfolioReturnTerms[*];
    finalValuationPrice: observable::PriceSchedule[*];
}

Association cdm_assoc::NonTransferableProduct_ProductIdentifier_identifier
{
    nonTransferableProduct: template::NonTransferableProduct[*];
    identifier: asset::ProductIdentifier[*];
}

Association cdm_assoc::NonTransferableProduct_ProductTaxonomy_taxonomy
{
    nonTransferableProduct: template::NonTransferableProduct[*];
    taxonomy: asset::ProductTaxonomy[*];
}

Association cdm_assoc::NonTransferableProduct_EconomicTerms_economicTerms
{
    nonTransferableProduct: template::NonTransferableProduct[*];
    economicTerms: template::EconomicTerms[*];
}

Association cdm_assoc::TradeLot_Identifier_lotIdentifier
{
    tradeLot: template::TradeLot[*];
    lotIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::TradeLot_PriceQuantity_priceQuantity
{
    tradeLot: template::TradeLot[*];
    priceQuantity: observable::PriceQuantity[*];
}

Association cdm_assoc::TradableProduct_NonTransferableProduct_product
{
    tradableProduct: template::TradableProduct[*];
    product: template::NonTransferableProduct[*];
}

Association cdm_assoc::TradableProduct_TradeLot_tradeLot
{
    tradableProduct: template::TradableProduct[*];
    tradeLot: template::TradeLot[*];
}

Association cdm_assoc::TradableProduct_Counterparty_counterparty
{
    tradableProduct: template::TradableProduct[*];
    counterparty: party::Counterparty[*];
}

Association cdm_assoc::TradableProduct_AncillaryParty_ancillaryParty
{
    tradableProduct: template::TradableProduct[*];
    ancillaryParty: party::AncillaryParty[*];
}

Association cdm_assoc::SettlementPayout_AssetDeliveryInformation_delivery
{
    settlementPayout: template::SettlementPayout[*];
    delivery: product::AssetDeliveryInformation[*];
}

Association cdm_assoc::SettlementPayout_CalculationSchedule_schedule
{
    settlementPayout: template::SettlementPayout[*];
    schedule: template::CalculationSchedule[*];
}

Association cdm_assoc::CalculationSchedule_SchedulePeriod_schedulePeriod
{
    calculationSchedule: template::CalculationSchedule[*];
    schedulePeriod: template::SchedulePeriod[*];
}

Association cdm_assoc::SchedulePeriod_DateRange_calculationPeriod
{
    schedulePeriod: template::SchedulePeriod[*];
    calculationPeriod: datetime::DateRange[*];
}

Association cdm_assoc::SchedulePeriod_DateRange_fixingPeriod
{
    schedulePeriod: template::SchedulePeriod[*];
    fixingPeriod: datetime::DateRange[*];
}

Association cdm_assoc::SchedulePeriod_CalculationScheduleDeliveryPeriods_deliveryPeriod
{
    schedulePeriod: template::SchedulePeriod[*];
    deliveryPeriod: product::CalculationScheduleDeliveryPeriods[*];
}

Association cdm_assoc::FixedPricePayout_PaymentDates_paymentDates
{
    fixedPricePayout: template::FixedPricePayout[*];
    paymentDates: schedule::PaymentDates[*];
}

Association cdm_assoc::FixedPricePayout_FixedPrice_fixedPrice
{
    fixedPricePayout: template::FixedPricePayout[*];
    fixedPrice: settlement::FixedPrice[*];
}

Association cdm_assoc::FixedPricePayout_CalculationSchedule_schedule
{
    fixedPricePayout: template::FixedPricePayout[*];
    schedule: template::CalculationSchedule[*];
}

Association cdm_assoc::CancelableProvision_ExerciseNotice_exerciseNotice
{
    cancelableProvision: template::CancelableProvision[*];
    exerciseNotice: template::ExerciseNotice[*];
}

Association cdm_assoc::CancelableProvision_CancelableProvisionAdjustedDates_cancelableProvisionAdjustedDates
{
    cancelableProvision: template::CancelableProvision[*];
    cancelableProvisionAdjustedDates: template::CancelableProvisionAdjustedDates[*];
}

Association cdm_assoc::CancelableProvision_FinalCalculationPeriodDateAdjustment_finalCalculationPeriodDateAdjustment
{
    cancelableProvision: template::CancelableProvision[*];
    finalCalculationPeriodDateAdjustment: schedule::FinalCalculationPeriodDateAdjustment[*];
}

Association cdm_assoc::CancelableProvision_Transfer_initialFee
{
    cancelableProvision: template::CancelableProvision[*];
    initialFee: event::Transfer[*];
}

Association cdm_assoc::CancelableProvision_AdjustableOrRelativeDate_earliestDate
{
    cancelableProvision: template::CancelableProvision[*];
    earliestDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::CancelableProvision_AdjustableOrRelativeDate_expirationDate
{
    cancelableProvision: template::CancelableProvision[*];
    expirationDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::CancelableProvision_AdjustableOrRelativeDates_effectiveDate
{
    cancelableProvision: template::CancelableProvision[*];
    effectiveDate: datetime::AdjustableOrRelativeDates[*];
}

Association cdm_assoc::CancelableProvision_Period_effectivePeriod
{
    cancelableProvision: template::CancelableProvision[*];
    effectivePeriod: datetime::Period[*];
}

Association cdm_assoc::CancelableProvision_BusinessCenterTime_earliestCancellationTime
{
    cancelableProvision: template::CancelableProvision[*];
    earliestCancellationTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::CancelableProvision_BusinessCenterTime_latestCancelationTime
{
    cancelableProvision: template::CancelableProvision[*];
    latestCancelationTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::CancelableProvision_ExerciseTerms_exerciseTerms
{
    cancelableProvision: template::CancelableProvision[*];
    exerciseTerms: template::ExerciseTerms[*];
}

Association cdm_assoc::CancelableProvisionAdjustedDates_CancellationEvent_cancellationEvent
{
    cancelableProvisionAdjustedDates: template::CancelableProvisionAdjustedDates[*];
    cancellationEvent: template::CancellationEvent[*];
}

Association cdm_assoc::EarlyTerminationProvision_MandatoryEarlyTermination_mandatoryEarlyTermination
{
    earlyTerminationProvision: template::EarlyTerminationProvision[*];
    mandatoryEarlyTermination: template::MandatoryEarlyTermination[*];
}

Association cdm_assoc::EarlyTerminationProvision_Period_mandatoryEarlyTerminationDateTenor
{
    earlyTerminationProvision: template::EarlyTerminationProvision[*];
    mandatoryEarlyTerminationDateTenor: datetime::Period[*];
}

Association cdm_assoc::EarlyTerminationProvision_OptionalEarlyTermination_optionalEarlyTermination
{
    earlyTerminationProvision: template::EarlyTerminationProvision[*];
    optionalEarlyTermination: template::OptionalEarlyTermination[*];
}

Association cdm_assoc::EarlyTerminationProvision_ExercisePeriod_optionalEarlyTerminationParameters
{
    earlyTerminationProvision: template::EarlyTerminationProvision[*];
    optionalEarlyTerminationParameters: template::ExercisePeriod[*];
}

Association cdm_assoc::ExercisePeriod_Period_earliestExerciseDateTenor
{
    exercisePeriod: template::ExercisePeriod[*];
    earliestExerciseDateTenor: datetime::Period[*];
}

Association cdm_assoc::ExercisePeriod_Period_exerciseFrequency
{
    exercisePeriod: template::ExercisePeriod[*];
    exerciseFrequency: datetime::Period[*];
}

Association cdm_assoc::ExtendibleProvision_ExerciseNotice_exerciseNotice
{
    extendibleProvision: template::ExtendibleProvision[*];
    exerciseNotice: template::ExerciseNotice[*];
}

Association cdm_assoc::ExtendibleProvision_ExtendibleProvisionAdjustedDates_extendibleProvisionAdjustedDates
{
    extendibleProvision: template::ExtendibleProvision[*];
    extendibleProvisionAdjustedDates: template::ExtendibleProvisionAdjustedDates[*];
}

Association cdm_assoc::ExtendibleProvision_RelativeDateOffset_noticeDeadlinePeriod
{
    extendibleProvision: template::ExtendibleProvision[*];
    noticeDeadlinePeriod: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::ExtendibleProvision_RelativeDateOffset_extensionTerm
{
    extendibleProvision: template::ExtendibleProvision[*];
    extensionTerm: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::ExtendibleProvision_AdjustableRelativeOrPeriodicDates_extensionPeriod
{
    extendibleProvision: template::ExtendibleProvision[*];
    extensionPeriod: datetime::AdjustableRelativeOrPeriodicDates[*];
}

Association cdm_assoc::ExtendibleProvision_ExerciseTerms_exerciseTerms
{
    extendibleProvision: template::ExtendibleProvision[*];
    exerciseTerms: template::ExerciseTerms[*];
}

Association cdm_assoc::ExtendibleProvisionAdjustedDates_ExtensionEvent_extensionEvent
{
    extendibleProvisionAdjustedDates: template::ExtendibleProvisionAdjustedDates[*];
    extensionEvent: template::ExtensionEvent[*];
}

Association cdm_assoc::MandatoryEarlyTermination_AdjustableDate_mandatoryEarlyTerminationDate
{
    mandatoryEarlyTermination: template::MandatoryEarlyTermination[*];
    mandatoryEarlyTerminationDate: datetime::AdjustableDate[*];
}

Association cdm_assoc::MandatoryEarlyTermination_CalculationAgent_calculationAgent
{
    mandatoryEarlyTermination: template::MandatoryEarlyTermination[*];
    calculationAgent: observable::CalculationAgent[*];
}

Association cdm_assoc::MandatoryEarlyTermination_SettlementTerms_cashSettlement
{
    mandatoryEarlyTermination: template::MandatoryEarlyTermination[*];
    cashSettlement: settlement::SettlementTerms[*];
}

Association cdm_assoc::MandatoryEarlyTermination_MandatoryEarlyTerminationAdjustedDates_mandatoryEarlyTerminationAdjustedDates
{
    mandatoryEarlyTermination: template::MandatoryEarlyTermination[*];
    mandatoryEarlyTerminationAdjustedDates: template::MandatoryEarlyTerminationAdjustedDates[*];
}

Association cdm_assoc::OptionalEarlyTermination_BuyerSeller_singlePartyOption
{
    optionalEarlyTermination: template::OptionalEarlyTermination[*];
    singlePartyOption: party::BuyerSeller[*];
}

Association cdm_assoc::OptionalEarlyTermination_ExerciseNotice_exerciseNotice
{
    optionalEarlyTermination: template::OptionalEarlyTermination[*];
    exerciseNotice: template::ExerciseNotice[*];
}

Association cdm_assoc::OptionalEarlyTermination_CalculationAgent_calculationAgent
{
    optionalEarlyTermination: template::OptionalEarlyTermination[*];
    calculationAgent: observable::CalculationAgent[*];
}

Association cdm_assoc::OptionalEarlyTermination_SettlementTerms_cashSettlement
{
    optionalEarlyTermination: template::OptionalEarlyTermination[*];
    cashSettlement: settlement::SettlementTerms[*];
}

Association cdm_assoc::OptionalEarlyTermination_OptionalEarlyTerminationAdjustedDates_optionalEarlyTerminationAdjustedDates
{
    optionalEarlyTermination: template::OptionalEarlyTermination[*];
    optionalEarlyTerminationAdjustedDates: template::OptionalEarlyTerminationAdjustedDates[*];
}

Association cdm_assoc::OptionalEarlyTermination_ExerciseTerms_exerciseTerms
{
    optionalEarlyTermination: template::OptionalEarlyTermination[*];
    exerciseTerms: template::ExerciseTerms[*];
}

Association cdm_assoc::OptionalEarlyTerminationAdjustedDates_EarlyTerminationEvent_earlyTerminationEvent
{
    optionalEarlyTerminationAdjustedDates: template::OptionalEarlyTerminationAdjustedDates[*];
    earlyTerminationEvent: template::EarlyTerminationEvent[*];
}

Association cdm_assoc::AveragingFeature_AveragingCalculation_averagingCalculation
{
    averagingFeature: template::AveragingFeature[*];
    averagingCalculation: template::AveragingCalculation[*];
}

Association cdm_assoc::AveragingFeature_AveragingPeriod_averagingPeriodIn
{
    averagingFeature: template::AveragingFeature[*];
    averagingPeriodIn: schedule::AveragingPeriod[*];
}

Association cdm_assoc::AveragingFeature_AveragingPeriod_averagingPeriodOut
{
    averagingFeature: template::AveragingFeature[*];
    averagingPeriodOut: schedule::AveragingPeriod[*];
}

Association cdm_assoc::AveragingCalculation_AveragingCalculationMethod_averagingMethod
{
    averagingCalculation: template::AveragingCalculation[*];
    averagingMethod: math::AveragingCalculationMethod[*];
}

Association cdm_assoc::AveragingCalculation_Rounding_precision
{
    averagingCalculation: template::AveragingCalculation[*];
    precision: math::Rounding[*];
}

Association cdm_assoc::AveragingStrikeFeature_AveragingCalculation_averagingCalculation
{
    averagingStrikeFeature: template::AveragingStrikeFeature[*];
    averagingCalculation: template::AveragingCalculation[*];
}

Association cdm_assoc::AveragingStrikeFeature_ObservationTerms_observationTerms
{
    averagingStrikeFeature: template::AveragingStrikeFeature[*];
    observationTerms: schedule::ObservationTerms[*];
}

Association cdm_assoc::Barrier_TriggerEvent_knockIn
{
    barrier: template::Barrier[*];
    knockIn: observable::TriggerEvent[*];
}

Association cdm_assoc::Barrier_TriggerEvent_knockOut
{
    barrier: template::Barrier[*];
    knockOut: observable::TriggerEvent[*];
}

Association cdm_assoc::CalendarSpread_AdjustableOrRelativeDate_expirationDateTwo
{
    calendarSpread: template::CalendarSpread[*];
    expirationDateTwo: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::Composite_RelativeDateOffset_relativeDate
{
    composite: template::Composite[*];
    relativeDate: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::Composite_FxSpotRateSource_fxSpotRateSource
{
    composite: template::Composite[*];
    fxSpotRateSource: observable::FxSpotRateSource[*];
}

Association cdm_assoc::Composite_BusinessCenterTime_fixingTime
{
    composite: template::Composite[*];
    fixingTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::FxFeature_Composite_composite
{
    fxFeature: template::FxFeature[*];
    composite: template::Composite[*];
}

Association cdm_assoc::FxFeature_Quanto_quanto
{
    fxFeature: template::FxFeature[*];
    quanto: template::Quanto[*];
}

Association cdm_assoc::FxFeature_Composite_crossCurrency
{
    fxFeature: template::FxFeature[*];
    crossCurrency: template::Composite[*];
}

Association cdm_assoc::OptionFeature_FxFeature_fxFeature
{
    optionFeature: template::OptionFeature[*];
    fxFeature: template::FxFeature[*];
}

Association cdm_assoc::OptionFeature_StrategyFeature_strategyFeature
{
    optionFeature: template::OptionFeature[*];
    strategyFeature: template::StrategyFeature[*];
}

Association cdm_assoc::OptionFeature_AveragingFeature_averagingFeature
{
    optionFeature: template::OptionFeature[*];
    averagingFeature: template::AveragingFeature[*];
}

Association cdm_assoc::OptionFeature_Barrier_barrier
{
    optionFeature: template::OptionFeature[*];
    barrier: template::Barrier[*];
}

Association cdm_assoc::OptionFeature_PassThrough_passThrough
{
    optionFeature: template::OptionFeature[*];
    passThrough: template::PassThrough[*];
}

Association cdm_assoc::TerminationProvision_CancelableProvision_cancelableProvision
{
    terminationProvision: template::TerminationProvision[*];
    cancelableProvision: template::CancelableProvision[*];
}

Association cdm_assoc::TerminationProvision_EarlyTerminationProvision_earlyTerminationProvision
{
    terminationProvision: template::TerminationProvision[*];
    earlyTerminationProvision: template::EarlyTerminationProvision[*];
}

Association cdm_assoc::TerminationProvision_EvergreenProvision_evergreenProvision
{
    terminationProvision: template::TerminationProvision[*];
    evergreenProvision: template::EvergreenProvision[*];
}

Association cdm_assoc::TerminationProvision_ExtendibleProvision_extendibleProvision
{
    terminationProvision: template::TerminationProvision[*];
    extendibleProvision: template::ExtendibleProvision[*];
}

Association cdm_assoc::TerminationProvision_RecallProvision_recallProvision
{
    terminationProvision: template::TerminationProvision[*];
    recallProvision: template::RecallProvision[*];
}

Association cdm_assoc::RecallProvision_TimeZone_issuanceCutoffTime
{
    recallProvision: template::RecallProvision[*];
    issuanceCutoffTime: datetime::TimeZone[*];
}

Association cdm_assoc::RecallProvision_TimeZone_notificationTime
{
    recallProvision: template::RecallProvision[*];
    notificationTime: datetime::TimeZone[*];
}

Association cdm_assoc::RecallProvision_RelativeDateOffset_intendedSettlementDate
{
    recallProvision: template::RecallProvision[*];
    intendedSettlementDate: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::OptionStrike_FixedRateSpecification_strikeReference
{
    optionStrike: template::OptionStrike[*];
    strikeReference: product::FixedRateSpecification[*];
}

Association cdm_assoc::OptionStrike_ReferenceSwapCurve_referenceSwapCurve
{
    optionStrike: template::OptionStrike[*];
    referenceSwapCurve: observable::ReferenceSwapCurve[*];
}

Association cdm_assoc::OptionStrike_AveragingStrikeFeature_averagingStrikeFeature
{
    optionStrike: template::OptionStrike[*];
    averagingStrikeFeature: template::AveragingStrikeFeature[*];
}

Association cdm_assoc::PassThrough_PassThroughItem_passThroughItem
{
    passThrough: template::PassThrough[*];
    passThroughItem: template::PassThroughItem[*];
}

Association cdm_assoc::PassThroughItem_PayerReceiver_payerReceiver
{
    passThroughItem: template::PassThroughItem[*];
    payerReceiver: party::PayerReceiver[*];
}

Association cdm_assoc::Quanto_FxRate_fxRate
{
    quanto: template::Quanto[*];
    fxRate: observable::FxRate[*];
}

Association cdm_assoc::Quanto_FxSpotRateSource_fxSpotRateSource
{
    quanto: template::Quanto[*];
    fxSpotRateSource: observable::FxSpotRateSource[*];
}

Association cdm_assoc::Quanto_BusinessCenterTime_fixingTime
{
    quanto: template::Quanto[*];
    fixingTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::StrategyFeature_StrikeSpread_strikeSpread
{
    strategyFeature: template::StrategyFeature[*];
    strikeSpread: template::StrikeSpread[*];
}

Association cdm_assoc::StrategyFeature_CalendarSpread_calendarSpread
{
    strategyFeature: template::StrategyFeature[*];
    calendarSpread: template::CalendarSpread[*];
}

Association cdm_assoc::StrikeSpread_OptionStrike_upperStrike
{
    strikeSpread: template::StrikeSpread[*];
    upperStrike: template::OptionStrike[*];
}

Association cdm_assoc::ExerciseTerms_AdjustableOrRelativeDate_commencementDate
{
    exerciseTerms: template::ExerciseTerms[*];
    commencementDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::ExerciseTerms_AdjustableOrRelativeDates_exerciseDates
{
    exerciseTerms: template::ExerciseTerms[*];
    exerciseDates: datetime::AdjustableOrRelativeDates[*];
}

Association cdm_assoc::ExerciseTerms_AdjustableOrRelativeDate_expirationDate
{
    exerciseTerms: template::ExerciseTerms[*];
    expirationDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::ExerciseTerms_AdjustableOrRelativeDates_relevantUnderlyingDate
{
    exerciseTerms: template::ExerciseTerms[*];
    relevantUnderlyingDate: datetime::AdjustableOrRelativeDates[*];
}

Association cdm_assoc::ExerciseTerms_BusinessCenterTime_earliestExerciseTime
{
    exerciseTerms: template::ExerciseTerms[*];
    earliestExerciseTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::ExerciseTerms_BusinessCenterTime_latestExerciseTime
{
    exerciseTerms: template::ExerciseTerms[*];
    latestExerciseTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::ExerciseTerms_BusinessCenterTime_expirationTime
{
    exerciseTerms: template::ExerciseTerms[*];
    expirationTime: datetime::BusinessCenterTime[*];
}

Association cdm_assoc::ExerciseTerms_MultipleExercise_multipleExercise
{
    exerciseTerms: template::ExerciseTerms[*];
    multipleExercise: template::MultipleExercise[*];
}

Association cdm_assoc::ExerciseTerms_ExerciseFeeSchedule_exerciseFeeSchedule
{
    exerciseTerms: template::ExerciseTerms[*];
    exerciseFeeSchedule: template::ExerciseFeeSchedule[*];
}

Association cdm_assoc::ExerciseTerms_ExerciseProcedure_exerciseProcedure
{
    exerciseTerms: template::ExerciseTerms[*];
    exerciseProcedure: template::ExerciseProcedure[*];
}

Association cdm_assoc::ExerciseTerms_ExerciseFee_exerciseFee
{
    exerciseTerms: template::ExerciseTerms[*];
    exerciseFee: template::ExerciseFee[*];
}

Association cdm_assoc::ExerciseTerms_PartialExercise_partialExercise
{
    exerciseTerms: template::ExerciseTerms[*];
    partialExercise: template::PartialExercise[*];
}

Association cdm_assoc::ExerciseFee_RelativeDateOffset_feePaymentDate
{
    exerciseFee: template::ExerciseFee[*];
    feePaymentDate: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::ExerciseFeeSchedule_AmountSchedule_feeAmountSchedule
{
    exerciseFeeSchedule: template::ExerciseFeeSchedule[*];
    feeAmountSchedule: schedule::AmountSchedule[*];
}

Association cdm_assoc::ExerciseFeeSchedule_Schedule_feeRateSchedule
{
    exerciseFeeSchedule: template::ExerciseFeeSchedule[*];
    feeRateSchedule: math::Schedule[*];
}

Association cdm_assoc::ExerciseFeeSchedule_RelativeDateOffset_feePaymentDate
{
    exerciseFeeSchedule: template::ExerciseFeeSchedule[*];
    feePaymentDate: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::ExerciseProcedure_ManualExercise_manualExercise
{
    exerciseProcedure: template::ExerciseProcedure[*];
    manualExercise: template::ManualExercise[*];
}

Association cdm_assoc::ExerciseProcedure_AutomaticExercise_automaticExercise
{
    exerciseProcedure: template::ExerciseProcedure[*];
    automaticExercise: template::AutomaticExercise[*];
}

Association cdm_assoc::ManualExercise_ExerciseNotice_exerciseNotice
{
    manualExercise: template::ManualExercise[*];
    exerciseNotice: template::ExerciseNotice[*];
}

Association cdm_assoc::AssetPayout_AssetLeg_assetLeg
{
    assetPayout: template::AssetPayout[*];
    assetLeg: template::AssetLeg[*];
}

Association cdm_assoc::AssetPayout_DividendTerms_dividendTerms
{
    assetPayout: template::AssetPayout[*];
    dividendTerms: template::DividendTerms[*];
}

Association cdm_assoc::DividendTerms_DividendPayoutRatio_manufacturedIncomeRequirement
{
    dividendTerms: template::DividendTerms[*];
    manufacturedIncomeRequirement: product::DividendPayoutRatio[*];
}

Association cdm_assoc::AssetLeg_AdjustableOrRelativeDate_settlementDate
{
    assetLeg: template::AssetLeg[*];
    settlementDate: datetime::AdjustableOrRelativeDate[*];
}

Association cdm_assoc::EvergreenProvision_PartyRole_singlePartyOption
{
    evergreenProvision: template::EvergreenProvision[*];
    singlePartyOption: party::PartyRole[*];
}

Association cdm_assoc::EvergreenProvision_RelativeDateOffset_noticePeriod
{
    evergreenProvision: template::EvergreenProvision[*];
    noticePeriod: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::EvergreenProvision_RelativeDateOffset_noticeDeadlinePeriod
{
    evergreenProvision: template::EvergreenProvision[*];
    noticeDeadlinePeriod: datetime::RelativeDateOffset[*];
}

Association cdm_assoc::EvergreenProvision_AdjustableRelativeOrPeriodicDates_extensionFrequency
{
    evergreenProvision: template::EvergreenProvision[*];
    extensionFrequency: datetime::AdjustableRelativeOrPeriodicDates[*];
}

Association cdm_assoc::CreditLimitInformation_LimitApplicableExtended_limitApplicable
{
    creditLimitInformation: workflow::CreditLimitInformation[*];
    limitApplicable: workflow::LimitApplicableExtended[*];
}

Association cdm_assoc::CreditLimitUtilisation_CreditLimitUtilisationPosition_executed
{
    creditLimitUtilisation: workflow::CreditLimitUtilisation[*];
    executed: workflow::CreditLimitUtilisationPosition[*];
}

Association cdm_assoc::CreditLimitUtilisation_CreditLimitUtilisationPosition_pending
{
    creditLimitUtilisation: workflow::CreditLimitUtilisation[*];
    pending: workflow::CreditLimitUtilisationPosition[*];
}

Association cdm_assoc::WorkflowStepApproval_Party_party
{
    workflowStepApproval: workflow::WorkflowStepApproval[*];
    party: party::Party[*];
}

Association cdm_assoc::WorkflowStepApproval_EventTimestamp_timestamp
{
    workflowStepApproval: workflow::WorkflowStepApproval[*];
    timestamp: workflow::EventTimestamp[*];
}

Association cdm_assoc::WorkflowStep_BusinessEvent_businessEvent
{
    workflowStep: workflow::WorkflowStep[*];
    businessEvent: event::BusinessEvent[*];
}

Association cdm_assoc::WorkflowStep_CounterpartyPositionBusinessEvent_counterpartyPositionBusinessEvent
{
    workflowStep: workflow::WorkflowStep[*];
    counterpartyPositionBusinessEvent: event::CounterpartyPositionBusinessEvent[*];
}

Association cdm_assoc::WorkflowStep_EventInstruction_proposedEvent
{
    workflowStep: workflow::WorkflowStep[*];
    proposedEvent: workflow::EventInstruction[*];
}

Association cdm_assoc::WorkflowStep_WorkflowStepApproval_approval
{
    workflowStep: workflow::WorkflowStep[*];
    approval: workflow::WorkflowStepApproval[*];
}

Association cdm_assoc::WorkflowStep_EventInstruction_nextEvent
{
    workflowStep: workflow::WorkflowStep[*];
    nextEvent: workflow::EventInstruction[*];
}

Association cdm_assoc::WorkflowStep_MessageInformation_messageInformation
{
    workflowStep: workflow::WorkflowStep[*];
    messageInformation: workflow::MessageInformation[*];
}

Association cdm_assoc::WorkflowStep_EventTimestamp_timestamp
{
    workflowStep: workflow::WorkflowStep[*];
    timestamp: workflow::EventTimestamp[*];
}

Association cdm_assoc::WorkflowStep_Identifier_eventIdentifier
{
    workflowStep: workflow::WorkflowStep[*];
    eventIdentifier: identifier::Identifier[*];
}

Association cdm_assoc::WorkflowStep_Party_party
{
    workflowStep: workflow::WorkflowStep[*];
    party: party::Party[*];
}

Association cdm_assoc::WorkflowStep_Account_account
{
    workflowStep: workflow::WorkflowStep[*];
    account: party::Account[*];
}

Association cdm_assoc::WorkflowStep_Lineage_lineage
{
    workflowStep: workflow::WorkflowStep[*];
    lineage: event::Lineage[*];
}

Association cdm_assoc::WorkflowStep_CreditLimitInformation_creditLimitInformation
{
    workflowStep: workflow::WorkflowStep[*];
    creditLimitInformation: workflow::CreditLimitInformation[*];
}

Association cdm_assoc::Workflow_WorkflowStep_steps
{
    workflow: workflow::Workflow[*];
    steps: workflow::WorkflowStep[*];
}

Association cdm_assoc::EventInstruction_IdentifiedList_packageInformation
{
    eventInstruction: workflow::EventInstruction[*];
    packageInformation: identifier::IdentifiedList[*];
}

Association cdm_assoc::EventInstruction_Instruction_instruction
{
    eventInstruction: workflow::EventInstruction[*];
    instruction: event::Instruction[*];
}

Association cdm_assoc::WorkflowState_PartyCustomisedWorkflow_partyCustomisedWorkflow
{
    workflowState: workflow::WorkflowState[*];
    partyCustomisedWorkflow: workflow::PartyCustomisedWorkflow[*];
}

Association cdm_assoc::LimitApplicable_CreditLimitUtilisation_utilization
{
    limitApplicable: workflow::LimitApplicable[*];
    utilization: workflow::CreditLimitUtilisation[*];
}

Association cdm_assoc::LimitApplicable_Velocity_velocity
{
    limitApplicable: workflow::LimitApplicable[*];
    velocity: workflow::Velocity[*];
}

Association cdm_assoc::PartyCustomisedWorkflow_Party_partyReference
{
    partyCustomisedWorkflow: workflow::PartyCustomisedWorkflow[*];
    partyReference: party::Party[*];
}

Association cdm_assoc::PartyCustomisedWorkflow_CustomisedWorkflow_customisedWorkflow
{
    partyCustomisedWorkflow: workflow::PartyCustomisedWorkflow[*];
    customisedWorkflow: workflow::CustomisedWorkflow[*];
}
